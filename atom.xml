<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Max&#39;s Blog-程式學習研究記錄</title>
  <icon>https://www.gravatar.com/avatar/d4fa779638e91d085afca3ea034b7703</icon>
  <subtitle>求生是激發人的成長與潛能</subtitle>
  <link href="https://hand79.github.io/Blog/atom.xml" rel="self"/>
  
  <link href="https://hand79.github.io/Blog/"/>
  <updated>2021-01-18T06:24:20.764Z</updated>
  <id>https://hand79.github.io/Blog/</id>
  
  <author>
    <name>MaxHanChen</name>
    <email>maxdjkl@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>資料庫的問題</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210118-database-expansion-1.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210118-database-expansion-1.html</id>
    <published>2021-01-18T06:30:30.000Z</published>
    <updated>2021-01-18T06:24:20.764Z</updated>
    
    <content type="html"><![CDATA[<p>遇上的資料庫相關效能處理問題，處理方式記錄。</p><a id="more"></a><h3 id="讀寫分離架構"><a href="#讀寫分離架構" class="headerlink" title="讀寫分離架構"></a>讀寫分離架構</h3><p>master : 主要用寫的服務，會與 slave進行資料同步。<br>slave : 主要用來讀的服務。</p><ul><li>適用於讀多寫少情況。</li></ul><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><ul><li>時機: 單表資料量太大讀寫遇上瓶頸，增加slave、優化索引仍然無法解決時。</li></ul><h3 id="分庫"><a href="#分庫" class="headerlink" title="分庫"></a>分庫</h3><ul><li>時機: 單機讀寫遇上瓶頸，增加slave、優化索引仍然無法解決時。</li><li>目的就在於減少單台資料庫讀寫的負擔，縮短查詢時間。</li></ul><h3 id="DB遇上瓶頸，初步判斷各種可能的解決方法"><a href="#DB遇上瓶頸，初步判斷各種可能的解決方法" class="headerlink" title="DB遇上瓶頸，初步判斷各種可能的解決方法"></a>DB遇上瓶頸，初步判斷各種可能的解決方法</h3><ul><li>IO<ul><li>磁盤讀IO瓶頸，熱點資料太多，資料庫cache放不下，每次查詢時會產生大量的IO，降低查詢速度。<ul><li>圖片、檔案、影片等不存資料庫，降低負擔(檔案放入Amazon S3、FTP server等做存取，DB只做該檔案資料純文字索引)。</li><li>讀寫分離</li><li>另外架cache server 降低資料庫負擔(eg. Redis)。</li><li>分庫和垂直分表 </li></ul></li><li>網絡IO瓶頸，請求的資料太多，網絡帶寬不夠 <ul><li>減少一次請求的資料(這比較實際，有些工程師為了方便一次性查詢把所有資料查回來，但該階段根本用不到的資料(圖片、影片等單次請求)也一起回來了)</li><li>分庫</li></ul></li></ul></li><li>CPU<ul><li>SQL問題，如SQL中包含join，group by，order by，非索引字段條件查詢等，增加CPU運算的操作<ul><li>建立合適的索引，在Application layer進行計算(不透過資料庫處理複雜運算)。</li></ul></li><li>單表資料量太大，查詢時掃描的行太多，SQL效率低，增加CPU運算的操作 <ul><li>水平分表(使用者人數多的時候有機會遇到，根據資料熱點區間分散)。</li></ul></li></ul></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>須根據系統實際狀況處理，沒有一定法則。<br>以下是過取處理案子時的處理方式:</p><ul><li>選擇處理方案優先序:<ol><li>Application layer(應用程式問題)</li><li>檔案相關IO</li><li>快取設計(資料預熱、增加快取Server)、 獨立資料表、靜態常數化(該資料為常用資料)</li><li>讀寫分離(主要調整資料庫設定)</li><li>分區(Partition， 分割資料表，與水平分表(針對資料創資料表)類似但有不同，針對資料內容經由資料庫創建資料的分區，例如: 1~100 1區)</li><li>分表</li><li>分庫</li><li>分庫分表(最不得以的情況，通常這調整幅度比較大，包含資料庫和應用程式的調整)</li></ol></li></ul><p>參考: <a href="https://ithelp.ithome.com.tw/articles/10226783" target="_blank" rel="noopener">資料庫層的擴展 - 讀寫分離架構</a><br>參考: <a href="https://ithelp.ithome.com.tw/articles/10227066" target="_blank" rel="noopener">資料庫層的擴展 - 分庫分表架構</a><br>參考: <a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/742272/" target="_blank" rel="noopener">數據庫怎麼分庫分表，垂直？水平？</a><br>參考: <a href="https://kknews.cc/zh-tw/news/abvzkex.html" target="_blank" rel="noopener">資料庫分庫分表，何時分？怎樣分？</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;遇上的資料庫相關效能處理問題，處理方式記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>CI/CD 相關內容概念</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210107-CI-CD.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210107-CI-CD.html</id>
    <published>2021-01-07T06:30:30.000Z</published>
    <updated>2021-01-07T07:24:49.098Z</updated>
    
    <content type="html"><![CDATA[<p>概念解釋。</p><a id="more"></a><h3 id="Continuous-integration-CI，持續性整合"><a href="#Continuous-integration-CI，持續性整合" class="headerlink" title="Continuous integration(CI，持續性整合)"></a>Continuous integration(CI，持續性整合)</h3><ul><li>將開發人員對應用程序的更改被合併，系統將會通過自動生成應用並運行不同級別的自動化測試（通常是單元測試和整合測試）來驗證，確保這些更改沒有對程式功能造成破壞。測試內容涵蓋了從類和函數到構成整個應用的不同模塊。如果自動化測試發現新代碼和現有代碼之間存在衝突，可以更加輕鬆地快速修復這些錯誤。     </li><li>目的: 完成各程式碼的整合。應用程序的新更改會定期構建，測試並合併到共享存儲庫中，解決在一次開發中有太多應用分支，從而導致相互衝突的問題。</li></ul><h3 id="Continuous-Delivery-CD，持續性交付"><a href="#Continuous-Delivery-CD，持續性交付" class="headerlink" title="Continuous Delivery(CD，持續性交付)"></a>Continuous Delivery(CD，持續性交付)</h3><ul><li>完成CI中生成及單元測試和整合測試的自動化流程後，持續交付可自動將已驗證的程式碼發佈到存儲庫。為了實現高效的持續交付流程，必須確保CI已內置於開發管道。</li><li>目的: 是擁有一個可隨時部署到生產環境的程式庫。</li></ul><h3 id="Continuous-Deployment-CD，持續性部署"><a href="#Continuous-Deployment-CD，持續性部署" class="headerlink" title="Continuous Deployment(CD，持續性部署)"></a>Continuous Deployment(CD，持續性部署)</h3><ul><li>最後的階段是持續部署，自動部署到指定環境。</li><li>目的: 自動將預定的程式版本發佈到程式碼存儲庫的延伸，自動將程式發佈到生產環境。</li></ul><h2 id="CI-CD總結"><a href="#CI-CD總結" class="headerlink" title="CI/CD總結"></a>CI/CD總結</h2><ul><li>CI/CD 就是程式開發完畢後，把開發完成的程式碼進行測試與Code Review，通過後經過合併於主線(Main branch)後直接發佈上線(Prod, UAT等環境)，這樣的過程就是所謂的 CI/CD。</li><li>CI/CD常用工具:    <ul><li>GitLab CI</li><li>Travis CI</li><li>Bamboo (Atlassian家出的 CI)</li><li>Circle CI</li><li>Jenkins</li><li>Ansible </li></ul></li></ul><p>*<em>流程參考 Redhat *</em><br><img src="https://www.redhat.com/cms/managed-files/ci-cd-flow-desktop_1.png" alt="Redhat_CI_CD"></p><h3 id="Unit-Testing-單元測試"><a href="#Unit-Testing-單元測試" class="headerlink" title="Unit Testing (單元測試)"></a>Unit Testing (單元測試)</h3><ul><li>針對程式中的模組來進行正確性檢驗的測試工作，一個單元的定義可以是單個程式、函式、過程等內容，作為一個單元。(對於物件導向程式設計，最小單元就是方法，包括基礎類別（超類）、抽象類、或者衍生類別（子類）中的方法。)</li></ul><h3 id="System-Integration-Testing-SIT，整合測試"><a href="#System-Integration-Testing-SIT，整合測試" class="headerlink" title="System Integration Testing (SIT，整合測試)"></a>System Integration Testing (SIT，整合測試)</h3><ul><li>在單獨的軟體模組被合併作為一個組測試。在單元測試之後和在系統測試之前。整合測試在已經被單元測試檢驗後進行作為它的輸入，組織在更大的集合，和遞送，作為它的輸出，整合系統為系統測試做準備。</li><li>目的: 整合測試的目的是校驗功能、效能和可靠性要求，配置在主設計專案中。</li></ul><h3 id="System-Testing-系統測試"><a href="#System-Testing-系統測試" class="headerlink" title="System Testing (系統測試)"></a>System Testing (系統測試)</h3><ul><li>系統測試的涵蓋面很廣，主要包括功能測試、介面測試、可靠性測試、易用性測試、效能測試。 功能測試主要針對包括功能可用性、功能實現程度（功能流程&amp;業務流程、資料處理&amp;業務資料處理）方面測試。</li><li>壓力測試與效能測試差異<ul><li>壓力測試要求進行超過規定效能指標的測試。例如一個網站請求是100qps，壓力測試就要是採用120qps個同時請求的條件測試。<ul><li>判斷準則： 系統能夠恢復、壓力過程中不要有明顯效能下降</li></ul></li><li>效能測試是就是該系統的效能標準(eg. 80tps)</li></ul></li></ul><h3 id="Stress-Testing-壓力測試"><a href="#Stress-Testing-壓力測試" class="headerlink" title="Stress Testing (壓力測試)"></a>Stress Testing (壓力測試)</h3><ul><li>測驗系統在當下的軟硬體環境下能夠承受的請求有多少，用來計算出系統的極限。</li></ul><h3 id="User-Acceptance-Testing-UAT，使用者驗收測試"><a href="#User-Acceptance-Testing-UAT，使用者驗收測試" class="headerlink" title="User Acceptance Testing(UAT，使用者驗收測試)"></a>User Acceptance Testing(UAT，使用者驗收測試)</h3><ul><li>通常是由一般的使用者（通常這些使用者不瞭解軟體的具體邏輯，但對業務邏輯非常熟悉）進行的測試，因此是面向終端使用者的測試，結束後通常就可以佈署到正式環境了(Production)。</li></ul><p>###　其他</p><ul><li>TPS（每秒事務數）代表每秒執行的事務數量，由資料庫管理系統和用戶用於描述每秒鐘的資料庫操作數。例如，用戶每分鐘執行6個事務，TPS為6 / 60s = 0.10 TPS。</li><li>QPS：Queries Per Second意思是「每秒查詢率」，是一台伺服器每秒能夠相應的”查詢次數”，是對一個特定的查詢伺服器在規定時間內所處理流量多少的衡量標準。<br>More info: <a href="https://kknews.cc/zh-tw/code/nax2lv3.html" target="_blank" rel="noopener">相關參考1</a><br>More info: <a href="https://kknews.cc/news/zejoy8l.html" target="_blank" rel="noopener">相關參考2</a></li></ul><p>More info: <a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88" target="_blank" rel="noopener">Continuous integration(wiki)</a><br>More info: <a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E4%BA%A4%E4%BB%98" target="_blank" rel="noopener">Continuous Delivery(wiki)</a><br>More info: <a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" target="_blank" rel="noopener">CI/CD(RedHat)</a><br>More info: <a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">Software Testing(wiki)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;概念解釋。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Rest 無狀態的解釋</title>
    <link href="https://hand79.github.io/Blog/posts/Web/20210104-rest-stateless.html"/>
    <id>https://hand79.github.io/Blog/posts/Web/20210104-rest-stateless.html</id>
    <published>2021-01-04T06:30:30.000Z</published>
    <updated>2021-01-07T03:30:50.981Z</updated>
    
    <content type="html"><![CDATA[<p>每次都忘怎麼解釋，寫一下。</p><a id="more"></a><h3 id="Wiki-Rest擷取"><a href="#Wiki-Rest擷取" class="headerlink" title="Wiki Rest擷取"></a>Wiki Rest擷取</h3><ul><li>無狀態（Stateless）<ul><li>伺服器不能儲存客戶端的資訊,每一次從客戶端傳送的請求中, 要包含所有的必須的狀態資訊, 對談資訊由客戶端儲存, 伺服器端根據這些狀態資訊來處理請求. 伺服器可以將對談狀態資訊傳遞給其他服務, 比如資料庫服務, 這樣可以保持一段時間的狀態資訊, 從而實現認證功能. 當客戶端可以切換到一個新狀態的時候傳送請求資訊. 當一個或者多個請求被傳送之後, 客戶端就處於一個狀態變遷過程中. 每一個應用的狀態描述可以被客戶端用來初始化下一次的狀態變遷.</li></ul></li></ul><p>每次回過頭直接看這段Wiki翻的和原文我真心看不懂!!直到看了這個無狀態Server的解釋。</p><h3 id="無狀態Server"><a href="#無狀態Server" class="headerlink" title="無狀態Server"></a>無狀態Server</h3><ul><li>無狀態伺服器是指一種把每個請求作為與之前任何請求都無關的獨立的事務的伺服器。</li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><ul><li>無狀態 (Stateless) 是指從 Client 到 Server 的所有請求，皆需包含『 用於理解該次請求 』的 所有 相關信息，不得利用任何儲存在 Server 的上下文。</li><li>Server不得假定同一連接 上的兩個請求來自同一個 User Agent。</li><li>REST 中的『 狀態 』，是指 資源 與 表示 的狀態，而非無狀態 (Stateless) 架構約束中的 會話(Session)狀態。</li></ul><p>More info: <a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">Representational State Transfer (Rest)</a><br>More info: <a href="https://zh.wikipedia.org/wiki/%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE" target="_blank" rel="noopener">Stateless protocol (無狀態協議)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;每次都忘怎麼解釋，寫一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://hand79.github.io/Blog/categories/Web/"/>
    
    
    <category term="Web" scheme="https://hand79.github.io/Blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Session, Cookie, JWT相關概念</title>
    <link href="https://hand79.github.io/Blog/posts/Web/20210104-jwt-session-cookie.html"/>
    <id>https://hand79.github.io/Blog/posts/Web/20210104-jwt-session-cookie.html</id>
    <published>2021-01-04T05:30:20.000Z</published>
    <updated>2021-01-07T01:55:24.191Z</updated>
    
    <content type="html"><![CDATA[<p>概念整理。</p><a id="more"></a><h3 id="Session"><a href="#Session" class="headerlink" title="Session"></a>Session</h3><ul><li>原理: Client端連上Server時，Server會創建Session出來，Server向Client端瀏覽器傳送一個名為JSESSIONID的Cookie會以Cookie的形式傳回Client端，Session依據該Cookie來識別是否為同一使用者。<ul><li>該Cookie為伺服器自動生成的，它的maxAge屬性一般為–1，表示僅當前瀏覽器內有效，關閉瀏覽器就會失效。</li><li>Cookie被禁止時會以URL重寫的方式來處理，表現形式為http://…../xxx?jsessionid=xxxxx。</li></ul><ul><li>常有的錯誤想法:<ul><li>只要關閉瀏覽器，Session就消失了。沒有主動Call Server做登出的動作其實不會消除Session，Server會一直保留，因為Server這邊不會知道已經關閉瀏覽器了。會有這種錯覺，是大部分Session機制都使用Cookie來儲存Session id(瀏覽器上會看到jsessionid儲存這部分的資訊)， 而關閉瀏覽器後這個Session id就消失了，再次連線Server也就無法找到原來的Session。</li><li>如果Server產生的Cookie被儲存或者使用某種手段改寫瀏覽器發出的HTTP請求頭，把原來的Session id傳送給Server，則再次開啟瀏覽器仍然能夠找到原來的Session。</li><li>關閉瀏覽器不會導致Session被刪除，Server會為seesion設定了一個失效時間，當距離客戶端上一次使用Session的時間超過這個失效時間時，Server就可以認為Client端已經停止了活動，才會把Session刪除以節省儲存空間。</li></ul></li></ul></li></ul><h3 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h3><ul><li>不可跨域，會綁單一域名。</li><li>Cookie的maxAge決定著Cookie的有效期，單位為秒（Second)。</li><li>如果maxAge為負數，則表示該Cookie僅在本瀏覽器視窗以及本視窗開啟的子視窗內有效，關閉視窗後該Cookie即失效。maxAge為負數的Cookie，為臨時性Cookie，不會被持久化，不會被寫到Cookie檔案中。Cookie資訊儲存在瀏覽器記憶體中，因此關閉瀏覽器該Cookie就消失了。Cookie預設的maxAge值為–1。</li><li>如果maxAge為0，則表示刪除該Cookie。Cookie機制沒有提供刪除Cookie的方法，因此通過設定該Cookie即時失效實現刪除Cookie的效果。失效的Cookie會被瀏覽器從Cookie檔案或者記憶體中刪除。</li><li>不希望Cookie在HTTP等非安全協議中傳輸，可以設定Cookie的secure屬性為true。瀏覽器只會在HTTPS和SSL等安全協議中傳輸此類Cookie。<ul><li>secure屬性並不能對Cookie內容執行加密，因而不能保證絕對的安全性。若需要高安全性，需要在程式中對Cookie內容加密、解密，以防洩密。</li></ul></li></ul><h3 id="Session和Cookie的主要區別"><a href="#Session和Cookie的主要區別" class="headerlink" title="Session和Cookie的主要區別"></a>Session和Cookie的主要區別</h3><ul><li>安全性: Session比 Cookie安全<ul><li>Session是儲存Server端。</li><li>Cookie是儲存Client端，因此敏感資料不可放在這。</li></ul></li><li>存取類型:<ul><li>Cookie只支持存文字類型，想存其他類型的需做轉換(例: 用base64)。</li><li>Session可以儲存任意數據類型。</li></ul></li><li>儲存大小:<ul><li>Cookie: 至多4k。</li><li>Session: 遠高於Cookie，但過多的資料會佔用過多Server的資源。</li></ul></li><li>效期:<ul><li>Cookie: 關閉瀏覽器即失效、30天內有效與永久有效。通過設定Cookie的age屬性來實現。</li><li>Session: 至多上限24小時，實務上預設是30分鐘。</li></ul></li></ul><h3 id="JWT-JSON-Web-Token"><a href="#JWT-JSON-Web-Token" class="headerlink" title="JWT(JSON Web Token)"></a>JWT(JSON Web Token)</h3><ul><li>使用時機 :<ul><li>跨域下的請求。</li><li>一次性、時效短的請求。</li><li>身份驗證單點登入(SSO)。</li><li>Call Web API(eg. RESTful API)。</li></ul></li><li>JWT 主要分為三段，個別為 Header、Payload 與 Signature，以.做區隔，每一段都是透過 Base64去編碼，中間的 payload中有敏感資料會加密。<br>Header.Payload.Signature<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure></li><li>資料結構:<ul><li>Header</li></ul><ul><li>一個JSON對象， alg屬性表示簽名的算法（algorithm），默認為HMAC SHA256（寫成HS256）； typ屬性表示該令牌（token）的類型（type），JWT令牌統一寫為JWT。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;alg&quot;: &quot;HS256&quot;, # 加密的方法: HMAC、SHA256、RSA等</span><br><span class="line">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>Payload<ul><li>一個JSON對象，用於存放實際需要傳遞的資料。JWT規定了7個官方參數供選擇(建議但不強制使用)。</li><li>實際上這裡是明文，不適合儲存敏感資料(例如:使用者帳號密碼)。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">iss (issuer)：發行人</span><br><span class="line">exp (expiration time)：過期時間</span><br><span class="line">sub (subject)：主题</span><br><span class="line">aud (audience)：接收jwt的一方</span><br><span class="line">nbf (Not Before)：定義在什麼時間之前，該jwt都是不可用的，生效時間</span><br><span class="line">iat (Issued At)：簽發時間</span><br><span class="line">jti (JWT ID)：編號， jwt的唯一身份標識，主要用來作為一次性token,從而迴避replay attack</span><br></pre></td></tr></table></figure><ul><li>Signature<ul><li>針對Header與Payload產生，目的是防止資料竄改。</li><li>指定一個secret，只有Server知道secret才知道，不可洩漏給用戶，然後使用 Header裡面指定的簽名演算法。</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),  secret)</span><br></pre></td></tr></table></figure><p>Header、Payload 與 Signature之後用.串起來就是JWT，一般JWT放在HTTP的Authorization標頭中跟請求一起帶出去。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure><ul><li><p>安全的使用JWT:</p><ul><li>header: 確保指定唯一的decode algorithm。</li><li>payload: 不放入密鑰或敏感數據、設置置過期時間(exp)不要太長、驗證部分聲明(iss、aud等關鍵參數)。</li><li>signature: 密鑰的安全性(長度、密碼複雜度)、指定decode函數的簽名驗證等。</li><li>開啟 Http only 防止Token被擷取，是常見的來 XSS防護方法之一。</li><li>使用 Https 確保在授權的時候不會被竊取。</li><li>用來加密的 Secret要保存在 Server不應外流 。</li><li>replay attacks的問題可以多宣告 jti, exp處理。</li><li>黑名單機制(針對使用不當或不明原因進行手動防禦機制)、刷新機制。</li><li>Server端保有JWT權限的控制權(例如: 把JWT儲存Cache server中，移除及消除該JWT權限)。</li><li>權限的授權與token分離(該token只是帳密認證過，擁有什麼權限依然掌握在Server這邊的設定)。</li></ul></li><li><p>JWT vs Session 一些個人結論，認為都有可取之處:</p><ul><li>安全機制: JWT安全機制的細節較Session處理而言較為繁雜。</li><li>擴展: JWT較為方便，不過Session這邊也有不少解決方案(硬體: F5, 軟體: nginx, AWS: ELB等方案，關鍵字: sticky session)。</li></ul></li></ul><h3 id="Single-sign-on-SSO"><a href="#Single-sign-on-SSO" class="headerlink" title="Single sign-on (SSO)"></a>Single sign-on (SSO)</h3><ul><li>降低存取第三方網站的風險。</li><li>減少相同身份重新輸入密碼所花費的時間。</li><li>不同的使用者名稱和密碼組合衍生的問題(例如:忘記某一組帳號密碼)。</li><li>跨域認證: 一般橫跨不同伺服器的架構上身份驗證Server是獨立出來，Single sign-on(SSO)的方式來處理。<ul><li>Java類似的方案有:</li></ul><ul><li>Java Spring + Redis(利用Cache server的特性， 使用Redis存入Session或JWT的方式，讓Redis管理其時效，不同AP可以從中取得相關訊息)。</li></ul></li></ul><p>More info: <a href="https://en.wikipedia.org/wiki/JSON_Web_Token" target="_blank" rel="noopener">JSON Web Token(JWT)</a><br>More info: <a href="https://zh.wikipedia.org/wiki/Base64" target="_blank" rel="noopener">Base64 編碼</a><br>More info: <a href="https://en.wikipedia.org/wiki/Single_sign-on" target="_blank" rel="noopener">Single sign-on(SSO)</a><br>More info: <a href="https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB" target="_blank" rel="noopener">Replay attack</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;概念整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Web" scheme="https://hand79.github.io/Blog/categories/Web/"/>
    
    
    <category term="Web" scheme="https://hand79.github.io/Blog/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>Hexo與SEO</title>
    <link href="https://hand79.github.io/Blog/posts/Hexo/20201231-hexo-seo.html"/>
    <id>https://hand79.github.io/Blog/posts/Hexo/20201231-hexo-seo.html</id>
    <published>2020-12-31T14:37:00.000Z</published>
    <updated>2020-12-31T14:45:18.935Z</updated>
    
    <content type="html"><![CDATA[<p>寫到這邊才發現我忘了SEO這回事了，這邊寫個筆記。</p><a id="more"></a><h3 id="安裝-Hexo-外掛"><a href="#安裝-Hexo-外掛" class="headerlink" title="安裝 Hexo 外掛"></a>安裝 Hexo 外掛</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure><h3 id="config-yml檔案加入："><a href="#config-yml檔案加入：" class="headerlink" title="_config.yml檔案加入："></a>_config.yml檔案加入：</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">    path: sitemap.xml</span><br></pre></td></tr></table></figure><p>hexo g -d，重新編譯發佈，以下網址驗證一下是否建出</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">https://hand79.github.io/Blog//sitemap.xml</span><br></pre></td></tr></table></figure><h3 id="提交至-Google-Search-Console"><a href="#提交至-Google-Search-Console" class="headerlink" title="提交至 Google Search Console"></a>提交至 Google Search Console</h3><ol><li>打開 Google Search Console</li><li>進入「索引 &gt; Sitemap」</li><li>「新增 Sitemap」：sitemap.xml</li></ol><p>註: 若網站google-site-verification還沒處理，google會有幾個方案給你驗證網站的所有權，我選擇meta方案。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;meta name=<span class="string">"google-site-verification"</span> content=<span class="string">"XXXXX"</span> /&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;寫到這邊才發現我忘了SEO這回事了，這邊寫個筆記。&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo與LocalSearch</title>
    <link href="https://hand79.github.io/Blog/posts/Hexo/20201231-hexo-localsearch.html"/>
    <id>https://hand79.github.io/Blog/posts/Hexo/20201231-hexo-localsearch.html</id>
    <published>2020-12-31T13:35:00.000Z</published>
    <updated>2020-12-31T14:22:52.433Z</updated>
    
    <content type="html"><![CDATA[<p>添加LocalSearch搜尋功能</p><a id="more"></a><h2 id="安裝-hexo-generator-searchdb"><a href="#安裝-hexo-generator-searchdb" class="headerlink" title="安裝 hexo-generator-searchdb"></a>安裝 hexo-generator-searchdb</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure><h2 id="config-yml-設定"><a href="#config-yml-設定" class="headerlink" title="_config.yml 設定"></a>_config.yml 設定</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">search:</span><br><span class="line">  path: search.json</span><br><span class="line">  field: post</span><br><span class="line">  format: html</span><br><span class="line">  limit: 10000</span><br></pre></td></tr></table></figure><h2 id="啟用Local搜索功能："><a href="#啟用Local搜索功能：" class="headerlink" title="啟用Local搜索功能："></a>啟用Local搜索功能：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Local search</span><br><span class="line">local_search:</span><br><span class="line">  enable: true</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;添加LocalSearch搜尋功能&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo與RSS</title>
    <link href="https://hand79.github.io/Blog/posts/Hexo/20201231-hexo-plugin-rss.html"/>
    <id>https://hand79.github.io/Blog/posts/Hexo/20201231-hexo-plugin-rss.html</id>
    <published>2020-12-31T13:10:00.000Z</published>
    <updated>2020-12-31T13:26:06.047Z</updated>
    
    <content type="html"><![CDATA[<p>Hexo的主題上面一直有這個東西沒弄，到最後手癢還是找了方法弄了一下。</p><a id="more"></a><h3 id="安裝-Hexo-外掛"><a href="#安裝-Hexo-外掛" class="headerlink" title="安裝 Hexo 外掛"></a>安裝 Hexo 外掛</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure><p>_config.yml檔案加入：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">plugins: hexo-generator-feed</span><br><span class="line">rss: /atom.xml</span><br></pre></td></tr></table></figure><p>hexo g之後執行發佈</p><p>More info: <a href="https://zh.wikipedia.org/wiki/RSS" target="_blank" rel="noopener">RSS是什麼?，參考wiki</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Hexo的主題上面一直有這個東西沒弄，到最後手癢還是找了方法弄了一下。&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Ubuntu install deb file</title>
    <link href="https://hand79.github.io/Blog/posts/Linux/20201231-Ubuntu-cmd-dpkg.html"/>
    <id>https://hand79.github.io/Blog/posts/Linux/20201231-Ubuntu-cmd-dpkg.html</id>
    <published>2020-12-31T11:00:00.000Z</published>
    <updated>2020-12-31T13:05:37.902Z</updated>
    
    <content type="html"><![CDATA[<p>RedHat, Centos 這系列的是用rpm在裝，因為一些個人需求開始用ubuntu，弄個紀錄。 </p><a id="more"></a><h3 id="dpkg"><a href="#dpkg" class="headerlink" title="dpkg"></a>dpkg</h3><p>Ubuntu軟體包格式為deb,安裝方法如下:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">sudo dpkg -i xxxxx.deb (安裝用root權限，xxxx檔案名稱) or dpkg -i xxxxx.deb </span><br><span class="line"></span><br><span class="line">其他指令參考:</span><br><span class="line">dpkg -r xxxxx 刪除該包</span><br><span class="line">dpkg -P xxxxx 刪除該包(包括配置檔案)</span><br><span class="line">dpkg -L xxxxx 列出與該包關聯的檔案</span><br><span class="line">dpkg -l xxxxx 顯示該包的版本</span><br><span class="line">dpkg –unpack xxxxx.deb 解壓 deb</span><br><span class="line">dpkg -S xxxxx 搜尋所屬的包內容</span><br><span class="line">dpkg -l 列出當前已安裝的deb</span><br><span class="line">dpkg -c xxxxx.deb 列出 deb 包的內容</span><br><span class="line">dpkg –configure xxxxx 配置包</span><br><span class="line">man dpkg 詳細指令</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;RedHat, Centos 這系列的是用rpm在裝，因為一些個人需求開始用ubuntu，弄個紀錄。 &lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hand79.github.io/Blog/categories/Linux/"/>
    
    
    <category term="Ubuntu" scheme="https://hand79.github.io/Blog/tags/Ubuntu/"/>
    
  </entry>
  
  <entry>
    <title>Add Disqus.md</title>
    <link href="https://hand79.github.io/Blog/posts/Hexo/20201223-hexo-add-disqus-blog.html"/>
    <id>https://hand79.github.io/Blog/posts/Hexo/20201223-hexo-add-disqus-blog.html</id>
    <published>2020-12-23T08:39:00.000Z</published>
    <updated>2020-12-23T08:49:58.332Z</updated>
    
    <content type="html"><![CDATA[<p>Disqus留言板的添加</p><a id="more"></a><h2 id="處理流程"><a href="#處理流程" class="headerlink" title="處理流程"></a>處理流程</h2><p>. 先申請Disqus帳號<br>. 到後台管理區設定網址<br>. 複製提供的js程式碼，到需要用的位置(若本身Hexo就提供該功能可以省略，本文使用landscape)<br>. _config.yml 設定參數，主題若有其他參數需參考該主題</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">disqus_enabled: true</span><br><span class="line">disqus_shortname: xxxx (Disqus後台設定的名稱)</span><br><span class="line">disqus_count: true (計數)</span><br></pre></td></tr></table></figure><p>More info: <a href="https://disqus.com/" target="_blank" rel="noopener">Disqus</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Disqus留言板的添加&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo鏈結的中文標題問題</title>
    <link href="https://hand79.github.io/Blog/posts/Hexo/20201223-hexo-permalink-blog.html"/>
    <id>https://hand79.github.io/Blog/posts/Hexo/20201223-hexo-permalink-blog.html</id>
    <published>2020-12-23T08:30:00.000Z</published>
    <updated>2020-12-31T13:35:16.969Z</updated>
    
    <content type="html"><![CDATA[<p>版本: Hexo 4.20</p><a id="more"></a><h2 id="處理方式-config-yml修改"><a href="#處理方式-config-yml修改" class="headerlink" title="處理方式(_config.yml修改)"></a>處理方式(_config.yml修改)</h2><p>. 用urlname處理，並在各文章添加其值。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">permalink: posts&#x2F;:category&#x2F;:year:month:day-:urlname.html</span><br><span class="line">permalink_defaults:</span><br><span class="line">  lang: en</span><br></pre></td></tr></table></figure><p>. 套件處理</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class="line"># permalink_defaults:</span><br><span class="line">permalink: posts&#x2F;:abbrlink.html</span><br><span class="line">abbrlink:</span><br><span class="line">  alg: crc32  # crc16(default) and crc32</span><br><span class="line">  rep: hex    # dec(default) and hex</span><br></pre></td></tr></table></figure><p>More info: <a href="https://github.com/rozbo/hexo-abbrlink" target="_blank" rel="noopener">hexo-abbrlink</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;版本: Hexo 4.20&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Hexo設定permalink</title>
    <link href="https://hand79.github.io/Blog/posts/Hexo/20201223-hexo-permalink-blog.html"/>
    <id>https://hand79.github.io/Blog/posts/Hexo/20201223-hexo-permalink-blog.html</id>
    <published>2020-12-23T07:56:00.000Z</published>
    <updated>2020-12-31T13:35:00.931Z</updated>
    
    <content type="html"><![CDATA[<p>版本: Hexo 4.20</p><a id="more"></a><h2 id="config-yml"><a href="#config-yml" class="headerlink" title="_config.yml"></a>_config.yml</h2><p>. 用github為範例，{yourname}為名稱<br>. 主要是根節點的設定 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># URL</span><br><span class="line">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class="line">url: https:&#x2F;&#x2F;&#123;yourname&#125;.github.io&#x2F;Blog&#x2F;</span><br><span class="line">root: &#x2F;Blog&#x2F;</span><br></pre></td></tr></table></figure><p>More info: <a href="https://github.com/hexojs/hexo/issues/1812" target="_blank" rel="noopener">舊版的問題</a><br>More info: <a href="https://hexo.io/docs/configuration.html" target="_blank" rel="noopener">相關設定</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;版本: Hexo 4.20&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>Maven中的dependency的Scope功用</title>
    <link href="https://hand79.github.io/Blog/posts/Maven/20201124-maven-dependancy-scope.html"/>
    <id>https://hand79.github.io/Blog/posts/Maven/20201124-maven-dependancy-scope.html</id>
    <published>2020-11-24T11:10:00.000Z</published>
    <updated>2020-12-23T08:44:18.769Z</updated>
    
    <content type="html"><![CDATA[<p>Maven中的dependency的Scope功用</p><a id="more"></a><p>###compile</p><p> 預設值，jar是所有階段需要， 部署時將一起被打包到jar/war裡面。</p><p>###test</p><p>此jar檔只有在測試時才需要使用，部署時將不會打包到jar/war裡面。如 junit jar 等。</p><h3 id="runtime"><a href="#runtime" class="headerlink" title="runtime"></a>runtime</h3><p>表示此jar在運行時，才需要使用。如jdbc jar等。</p><p>###provided</p><p>運行時該jar檔由JDK、Tomcat及jboss等來提供。如 servlet.jar、jsp-api.jar 等。<br> 部署時將不會打包到jar/war裡面。</p><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3><p>jar檔由系統提供，跟provided相似。在maven repository是無法找到，須提供需指定systemPath來使用。<br>以外部JAR檔的形式提供。</p><h3 id="import"><a href="#import" class="headerlink" title="import"></a>import</h3><p>僅支援<dependencyManagement>區塊中且type僅為pom</p><p>dependencyManagement 和 dependencies的使用區別:</p><ul><li>dependencyManagement裡只是聲明依賴，並不實現引入，因此子項目需要顯示的聲明需要用的依賴。</li><li>如果不在子項目中聲明依賴，是不會從父項目中繼承下來的。</li><li>只有在子項目中寫了該依賴項且沒有指定具體版本，才會從讀取父項目中的pom繼承該項 version和scope。如果子項目中指定了版本號，那麼會使用子項目中指定的jar版本。</li></ul><p>More info: <a href="https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html" target="_blank" rel="noopener">Maven Scope</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Maven中的dependency的Scope功用&lt;/p&gt;</summary>
    
    
    
    <category term="Maven" scheme="https://hand79.github.io/Blog/categories/Maven/"/>
    
    
    <category term="Maven" scheme="https://hand79.github.io/Blog/tags/Maven/"/>
    
  </entry>
  
  <entry>
    <title>Tag 與 Category設定</title>
    <link href="https://hand79.github.io/Blog/posts/Hexo/20200223-hexo-tag-category.html"/>
    <id>https://hand79.github.io/Blog/posts/Hexo/20200223-hexo-tag-category.html</id>
    <published>2020-02-23T11:10:00.000Z</published>
    <updated>2020-12-31T13:01:45.811Z</updated>
    
    <content type="html"><![CDATA[<p>文章的Tag 與 Category設定</p><a id="more"></a><h3 id="config-yml-內容設定"><a href="#config-yml-內容設定" class="headerlink" title="_config.yml 內容設定"></a>_config.yml 內容設定</h3><p>blog 資料夾下 _config.yml設定。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">default_category: uncategorized</span><br><span class="line">category_map:</span><br><span class="line">  Hexo: Hexo</span><br><span class="line"> </span><br><span class="line">tag_map: </span><br><span class="line">  Hexo: Hexo</span><br></pre></td></tr></table></figure><p>.md 檔中加入設定再發布，就可以看效果。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">categories: Hexo</span><br><span class="line">tags: [Hexo]</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;文章的Tag 與 Category設定&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>文章時間設定</title>
    <link href="https://hand79.github.io/Blog/posts/Hexo/20200223-article-date-time-config.html"/>
    <id>https://hand79.github.io/Blog/posts/Hexo/20200223-article-date-time-config.html</id>
    <published>2020-02-23T11:00:00.000Z</published>
    <updated>2020-12-31T13:01:45.813Z</updated>
    
    <content type="html"><![CDATA[<p>文檔搬遷時，由於時間顯示都是文章檔案建立的時間，因此需做一點設定。</p><a id="more"></a><h3 id="config-yml-內容設定"><a href="#config-yml-內容設定" class="headerlink" title="_config.yml 內容設定"></a>_config.yml 內容設定</h3><p>blog 資料夾下 _config.yml，台灣時間作範例。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">timezone: Asia/Taipei</span><br><span class="line"></span><br><span class="line">date_format: YYYY-MM-DD HH:mm:ss </span><br><span class="line">time_format: HH:mm:ss</span><br></pre></td></tr></table></figure><p>.md 檔中加入date，就會是指定文章的時間了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">date: 2020-02-23 19:00:00</span><br></pre></td></tr></table></figure><p>More info: <a href="https://en.wikipedia.org/wiki/List_of_tz_database_time_zones" target="_blank" rel="noopener">時區參考</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;文檔搬遷時，由於時間顯示都是文章檔案建立的時間，因此需做一點設定。&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/tags/Hexo/"/>
    
  </entry>
  
  <entry>
    <title>建立Blog</title>
    <link href="https://hand79.github.io/Blog/posts/Hexo/20200222-hexo-bulid-blog.html"/>
    <id>https://hand79.github.io/Blog/posts/Hexo/20200222-hexo-bulid-blog.html</id>
    <published>2020-02-22T10:50:21.000Z</published>
    <updated>2020-12-31T13:01:45.815Z</updated>
    
    <content type="html"><![CDATA[<p>用Hexo + Node.js + Github 搭建簡易Blog</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><p>. 安裝 Node.js<br>. 安裝 Hexo Git</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>. 安裝 Hexo - 使用 npm(須先安裝 Node.js)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure><h3 id="Create"><a href="#Create" class="headerlink" title="Create"></a>Create</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ hexo init blog    <span class="comment"># 初始化 blog</span></span><br><span class="line">$ <span class="built_in">cd</span> blog           <span class="comment"># 移動到剛創建的 blog 資料夾裡</span></span><br><span class="line">$ npm install<span class="comment"># 安裝相關套件</span></span><br></pre></td></tr></table></figure><h3 id="Github-新建一個倉庫"><a href="#Github-新建一個倉庫" class="headerlink" title="Github 新建一個倉庫"></a>Github 新建一個倉庫</h3><p>. 倉庫名稱為 yourname</p><h3 id="blog-資料夾-內容設定"><a href="#blog-資料夾-內容設定" class="headerlink" title="blog 資料夾 內容設定"></a>blog 資料夾 內容設定</h3><p>再來到 blog 資料夾下找一個 _config.yml 開啟(root路徑設定為 “/repository/“，沒設定好css、js會抓不到)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">url: https://yourname.github.io</span><br><span class="line">root: /Blog/</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  <span class="built_in">type</span>: git</span><br><span class="line">  repository: http://github.com/yourname/yourname.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><h3 id="產生靜態文件和deploy-上-GitHub"><a href="#產生靜態文件和deploy-上-GitHub" class="headerlink" title="產生靜態文件和deploy 上 GitHub"></a>產生靜態文件和deploy 上 GitHub</h3><p>. clean 清除快取檔案 (db.json) 和已產生的靜態檔案 (public)。<br>. d是佈署<br>. g產生靜態文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo d -g</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/zh-tw/docs/commands.html" target="_blank" rel="noopener">Commands</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;用Hexo + Node.js + Github 搭建簡易Blog&lt;/p&gt;</summary>
    
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/categories/Hexo/"/>
    
    
    <category term="Hexo" scheme="https://hand79.github.io/Blog/tags/Hexo/"/>
    
  </entry>
  
</feed>
