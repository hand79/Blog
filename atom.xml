<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Max&#39;s Blog-程式學習研究記錄</title>
  <icon>https://www.gravatar.com/avatar/d4fa779638e91d085afca3ea034b7703</icon>
  <subtitle>求生是激發人的成長與潛能</subtitle>
  <link href="https://hand79.github.io/Blog/atom.xml" rel="self"/>
  
  <link href="https://hand79.github.io/Blog/"/>
  <updated>2021-02-17T13:30:46.688Z</updated>
  <id>https://hand79.github.io/Blog/</id>
  
  <author>
    <name>MaxHanChen</name>
    <email>maxdjkl@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Domain-Driven Design (DDD)</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210217-domain-driven-design.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210217-domain-driven-design.html</id>
    <published>2021-02-17T11:30:30.000Z</published>
    <updated>2021-02-17T13:30:46.688Z</updated>
    
    <content type="html"><![CDATA[<p>閱讀DDD相關文章重點整理。</p><a id="more"></a> <h2 id="Domain-Driven-Design"><a href="#Domain-Driven-Design" class="headerlink" title="Domain-Driven Design"></a>Domain-Driven Design</h2><p>價值: 把將商業領域的知識映照到程式碼中，解放「程式歸程式，業務歸業務」的傳統思維</p><h2 id="模型中有以下概念"><a href="#模型中有以下概念" class="headerlink" title="模型中有以下概念"></a>模型中有以下概念</h2><ul><li>上下文（Context）: 詞或句子出現的位置。</li><li>領域（Domain）: 知識，影響，或活動。客戶使用軟體要處理旳問題種類即為軟體的領域。</li><li>模型（Model）: 一類描述域的不同方面並可用於解決相關問題的系統化的抽象。</li><li>統一術語（Ubiquitous Language）: 一種團隊成員使用，為了描述域模型而構造的語言。 用於如下:<ul><li>User story 或RFC</li><li>任意的會議</li><li>書信往來</li><li>技術文件</li><li>流程或是行程</li><li>程式碼</li></ul></li></ul><h2 id="Building-blocks"><a href="#Building-blocks" class="headerlink" title="Building blocks"></a>Building blocks</h2><p>在領域驅動設計一書中[2]闡述了一些高層次的概念和實踐，比如通用語言，這意味著領域模型應該形成領域專家為描述系統需求而提供的共同語言，同樣的，這些語言也需要能夠被商業使用者或贊助商和軟體開發商使用。本書專注於將領域層描述為具有多層體系結構的物件導向系統中的常見層次之一。在 DDD 中，有表示，建立和檢索域模型的工件：</p><ul><li>Entity: 一個不由自身屬性定義而是由標識線和它的身分定義的物件。<br>例如：大多數航空公司在每次航班上都獨特地區分每個座位。每個席位都是在這種情況下的一個實體。不過，西南航空，EasyJet 和瑞安航空並沒有區分每個座位；所有的座位都是一樣的。在這種情況下，一個席位實際上是一個Value Object</li><li>Value Object: 只包含元素屬性的不可變物件。<br>例如：當人們交換名片時，他們一般不會區分每張獨特的名片；他們只關心印在卡片上的資訊。在這種情況下，名片是 Value Object</li><li>Service: 強調與其他物件的關係，只定義了可以為客戶做什麼，不應該替代 Entity 和 Value Object 的所有行為。</li><li>Module: 一種表達機制，劃分代碼和概念。</li><li>Factory: 對於那些需要建立特定域物件的方法應該委派給工廠物件，因為這樣可以更容易的替換實現。</li><li>Repository: 對於檢索特定域物件的方法應該委派給 Repository 物件，因為這樣可以很容易地互換替代儲存的實現。</li><li>Aggregate: 由 ROOT ENTITY 繫結在一起的物件的集合，也稱為聚合根。聚合根通過禁止外部物件保持對其成員的參照來保證在聚合內進行的更改的一致性。<br>例如：駕駛汽車時，不必擔心向前移動車輪，使發動機燃燒火花和燃料等。你只是在開車。在這種情況下，汽車是其他幾個物件的集合，並作為所有其他系統的聚合根</li><li>Domain Event: 一個域物件定義了一個事件。域事件是域專家所關心的事件。</li></ul><h2 id="貧血模型-Anemic-Model"><a href="#貧血模型-Anemic-Model" class="headerlink" title="貧血模型 (Anemic Model)"></a>貧血模型 (Anemic Model)</h2><p>特徵:<br>其中包含物件，許多物件會以領域空間中的名詞來命名，而且這些物件會透過真實領域模型所具有的豐富關聯性和結構來連接。<br>從行為上會看出端倪，並了解這些物件上幾乎沒有任何行為，比較像是一組 getter 和 setter。<br>使用 Anemic 領域模型時，會從一組擷取所有領域或商務邏輯的服務物件 (service，傳統上稱為「商務層」**) 來使用這些資料模型。 商務層位於資料模型最上層，其使用資料模型的方式就像是資料一樣。</p><p>重點節錄(來自微軟)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Anemic 領域模型只是程序樣式設計。 Anemic 實體物件不是真正的物件，因為它們缺少行為 (方法)。</span><br><span class="line">它們只會保存資料屬性，因此不是物件導向設計。</span><br><span class="line"></span><br><span class="line">藉由將所有的行為放入服務物件（商務層）中，您基本上會得到spaghetti 程式碼或交易腳本，</span><br><span class="line">因此您會失去領域模型所提供的優點。</span><br><span class="line"></span><br><span class="line">即便如此，如果您的微服務或限定內容很簡單 (CRUD 服務)，只有資料屬性之實體物件形式的 Anemic 領域模型便已足夠，</span><br><span class="line">而且可能不值得實作更複雜的 DDD 模式。 在此情況下，它只是持續性模型，因為您刻意建立只有 CRUD 用途資料的實體。</span><br><span class="line"></span><br><span class="line">這就是為什麼微服務架構對於根據每個限定內容之多架構方法很理想的原因。 </span><br><span class="line">例如，在 eShopOnContainers 中，</span><br><span class="line">訂購微服務會實作 DDD 模式，但目錄微服務是簡易 CRUD 服務，因此不會實作此模式。</span><br><span class="line">它其實取決於您實作的內容。 如果您要建立的微服務夠簡單 (例如 CRUD 服務)，遵循 Anemic 領域模型就不是反模式。</span><br><span class="line"></span><br><span class="line"> 不過，如果您需要處理微服務網域的複雜性，</span><br><span class="line"> 而此領域有許多不斷改變的商務規則，則 anemic 領域模型可能是該微服務或限定內容的反模式。</span><br><span class="line"> 在此情況下，將它設計為具有實體的豐富模型可能會相當有利於這類微服務的長期成功，</span><br><span class="line"> 因為這些實體包含資料加上行為，並實作額外的 DDD 模式 (彙總、值物件等)。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20171108161155976?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHJvdWJsZXNob290ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Anemic Model "></p><h2 id="豐富領域模型-Rich-Domain-Model"><a href="#豐富領域模型-Rich-Domain-Model" class="headerlink" title="豐富領域模型(Rich Domain Model)"></a>豐富領域模型(Rich Domain Model)</h2><p><img src="https://img-blog.csdn.net/20171108161246317?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHJvdWJsZXNob290ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Rich Domain Model "></p><p>架構參考:</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/95ed0cc001e94a8ba9f32666113169c9.png" alt="傳統架構 "></p><p>架構轉成DDD</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/d92764a7963f43068273133f9a1ac6f9.png" alt="DDD 之後"></p><h2 id="閱讀參考"><a href="#閱讀參考" class="headerlink" title="閱讀參考"></a>閱讀參考</h2><p>程式架構:<br><a href="https://developer.aliyun.com/article/716908" target="_blank" rel="noopener">阿里技术专家详解 DDD 系列- Domain Primitive</a><br><a href="https://developer.aliyun.com/article/719251" target="_blank" rel="noopener">阿里技术专家详解DDD系列 第二弹 - 应用架构</a><br><a href="https://juejin.cn/post/6845166890554228744" target="_blank" rel="noopener">阿里技术专家详解DDD系列 第三讲 - Repository模式 </a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650414919&idx=1&sn=0ad1df1a1b0e2488f7faa21008fdbdd0&chksm=8396d75fb4e15e49341b07022780dcb8dca66a0efb7f129d4de86a5ef5d8a890f6e0d2fd6432&scene=132#wechat_redirect" target="_blank" rel="noopener">DDD系列第四讲：领域层设计规范 </a></p><p>其他:<br><a href="https://blog.csdn.net/troubleshooter/article/details/78479984" target="_blank" rel="noopener">什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？</a><br><a href="https://blog.csdn.net/johnstrive/article/details/16805121?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control" target="_blank" rel="noopener">领域模型驱动设计（Domain Driven Design）入门概述</a><br><a href="https://blog.csdn.net/iteye_3055/article/details/82106174?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.control" target="_blank" rel="noopener">领域驱动设计(Domain Driven Design)参考架构详解</a><br><a href="https://docs.microsoft.com/zh-tw/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-domain-model" target="_blank" rel="noopener">微服務 - 架構電子書 (微軟) - 設計微服務領域模型</a><br><a href="https://ithelp.ithome.com.tw/articles/10216645" target="_blank" rel="noopener">關於 Domain-Driven Design 以及他的魅力　(這個上面寫的程式範例不太好，看其他文章範例)</a><br><a href="https://medium.com/tradeshift-engineering/my-vision-as-a-software-engineer-about-ddd-domain-driven-design-part-2-973bcf5a9848" target="_blank" rel="noopener">My vision, as a Software Engineer, about DDD (Domain Driven Design) — Part 2 (Java 為範例)</a><br><a href="https://hackmd.io/@ballfish/DDD" target="_blank" rel="noopener">Domain Driven Design</a><br><a href="https://www.cnblogs.com/daoqidelv/p/7648392.html" target="_blank" rel="noopener">【DDD】领域驱动设计实践 —— Domain层实现</a><br><a href="https://t.codebug.vip/questions-2083339.htm" target="_blank" rel="noopener">DDD 程式設計範例討論</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;閱讀DDD相關文章重點整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>資料庫Connection pool設定</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210217-database-connection-pool.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210217-database-connection-pool.html</id>
    <published>2021-02-17T09:30:30.000Z</published>
    <updated>2021-02-17T13:39:03.307Z</updated>
    
    <content type="html"><![CDATA[<p>相關文章重點整理。</p><a id="more"></a> <h2 id="誤區"><a href="#誤區" class="headerlink" title="誤區"></a>誤區</h2><p>資料庫連線池的大小越大越好? Ans: 絕對不是</p><h2 id="正確觀念"><a href="#正確觀念" class="headerlink" title="正確觀念"></a>正確觀念</h2><p>(maximumPoolSize: 連線池中允許的最大連線數) 連線數 = ((核心數 * 2) + 有效磁碟數)</p><h2 id="主要影響資料庫的效能瓶頸因素"><a href="#主要影響資料庫的效能瓶頸因素" class="headerlink" title="主要影響資料庫的效能瓶頸因素"></a>主要影響資料庫的效能瓶頸因素</h2><ul><li>CPU</li><li>磁碟 IO (SSD由於不像傳統硬碟需要定址、旋轉碟片，因此更少的阻塞 ，會更近似於CPU核心數)</li><li>網路 IO </li><li>SQL語法 </li></ul><p><a href="https://www.itread01.com/content/1547137124.html" target="_blank" rel="noopener">資料庫連線池DataSource (解釋連線池為何要使用)</a><br><a href="https://www.mdeditor.tw/pl/2FBd/zh-tw" target="_blank" rel="noopener">如何正確設定資料庫連線池的大小？</a><br><a href="https://www.youtube.com/watch?v=xNDnVOCdvQ0" target="_blank" rel="noopener">OLTP Performance - Concurrent Mid-Tier Connections (Oracle Learning Youtube)</a><br><a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">HikariCP 設定參數 (Github)</a><br><a href="https://www.mdeditor.tw/pl/piUT/zh-tw" target="_blank" rel="noopener">HikariCP 設定參數 (翻譯)</a><br><a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing" target="_blank" rel="noopener">About Pool Sizing - HikariCP (Github)</a><br><a href="https://www.itread01.com/content/1548895884.html" target="_blank" rel="noopener">Springboot datasource 常用配置說明</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;相關文章重點整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>SOA架構 與 Microservice</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210204-microservice-soa.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210204-microservice-soa.html</id>
    <published>2021-02-04T15:07:30.000Z</published>
    <updated>2021-02-04T15:09:56.475Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇到問題查詢的資料，做個整理。</p><a id="more"></a><h2 id="Service-Oriented-Architecture-SOA-服務導向架構"><a href="#Service-Oriented-Architecture-SOA-服務導向架構" class="headerlink" title="Service Oriented Architecture(SOA) 服務導向架構"></a>Service Oriented Architecture(SOA) 服務導向架構</h2><p>特性:</p><ul><li>針對某特定要求的輸出，該服務就是運作一項商業邏輯</li><li>具有完備的特性（self-contained）</li><li>消費者並不需要瞭解此服務的運作過程</li><li>可能由底層其他服務組成</li></ul><p>原則:</p><ul><li>可重複使用、粒度、模組性、可組合型、物件化原件、構件化以及具互動操作性</li><li>符合開放標準（通用的或行業的）</li><li>服務的識別和分類，提供和發布，監控和跟蹤。</li></ul><h2 id="SOA-所解決的核心問題"><a href="#SOA-所解決的核心問題" class="headerlink" title="SOA 所解決的核心問題"></a>SOA 所解決的核心問題</h2><ul><li>系統整合(技術層面)</li><li>系統的服務化(技術層面)</li><li>業務的服務化(是以業務驅動把一個 業務單元封裝成一項服務）</li></ul><p><img src="https://img-blog.csdnimg.cn/20181029125611787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4X0Zyb2xm,size_27,color_FFFFFF,t_70" alt="SOA"></p><h2 id="Microservices-微服務"><a href="#Microservices-微服務" class="headerlink" title="Microservices 微服務"></a>Microservices 微服務</h2><ul><li>通過服務實現元件化</li><li>按業務能力來劃分服務和開發團隊</li><li>去中心化</li><li>基礎設施自動化（devops、自動化部署）<br>與服務導向架構（Service-Oriented Architecture）不同，後者是整合各種業務的應用程式，但微服務只屬於一個應用程式。(強調單一業務組件化)</li></ul><h2 id="Microservices-特性"><a href="#Microservices-特性" class="headerlink" title="Microservices 特性"></a>Microservices 特性</h2><ul><li>每個服務都容易被取代。</li><li>服務是以能力來組織的，例如使用者介面、前端、推薦系統、帳單或是物流等。</li><li>由於功能被拆成多個服務，因此可以由不同的程式語言、資料庫實作。</li><li>架構是對稱而非分層（即生產者與消費者的關係）</li></ul><p><img src="http://www.45fan.com/uploads/allimg/190414/03110Jc9-1.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTI1MzAw,size_16,color_FFFFFF,t_70" alt="Microservices"></p><h2 id="Microservices-資料庫三種設計模式"><a href="#Microservices-資料庫三種設計模式" class="headerlink" title="Microservices 資料庫三種設計模式"></a>Microservices 資料庫三種設計模式</h2><ol><li>每個服務都各有一個數據庫，同屬性的服務可共享同個資料庫。</li><li>所有服務都共享同個資料庫，但是不同表格，並且不會跨域存取。</li><li>每個服務都有自己的資料庫，就算是同屬性的也是，資料庫並不會共</li></ol><p>資料庫的可棄性:<br>實踐微服務架構中有許多的做法。但是其中一種的做法是將資料庫視作短期的儲存空間而不是長期的資料。因為他們可以在上線時從事件中心回覆，因此可以快速的從記憶體中快速存取（例：Redis）作為資料庫伺服器。這種做法需要將每個請求當作事件來進行廣播，這樣就可以從事件儲存中心重播所有的事件。</p><p>在微服務中，則通過 API 調用來完成。這些模塊或者服務間調用，大部分時候是為了共享數據。<br>共享數據最賤的方式當然就是採用一種共享資料庫的模式，也就是單體應用常用的方式。應用可以有多個系統模塊，但一般都是只有一個資料庫。</p><p><img src="https://twgreatdaily.com/images/elastic/SnG/SnG8WHMBiuFnsJQVaRyz.jpg" alt="一庫一服  vs 一庫多服"></p><p>一庫多服，這種架構模式通常會被認為是 微服務架構下的反範式，它的問題在於:</p><ul><li>單點故障：一個資料庫倒下，整批服務全部停止。何來的服務獨立性？</li><li>數據在同一個地方，會給貪圖方便的開發或者 DBA 工程師編寫很多數據間高度依賴的程序或者工具。</li><li>無法針對某一個服務進行精準優化或擴展。<br>所以一般推薦的做法，是為每一個微服務準備一個單獨的資料庫，也即一庫一服(Database per Service)模式。這種模式更加適合微服務架構，它滿足每一個服務是獨立開發、獨立部署、獨立擴展的特性。需要對一個服務進行升級或者數據架構改動的時候，不會影響到其他的服務。需要對某個服務進行擴展的時候，也可以手術式的對某一個服務進行局部擴容。</li></ul><h2 id="微服務的切割"><a href="#微服務的切割" class="headerlink" title="微服務的切割"></a>微服務的切割</h2><ol><li>domain-driven design (DDD) 領域驅動設計</li></ol><ul><li>Infrastructure（基礎實施層）</li><li>Domain（領域層）</li><li>Application（應用層）</li><li>Interfaces（表示層，也叫用戶界面層或是接口層）</li></ul><p><img src="https://res.cloudinary.com/dgzowpeqr/image/upload/v1562839291/levp4f9usxwzlrlk1dou.jpg" alt="domain-driven design(DDD)"></p><ol start="2"><li>資料結構</li></ol><h2 id="微服務的利和弊"><a href="#微服務的利和弊" class="headerlink" title="微服務的利和弊"></a>微服務的利和弊</h2><p><img src="https://res.cloudinary.com/dgzowpeqr/image/upload/v1562839370/wgkwtaplr4keahh9ojsa.jpg" alt="Microservices 利與弊"></p><ul><li>利: 單一服務組件化、可獨立部署、技術多樣性</li><li>弊: 分佈式的系統複雜性(各別服務的溝通複雜化)、最終一致性、運維複雜性</li></ul><h2 id="微服務-設計模式"><a href="#微服務-設計模式" class="headerlink" title="微服務(設計模式)"></a>微服務(設計模式)</h2><p><img src="https://codertw.com/wp-content/uploads/img/15JGg8G9K0.jpg" alt="鏈式設計模式"></p><p><img src="https://codertw.com/wp-content/uploads/img/IEq6ZUD3Og.jpg" alt="聚合器設計模式"></p><p><img src="https://i.iter01.com/images/a65374eb32d49af469d0f73fa247e018af4ad67156d77ca20232556c48804cb6.png" alt="代理設計模式"></p><p><img src="https://i.iter01.com/images/a6d2c4c0b8e7cde26918b623c0fdd67f0603e723d1090c6197711638a0a8b3f7.png" alt="分支設計模式"></p><p><img src="https://codertw.com/wp-content/uploads/img/2hmI3o1N3Y.jpg" alt="資料庫共享模式"></p><p><img src="https://codertw.com/wp-content/uploads/img/M2dJFZmv5O.jpg" alt="異部消息設計模式"></p><h2 id="Service-Oriented-Architecture-與-Microservice-差別"><a href="#Service-Oriented-Architecture-與-Microservice-差別" class="headerlink" title="Service Oriented Architecture 與 Microservice 差別"></a>Service Oriented Architecture 與 Microservice 差別</h2><ul><li>微服務不再強調傳統SOA架構裡面比較重的ESB(企業服務匯流排)，進入到單個業務系統內部實現真正的元件化。</li><li>SOA注重的是系統整合方面，而微服務關注的是組件服務完全分離 。<br>more info:<a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener">Microservices wiki 英文</a><br>more info:<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99" target="_blank" rel="noopener">微服務(Microservices) wiki</a><br>more info:<a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/735003/" target="_blank" rel="noopener">微服務(Microservices) 設計模式</a><br>more info:<a href="https://iter01.com/513031.html" target="_blank" rel="noopener">架構設計思想-微服務架構設計模式</a><br>more info:<a href="https://twgreatdaily.com/I_S-V3MBfGB4SiUw1uN0.html" target="_blank" rel="noopener">如何在微服務架構下進行數據設計？</a><br>more info:<a href="https://www.cnblogs.com/takumicx/p/10021538.html" target="_blank" rel="noopener">微服務-柔性事务</a><br>more info:<a href="https://www.itread01.com/content/1542762129.html" target="_blank" rel="noopener">微服務-DB規劃</a><br>more info:<a href="https://morosedog.gitlab.io/technology-20200304-tech-10/" target="_blank" rel="noopener">技術觀念 | 淺談分散式系統 - 微服務淺談</a><br>more info:<a href="https://blog.csdn.net/xybelieve1990/article/details/84958671" target="_blank" rel="noopener">关于分布式事务BASE模型和柔性事务TCC</a><br>more info:<a href="https://www.itread01.com/content/1542394146.html" target="_blank" rel="noopener">SOA架構和微服務架構的比較</a><br>more info:<a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/588191/" target="_blank" rel="noopener">架構師必看：微服務架構綜述</a><br>more info:<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">SOA Wiki</a><br>more info:<a href="https://www.ipshop.xyz/16625.html" target="_blank" rel="noopener">我只是下了個訂單，鬼知道我在微服務里經歷了什麼？ (DDD 領域驅動設計-微服務切割-訂單設計)</a><br>more info:<a href="https://kknews.cc/zh-tw/news/p95rx6e.html" target="_blank" rel="noopener">老司機避坑指南：如何快速搞定微服務架構？</a><br>more info:<a href="https://www.martinfowler.com/articles/microservices.html#HowBigIsAMicroservice" target="_blank" rel="noopener">martinfowler blog原文</a><br>more info:<a href="https://dzone.com/articles/6-data-management-patterns-for-microservices-1" target="_blank" rel="noopener">6 Data Management Patterns for Microservices</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前遇到問題查詢的資料，做個整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>MVC模式 與 三層架構</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210202-mvc-tier.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210202-mvc-tier.html</id>
    <published>2021-02-02T12:07:30.000Z</published>
    <updated>2021-02-04T16:06:10.337Z</updated>
    
    <content type="html"><![CDATA[<p>MVC與三層架構解釋整理。</p><a id="more"></a><h2 id="MVC模式（Model–view–controller）"><a href="#MVC模式（Model–view–controller）" class="headerlink" title="MVC模式（Model–view–controller）"></a>MVC模式（Model–view–controller）</h2><p>是軟體工程中的一種軟體架構模式，把軟體系統分為三個基本部分：</p><ul><li>模型（Model): 用於封裝與應用程式的業務邏輯相關的資料以及對資料的處理方法。「 Model 」有對資料直接存取的權力，例如對資料庫的存取。<ul><li>「Model」不依賴「View」和「Controller」，也就是說， Model 不關心它會被如何顯示或是如何被操作。</li><li>但是 Model 中資料的變化一般會通過一種重新整理機制被公布。為了實現這種機制，那些用於監視此 Model 的 View 必須事先在此 Model 上註冊，從而，View 可以了解在資料 Model 上發生的改變。（比如：觀察者模式（軟體設計模式））</li></ul></li><li>視圖（View）:能夠實現資料有目的的顯示（理論上，這不是必需的）。在 View 中一般沒有程式上的邏輯。為了實現 View 上的重新整理功能，View 需要存取它監視的資料模型（Model），因此應該事先在被它監視的資料那裡註冊。 </li><li>控制器（Controller）: 起到不同層面間的組織作用，用於控制應用程式的流程。它處理事件並作出回應。「事件」包括使用者的行為和資料 Model 上的改變。</li></ul><p>MVC模式在概念上強調 Model, View, Controller 的分離，各個模組也遵循著由 Controller 來處理訊息，Model 掌管資料來源，View 負責資料顯示的職責分離原則，因此在實作上，MVC 模式的 Framework 通常會將 MVC 三個部份分離實作：</p><ul><li>Model 負責資料存取，較現代的 Framework 都會建議使用獨立的資料物件 (DTO, POCO, POJO 等) 來替代弱型別的集合物件。資料存取的程式碼會使用 Data Access 的程式碼或是 ORM-based Framework，也可以進一步使用 Repository Pattern 與 Unit of Works Pattern 來切割資料來源的相依性。</li><li>Controller 負責處理訊息，較高階的 Framework 會有一個預設的實作來作為 Controller 的基礎，例如 Spring 的 DispatcherServlet 或是 ASP.NET MVC 的 Controller 等，在職責分離原則的基礎上，每個 Controller 負責的部份不同，因此會將各個 Controller 切割成不同的檔案以利維護。</li><li>View 負責顯示資料，這個部份多為前端應用，而 Controller 會有一個機制將處理的結果 (可能是 Model, 集合或是狀態等) 交給 View，然後由 View 來決定怎麼顯示。例如 Spring Framework 使用 JSP 或相應技術，ASP.NET MVC 則使用 Razor 處理資料的顯示。</li></ul><h2 id="三層架構-3-tier-architecture"><a href="#三層架構-3-tier-architecture" class="headerlink" title="三層架構(3-tier architecture)"></a>三層架構(3-tier architecture)</h2><p>是一種軟體抽象的層次結構，從”整個應用程式架構的角度”來區分為三層。 </p><p>目的: 高內聚，低耦合的思想<br>優點: </p><ul><li>利於標準化</li><li>降低層與層之間的依賴</li><li>利於各層邏輯的復用，資源重用性好</li><li>開發人員可以只關注整個結構中的其中某一層</li><li>具有良好的開放性和可擴充性，維護和升級方便</li><li>提高系統的安全性</li></ul><p>缺點: </p><ul><li>有時會導致連動的修改。</li><li>如果在表現層中需要增加一個功能，為保證其設計符合分層式結構，可能需要在相應的商業邏輯層和資料存取層中都增加相應的程式碼。</li><li>相對於不分層，降低了系統的性能。</li><li>如果不採用分層式結構，很多業務可以直接造訪資料庫，以此獲取相應的數據，如今卻必須通過中間層來完成。</li><li>增加了開發成本。</li></ul><p>分層:</p><ul><li>表現層（Presentation layer）：通俗講就是展現給使用者的介面，即使用者在使用一個系統的時候他的所見所得。</li><li>業務邏輯層（Business Logic Layer）：針對具體問題的操作，也可以說是對資料層的操作，對資料業務邏輯處理。</li><li>資料訪問層（Data Access Layer）：該層所做事務直接運算元據庫，針對資料的增添、移除、修改、查找等。</li></ul><p><img src="https://www.itsfun.com.tw/cacheimg/d7/ce/3cf976ce330db425f6eb1a22d824.jpg" alt="3-tier architecture"></p><p><img src="https://qph.fs.quoracdn.net/main-qimg-91d0a36c056cce85cd3a941a730ef053" alt="3-tier architecture-en"></p><h2 id="兩者的差異"><a href="#兩者的差異" class="headerlink" title="兩者的差異"></a>兩者的差異</h2><ul><li>三層架構是一個分層式的軟件體系架構設計。 MVC是一個設計模式，它是根據項目的具體需求來決定是否適用於該項目。</li><li>三層架構的目的著重點是”高內聚，低耦合”，即解耦。 MVC的目的則是實現Web系統的職能分工，即職責劃分。</li><li>三層側重的是整體的一個解耦。 MVC側重的是web系統的解耦，即側重jsp和Servlet的一個解耦。</li><li>三層架構的分層模式是典型的上下關系，上層依賴於下層。 MVC作為表現模式是不存在上下關系的，而是相互協作關系。</li></ul><p>more info:<a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC Wiki</a><br>more info:<a href="https://shunnien.github.io/2017/07/29/3-tier-and-mvc-introduction/" target="_blank" rel="noopener">三層結構與 Asp.Net MVC 的簡介 Wiki</a><br>more info:<a href="https://www.itread01.com/content/1514351052.html" target="_blank" rel="noopener">三層架構與MVC的區別</a><br>more info:<a href="https://www.itread01.com/content/1514351052.html" target="_blank" rel="noopener">三層架構與MVC的區別</a><br>more info:[softwareengineering討論區]<a href="https://softwareengineering.stackexchange.com/questions/299836/difference-between-3-tier-architecture-and-mvc-model-view-controller-in-asp-n" target="_blank" rel="noopener">https://softwareengineering.stackexchange.com/questions/299836/difference-between-3-tier-architecture-and-mvc-model-view-controller-in-asp-n</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MVC與三層架構解釋整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Spring註解 @Component @Service, @Controller, @Repository</title>
    <link href="https://hand79.github.io/Blog/posts/Java/20210201-spring-annotation-component.html"/>
    <id>https://hand79.github.io/Blog/posts/Java/20210201-spring-annotation-component.html</id>
    <published>2021-02-01T14:47:33.000Z</published>
    <updated>2021-02-04T13:51:20.482Z</updated>
    
    <content type="html"><![CDATA[<p>以前留下整理的資料的記錄。</p><a id="more"></a><h2 id="spring註解"><a href="#spring註解" class="headerlink" title="spring註解"></a>spring註解</h2><p>@Component, @Service, @Controller, @Repository是spring註解，註解後可以被spring框架所掃描並註入到spring容器來進行管理</p><ul><li>@Component是通用註解，其他三個註解是這個註解的拓展，並且具有了特定的功能(generic stereotype for any Spring-managed component)。</li><li>@Repository註解在持久層中，具有將數據庫操作拋出的原生異常翻譯轉化為spring的持久層異常的功能。(stereotype for persistence layer)</li><li>@Controller層是spring-mvc的註解，具有將請求進行轉發，重定向的功能。(stereotype for presentation layer)</li><li>@Service層是業務邏輯層註解，這個註解只是標註該類處於業務邏輯層。 (stereotype for service layer)<br>用這些註解對應用進行分層之後，就能將請求處理，義務邏輯處理，數據庫操作處理分離出來，為代碼解耦，也方便了以後項目的維護和開發。</li></ul><p>註解:<br>Spring2.0時提供的: @Repository(在Spring2.5有修改部分內容)<br>Spring2.5時提供的: @Component, @Controller, @Service</p><p>more info:<a href="https://stackoverflow.com/posts/6897038/edit" target="_blank" rel="noopener">stackoverflow 參考</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html" target="_blank" rel="noopener">@Repository doc</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html" target="_blank" rel="noopener">@Component doc</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html" target="_blank" rel="noopener">@Controller doc</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html" target="_blank" rel="noopener">@Service doc</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前留下整理的資料的記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://hand79.github.io/Blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://hand79.github.io/Blog/tags/Java/"/>
    
    <category term="Spring" scheme="https://hand79.github.io/Blog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>悲觀鎖與樂觀鎖(資料庫交易)</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210201-locking-pessimistic-optimistic.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210201-locking-pessimistic-optimistic.html</id>
    <published>2021-02-01T11:47:30.000Z</published>
    <updated>2021-02-04T10:54:54.350Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇上的問題，劃個重點留個整理記錄。</p><a id="more"></a><p>資料庫交易特性ACID中的交易隔離(Isolation)通常利用「鎖(locking)」來實現，目的為避免同一筆資料在併行交易(concurrent transaction)中被不同的交易同時修改以確保資料的完整性。<br>交易鎖又分為「悲觀鎖(pessimistic locking)」與「樂觀鎖(optimistic locking)」。</p><p>常用鎖處理的例子: 電商商品庫存、銀行轉帳業務</p><p>##悲觀鎖(Pessimistic Locking)<br>時機: 悲觀並行控制主要用於資料爭用激烈的環境或發生並發衝突時，”使用鎖保護資料的成本”要低於”回復交易的成本”的環境中。</p><ul><li>悲觀並行控制實際上是「先取鎖再訪問」的保守策略，為資料處理的安全提供了保證。</li><li>在效率方面，處理加鎖的機制會讓資料庫產生額外的開銷，還有增加產生”死鎖”的機會</li><li>在只讀型交易處理中由於不會產生衝突，就沒必要使用鎖，這樣做只能增加系統負載，還有會降低了並行性。</li><li>一個交易如果鎖定了某行資料，其他交易就必須等待該交易處理完才可以處理那行資料。(當下資料有對其他執行存取有排他性)<br>典型的使用: synchronized (java)</li></ul><p>##樂觀鎖(Optimistic Locking)<br>時機: 樂觀並行控制多數用於”資料爭用不大”、”衝突較少的環境”中，”偶爾回復交易的成本”會低於”讀取資料時鎖定資料的成本”，因此可以獲得”比其他並行控制方法更高的吞吐量”。</p><ul><li>假設”多使用者並行的交易在處理時不會彼此互相影響”，”各交易能夠在不產生鎖”的情況下”處理各自影響的那部分資料”。在提交資料更新之前，每個交易會”先檢查在該交易讀取資料後，有沒有其他交易又修改了該資料”。如果其他交易有更新的話，正在提交的交易會進行rollback。</li></ul><p>缺點: 樂觀並行控制相信交易之間的資料競爭(data race)的概率是比較小的，因此儘可能直接做下去，直到提交的時候才去鎖定，所以不會產生任何鎖和死結。但如果直接簡單這麽做，還是有可能會遇到不可預期的結果，例如兩個交易都讀取了資料庫的某一行，經過修改以後寫回資料庫，這時就遇到了問題。(ABA问题) </p><ul><li>需要添加重試機制，舉個例子: 資料異動時衝突(JPA中的@version)，重新在執行失敗的動作</li></ul><h4 id="樂觀並行控制的交易包括以下階段："><a href="#樂觀並行控制的交易包括以下階段：" class="headerlink" title="樂觀並行控制的交易包括以下階段："></a>樂觀並行控制的交易包括以下階段：</h4><ul><li>讀取：交易將資料讀入快取，這時系統會給交易分派一個時間戳。</li><li>校驗：交易執行完畢後，進行提交。這時同步校驗所有交易，如果交易所讀取的資料在讀取之後又被其他交易修改，則產生衝突，交易被中斷回復。</li><li>寫入：通過校驗階段後，將更新的資料寫入資料庫。<br>典型的使用: Compare and Swap (CAS)、 AtomicReference class、 @Version(Java JPA中的@version 版本控制處理方式)</li></ul><p>##總結<br>樂觀鎖適用於讀大於寫、衝突少的的場景(省去了鎖的開銷，加大了系統的整個吞吐量。如果經常產生衝突，上層應用會不斷的進行retry可能須考慮是否用悲觀鎖)<br>悲觀鎖寫大於讀、衝突大的的場景(併發量不大且不允許髒讀適合)</p><p>more info:<a href="https://www.cnblogs.com/kismetv/p/10787228.html" target="_blank" rel="noopener">資料參考</a><br>more info:<a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank" rel="noopener">Optimistic Concurrency wiki</a><br>more info:<a href="https://zh.wikipedia.org/wiki/%E6%82%B2%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">Pessimistic Concurrency wiki</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前遇上的問題，劃個重點留個整理記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 故障排除流程圖</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210131-kubernetes.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210131-kubernetes.html</id>
    <published>2021-01-31T13:47:30.000Z</published>
    <updated>2021-01-31T14:07:06.524Z</updated>
    
    <content type="html"><![CDATA[<p>討論區看到的，留個記錄，某天遇上了可以參考。</p><a id="more"></a><p>*<em>Kubernetes 故障排除流程圖 參考 *</em><br><img src="https://learnk8s.io/a/7d3cde9ddb57e4246215de4be2f3dd71.png" alt="k8s"></p><p>more info:<a href="https://learnk8s.io/troubleshooting-deployments?fbclid=IwAR1q4Wu7GLSmmPlX7ooMK3W4lccZjwsqkygECROsyyvBe_o6YVv26Lz9PX4" target="_blank" rel="noopener">資料出處</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;討論區看到的，留個記錄，某天遇上了可以參考。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API設計</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210131-rest-api-Development.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210131-rest-api-Development.html</id>
    <published>2021-01-31T11:30:30.000Z</published>
    <updated>2021-01-31T13:48:03.605Z</updated>
    
    <content type="html"><![CDATA[<p>RESTful API 設計之學習記錄</p><a id="more"></a> <h2 id="REST要點-REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。"><a href="#REST要點-REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。" class="headerlink" title="REST要點(REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。)"></a>REST要點(REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。)</h2><ul><li>資源是由URI來指定。</li><li>對資源的操作包括取得、建立、修改和刪除，這些操作正好對應HTTP協定提供的GET、POST、PUT和DELETE方法。</li><li>通過操作資源的表現形式來操作資源。</li><li>資源的表現形式則是XML或者HTML，取決於讀者是機器還是人、是消費Web服務的客戶軟體還是Web瀏覽器。當然也可以是任何其他的格式，例如JSON。</li></ul><h2 id="特徵"><a href="#特徵" class="headerlink" title="特徵"></a>特徵</h2><ul><li>統一介面(Uniform Interface)<ul><li>Identification of resources - 唯一的資源識別</li><li>Manipulation of resources - 特定的操作方法</li><li>Self-descriptive messages - 訊息自我描述 </li><li>Hypermedia as the engine of application state (HATEOAS)<ul><li>Level 0 : 使用一個 URI 與一個 HTTP 方法，基本上就是單純使用 HTTP 作為傳輸協定，服務使用的 URI 只是個接收請求進行回應的端點，HTTP 方法只是用來發起請求，至於請求的相關細節，例如想進行的動作、必須提供的資料等，全部包含在發送過去的文件之中，像是 XML、JSON 等其他（自訂）格式，回應使用某個文件格式傳回，當中包含了請求操作後的結果。</li><li>Level 1 : 使用多個 URI 與一個 HTTP 方法，URI 代表了資源，像是 /show_message、/create_message、/update_message、/delete_message 都是資源，HTTP 方法只是用來發起請求，至於請求的細節由請求本體來提供，例如，在請求 /show_message 這項資源時，若包含 all 請求參數，表示顯示全部的訊息，若是 “id=1” 這類請求參數，表示顯示指定的訊息。</li><li>Level 2 :使用多個 URI、多個 HTTP 方法，並善用 HTTP 回應狀態碼，URI 用來代表資源，像是 /messages、/messages/1，HTTP 方法用來表示想進行的操作，例如 GET /messages 表示取得全部訊息，GET /messages/1 表示取得指定訊息，POST /messages 表示新增訊息、DELETE /messages/1 表示刪除指定訊息等</li><li>Level 3 : 更進一步地，支援 HATEOAS（Hypermedia As The Engine Of Application State）的概念，就類似 HTML 頁面鏈結，你可以從這個頁面得知可通往哪些頁面，在 REST 的 Level 3 模型中，客戶端可以從某個資源，知道還有哪些其他相關的資源，以及如何對它進行操作</li></ul></li></ul></li><li>Stateless(無狀態)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#How to understand “RESTful API is stateless”?(stackoverflow) (部分內容擷取)</span><br><span class="line">[...] </span><br><span class="line"> each request from client to server must contain all of the information necessary to understand the request,</span><br><span class="line"> and cannot take advantage of any stored context on the server. </span><br><span class="line"> Session state is therefore kept entirely on the client. [...]</span><br></pre></td></tr></table></figure><ul><li>Cacheable(可快取)</li><li>Client-Server(客戶伺服器分離模式，任何一個客戶端與伺服器都是可替換的)</li><li>Layered System (分層的系統，客戶端不知道他請求的是不是最終伺服器)</li><li>Code on Demand (optional)<ul><li>允許客戶端提高其靈活性(視情況決定要不要遵守，Server端 可以傳送可執行的程式碼給 Client端)</li></ul></li></ul><h2 id="REST設計"><a href="#REST設計" class="headerlink" title="REST設計"></a>REST設計</h2><p>符合REST設計風格的Web API稱為RESTful API。它從以下三個方面資源進行定義：</p><ul><li>直觀簡短的資源位址，比如: <a href="http://example.com/resources。" target="_blank" rel="noopener">http://example.com/resources。</a></li><li>傳輸的資源：Web服務接受與返回的網際網路媒體類型，比如：JSON，XML，YAML等。</li><li>對資源的操作：Web服務在該資源上所支援的一系列請求方法（比如：POST，GET，PUT或DELETE）。</li></ul><h2 id="RESTful-API設計要點"><a href="#RESTful-API設計要點" class="headerlink" title="RESTful API設計要點"></a>RESTful API設計要點</h2><p>HTTP動詞</p><ul><li>GET（SELECT）：請求指定資源，只應用於取得資料。(Filtering， query string)</li><li>POST（CREATE）：在服務器新建一個資源。</li><li>PUT（UPDATE）：會取代指定資源所酬載請求（request payload）的所有表現。</li><li>PATCH（UPDATE）：指定資源的部份修改。</li><li>DELETE（DELETE）：從服務器刪除指定資源。</li><li>HEAD：請求與 GET方法相同的回應，但它沒有回應主體（response body）。(應用於HTTP標頭，判別資源是否存在)</li><li>OPTIONS：描述指定資源的溝通方法（communication option）。</li><li>CONNECT: 指定資源標明的伺服器之間，建立隧道（tunnel）。</li><li>TRACE: 指定資源標明的伺服器之間，執行迴路返回測試（loop-back test）。</li></ul><p>資源命名與設計: </p><ul><li>複數名詞命名資源，如 <a href="https://api.example.com/v1/users" target="_blank" rel="noopener">https://api.example.com/v1/users</a></li><li>取得特定ID資源(別另外設計單數)，如 <a href="https://api.example.com/v1/users/1" target="_blank" rel="noopener">https://api.example.com/v1/users/1</a></li><li>取得特定複數資料查詢利用 query string做額外條件過濾或參數，<br>(<a href="https://api.example.com/v1/users?order=&quot;desc&quot;&amp;&amp;limit=10" target="_blank" rel="noopener">https://api.example.com/v1/users?order=&quot;desc&quot;&amp;&amp;limit=10</a>)</li><li>URI 應加入 API 的版本號，如<a href="https://api.example.com/v1/users" target="_blank" rel="noopener">https://api.example.com/v1/users</a></li></ul><h2 id="參考"><a href="#參考" class="headerlink" title="參考:"></a>參考:</h2><p><a href="https://www.crummy.com/writing/speaking/2008-QCon/act3.html" target="_blank" rel="noopener">REST 成熟度模型</a><br><a href="https://itbilu.com/other/relate/ry5IPQu8V.html" target="_blank" rel="noopener">成熟度模型-REST的实现步骤</a><br><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E5%B9%82%E7%AD%89%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">HyperText Transfer Protocol，HTTP (wiki)</a><br><a href="https://stackoverflow.com/questions/34130036/how-to-understand-restful-api-is-stateless" target="_blank" rel="noopener">How to understand “RESTful API is stateless”?(stackoverflow)</a><br><a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">REST Wiki</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南 - 阮一峰的网络日志</a><br><a href="https://openhome.cc/Gossip/Spring/HATEOAS.html" target="_blank" rel="noopener">Hypermedia As The Engine Of Application State(HATEOAS) Spring HATEOAS</a><br><a href="https://github.com/TritonHo/slides/blob/master/Taipei%202019-06%20talk/RESTful%20API%20Design-tw-2.2.pdf" target="_blank" rel="noopener">Backend社團-紫色石虎-RESTful API淺談</a><br><a href="https://github.com/TritonHo/slides/blob/master/restful-demo.pdf" target="_blank" rel="noopener">Backend社團-紫色石虎-RESTful淺談  - demo</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Methods" target="_blank" rel="noopener">HTTP (MDN)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RESTful API 設計之學習記錄&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>網頁前端設計</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210128-java-frontend-system-design.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210128-java-frontend-system-design.html</id>
    <published>2021-01-28T11:12:30.000Z</published>
    <updated>2021-01-28T11:15:03.544Z</updated>
    
    <content type="html"><![CDATA[<p>寫個記錄。</p><a id="more"></a><h2 id="Responsive-Web-Design-RWD-，-響應式網頁設計"><a href="#Responsive-Web-Design-RWD-，-響應式網頁設計" class="headerlink" title="Responsive Web Design (RWD)， 響應式網頁設計"></a>Responsive Web Design (RWD)， 響應式網頁設計</h2><ul><li>是一種網頁設計模式，這種設計可使網站在不同的裝置（從桌面電腦顯示器到行動電話或其他行動裝置）上瀏覽時對應不同解析度皆有適合的呈現，減少使用者進行縮放、平移和捲動等操作行為。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Complete.png/190px-Complete.png" alt="RWD示意圖"></li></ul><h2 id="Single-Page-Application-SPA-，單頁式應用"><a href="#Single-Page-Application-SPA-，單頁式應用" class="headerlink" title="Single Page Application (SPA)，單頁式應用"></a>Single Page Application (SPA)，單頁式應用</h2><ul><li>利用 AJAX 非同步的特性跟後端同步資料，將不同的資料動態輸向同一個頁面，達到網頁操作不換頁。</li><li>缺點: 是少了後端的渲染回傳，如果使用者操作太快，前端就不能保證每次都能得到正確的 Server 資料（eg. 點進網頁內容，還沒加載完成就點各種功能）。</li><li>需要解決sync與async各項功能的問題</li><li>典型應用: gmail信箱</li></ul><h2 id="Server-side-render-SSR-，伺服器端渲染"><a href="#Server-side-render-SSR-，伺服器端渲染" class="headerlink" title="Server side render (SSR)，伺服器端渲染"></a>Server side render (SSR)，伺服器端渲染</h2><ul><li>為避免 SPA 讓 SEO 變差，先渲染網頁內容，再將後續操作交給 JavaScript，</li><li>使用者一樣能享受到 SPA 不用換頁的好處，不過首次加載的時間增加了。</li><li>在 SSR 的開發上也要需要會一點後端技術。(JSP、Thymeleaf等)</li></ul><h2 id="Accelerated-Mobile-Pages-AMP"><a href="#Accelerated-Mobile-Pages-AMP" class="headerlink" title="Accelerated Mobile Pages (AMP)"></a>Accelerated Mobile Pages (AMP)</h2><ul><li>Google帶領開發的開源專案</li><li>即為「加速行動網頁」，目的是提升行動裝置對網站的存取速度。</li><li>AMP即是透過「規範HTML框架」、「限制JavaScript」、「Google高速緩存」這三種要素，縮小網頁檔案、縮短傳輸時間、降低頁面載入時間。</li><li>只要透過「行動裝置」搜尋時，發現網址前面顯示一個閃電符號⚡️即屬於AMP網頁，通常優先出現在排序前幾名，甚至讓用戶點擊進去等不到一秒，就能看到網頁內容。不僅提高點擊率，也降低了因網頁載入太久的跳出率。</li></ul><h2 id="Progressive-Web-App-PWA"><a href="#Progressive-Web-App-PWA" class="headerlink" title="Progressive Web App (PWA)"></a>Progressive Web App (PWA)</h2><ul><li>2016年 Google提出的概念，PWA的存在是為結合網站和 App 二者的特性，透過網站呈現如 APP 般的瀏覽優點，提供更好的用戶體驗。</li><li>因為PWA的本質是網站，程式語言就是用Html5、Css3、JS。</li><li>沒有跨平台需要不同程式版本的問題，更新內容也是直接從伺服端更改就可以了。</li><li>可靠：即時載入，就算網路狀況欠佳，甚至沒有網路的情況下還是能夠瀏覽。</li><li>快速：畫面流暢且即時回應，提供最佳瀏覽效果。</li><li>吸引度：使用起來如同App一般，帶來人性化的使用體驗。</li><li>不需要透過Google Play或是App Store下載，而是在你瀏覽該網站時，會跳出詢問視窗，當使用者按下同意後，會直接在裝置桌面新增一個快速連結的圖示</li></ul><p>More info: <a href="https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">RWD wiki</a><br>More info: <a href="https://zh.wikipedia.org/wiki/Accelerated_Mobile_Pages" target="_blank" rel="noopener">AMP wiki</a><br>More info: <a href="https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">PWA wiki</a><br>More info: <a href="https://blog.sharktech.tw/2018/02/07/google-amp" target="_blank" rel="noopener">google AMP</a><br>More info: <a href="https://web.dev/progressive-web-apps/" target="_blank" rel="noopener">PWA 官網</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;寫個記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>電信業即時計費系統Domain knowledge</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210128-java-telecommunications-system-design.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210128-java-telecommunications-system-design.html</id>
    <published>2021-01-28T10:30:30.000Z</published>
    <updated>2021-01-28T10:06:23.463Z</updated>
    
    <content type="html"><![CDATA[<p>某電信業即時計費系統簡易系統設計Domain knowledge描述，大概整理下。</p><a id="more"></a><h2 id="門號申裝流程"><a href="#門號申裝流程" class="headerlink" title="門號申裝流程"></a>門號申裝流程</h2><ol><li>電信申租門號(月租型、預付卡)</li><li>選號(手機號碼)</li><li>服務方案、優惠(後頭供裝在特定門號優惠服務)</li><li>門號啟用(使門號生效進行打電話、上網等服務)</li></ol><p>服務內容包括:</p><ul><li>資費設定、變更資費</li><li>用量查詢</li><li>計費周期(BillCycle)，出帳的週期</li><li>加值服務(數據加包價購，預付卡儲值等)</li><li>用量簡訊(到達特定亮時給予提醒)</li><li>到期簡訊(服務到期、數據包到期、預付卡到期等)</li><li>用罄簡訊(eg. 上網數據包用罄發送通知)</li><li>服務群組設定</li><li>優惠內容設定</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;某電信業即時計費系統簡易系統設計Domain knowledge描述，大概整理下。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Callback hell 處理(jQuery,Promise, async/await)</title>
    <link href="https://hand79.github.io/Blog/posts/JavaScript/20210128-java-callback-hell.html"/>
    <id>https://hand79.github.io/Blog/posts/JavaScript/20210128-java-callback-hell.html</id>
    <published>2021-01-28T09:30:33.000Z</published>
    <updated>2021-01-28T09:43:17.287Z</updated>
    
    <content type="html"><![CDATA[<p>在某家壽險業解過這類似的鬼東西，整理一下解釋。</p><a id="more"></a><p>如圖:<br>** 示意圖 **<br><img src="https://d1dwq032kyr03c.cloudfront.net/upload/images/20181014/201103713ObcIuaSP4.jpg" alt="Callback hell"></p><p>-必須兼容IE處理方式:</p><ul><li>jQuery 的方式處理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;參數&#125;)</span><br><span class="line">.then(callback_A)</span><br><span class="line">.then(callback_B)</span><br><span class="line">.then(callback_C)</span><br></pre></td></tr></table></figure><p>適合解法</p><ul><li>Promise (ES6 的語法)<br>![Promise] (<a href="https://cdn.rawgit.com/Vectaio/a76330b025baf9bcdf07cb46e5a9ef9e/raw/26c4213a93dee1c39611dcd0ec12625811b20a26/js-promise.svg" target="_blank" rel="noopener">https://cdn.rawgit.com/Vectaio/a76330b025baf9bcdf07cb46e5a9ef9e/raw/26c4213a93dee1c39611dcd0ec12625811b20a26/js-promise.svg</a>)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const promise1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;foo&#39;);</span><br><span class="line">  &#125;, 300);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">  &#x2F;&#x2F; expected output: &quot;foo&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(promise1);</span><br><span class="line">&#x2F;&#x2F; expected output: [object Promise]</span><br></pre></td></tr></table></figure><ul><li>async/await (ES7的語法)，可與Promise混合使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function a()&#123;</span><br><span class="line">  await b();</span><br><span class="line">  .....       &#x2F;&#x2F; 等 b() 完成後才會執行</span><br><span class="line">  await c();</span><br><span class="line">  .....       &#x2F;&#x2F; 等 c() 完成後才會執行</span><br><span class="line">  await new Promise(resolve&#x3D;&gt;&#123;</span><br><span class="line">    .....</span><br><span class="line">  &#125;);</span><br><span class="line">  .....       &#x2F;&#x2F; 上方的 promise 完成後才會執行</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">a().then(()&#x3D;&gt;&#123;</span><br><span class="line">  .....       &#x2F;&#x2F; 等 a() 完成後接著執行</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>參考: <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise MDN文件</a><br>參考: <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">async MDN文件</a><br>參考: <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">await MDN文件</a><br>參考: <a href="https://www.oxxostudio.tw/articles/201908/js-async-await.html" target="_blank" rel="noopener">簡單理解 JavaScript Async 和 Await</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在某家壽險業解過這類似的鬼東西，整理一下解釋。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://hand79.github.io/Blog/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://hand79.github.io/Blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>壽險業系統設計Domain knowledge</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210128-java-insurance-system-design.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210128-java-insurance-system-design.html</id>
    <published>2021-01-28T08:40:30.000Z</published>
    <updated>2021-01-28T10:06:20.452Z</updated>
    
    <content type="html"><![CDATA[<p>壽險業簡易系統設計Domain knowledge描述，大概整理個通則。</p><a id="more"></a><h2 id="保單投保、核保流程-依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣"><a href="#保單投保、核保流程-依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣" class="headerlink" title="保單投保、核保流程(依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣)"></a>保單投保、核保流程(依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣)</h2><ol><li>建議書</li></ol><ul><li>主要是業務員透過拜訪客戶在介紹公司的保險商品階段。</li><li>保險業務員與要被保險人談論保什麼險，之後進行初步輸入資料的階段。</li></ul><ol start="2"><li>要保書</li></ol><ul><li>輸入建檔階段，要被保人資料、簽名、保單商品資料、投保金額、證明文件等。</li><li>照會檢查</li></ul><ol start="3"><li>核保審核</li></ol><ul><li>該階段會有該業務員的主管審核該保單資料內容，比如說黑名單、該投保金額、年齡、收入、被保人健康狀態。</li><li>扣款也會在這階段。</li><li>有問題發送照會，依內容決定是否退回處理</li></ul><ol start="4"><li>投保完成</li></ol><ul><li>一般來說該階段僅提供查閱的功能，不再提供變更。</li><li>若要修改原本的保單，會需要留下資料備查不可刪除(log 或記錄在資料庫，保戶的舊保單相關內容進行註記)，另開新流程重新開始保單的投保流程或回到投保審核前階段。</li></ul><p>Extra: </p><ol><li><p>保單管理</p><ul><li>顧名思義就是保單的管理</li><li>掛在業務員身上通常是未審核前的保單(該系統需設計利益迴避，避免自己人審自己人的情況)</li><li>掛在審核人員身上的就是要審核的保單</li></ul></li><li><p>保單查詢</p><ul><li>查詢保單內容</li></ul></li><li><p>保單健檢 (不在投保主流程，算是輔助業務員與要被保人的檢視保障的功能)</p><ul><li>檢視該保單的保障和規劃，該設計內容可能有圖表預測、和一些依據保單提供的保障規劃。</li><li>提供保險公司保單的檢視功能，提供個人保單檢視及家庭保單檢視功能、可將全家人保單之保障、保費、還本金額、意外、醫療、癌症透過表格或圖形清楚顯示出保障缺口，方便說明，並可納入投資型商品之壽險保障檢視功能，由保障缺口促成保單調整或再銷售的機會，保險資訊源含國內所有保險公司人身險商品。</li></ul></li><li><p>保險需求分析系統  (不在投保主流程，算是輔助業務員與要被保人的檢視保障的功能)</p><ul><li>提供保險業務員協助客戶進行人生各階段理財目標規劃及計算—房貸規劃、子女教育規劃、退休養老規劃、遺產稅計算。</li><li>透過應備及已備費用計算生涯累積差額，找出不足的風險保障。</li><li>可結合保單健檢結果使需求更明確，以全家人的角度做家庭保險需求分析；並進一步提供退休養老規劃及遺產稅計算，根據客戶基本資料之判斷。</li></ul></li><li><p>網路投保系統(不透過業務員的投保流程，其實就是輸入建檔那段換成客戶自己輸入)</p></li></ol><ul><li>商品上架管理</li><li>會員資訊管理(含註冊/登入作業)</li><li>投保案件管理(含投保記錄查詢、投保商品查詢)</li><li>保險商品保費試算、保單核保(含保險公司核保及公會核保)</li><li>信用卡繳費(需確認持卡人為要保人本人)</li><li>投保額度計算</li><li>簽署作業、通報作業</li><li>自然人憑證驗證作業(要保人及簽署人用以驗證身份)等功能。<br>基本主流程:<ol><li>加入會員 -&gt; 同意相關會員條款 -&gt; 輸入個人資料  -&gt; 會員相關驗證(手機、email、支付等驗證，是否當下必填，依各家壽險業業務流程決定)</li><li>輸入投保資料 -&gt; 保費試算</li><li>確認投保資料</li><li>填寫或確認付款資訊</li><li>核保審核<ul><li>照會檢查</li></ul></li><li>完成投保</li></ol></li></ul><h2 id="理賠流程"><a href="#理賠流程" class="headerlink" title="理賠流程"></a>理賠流程</h2><ol><li>理賠申請書，輸入建檔(依過去保單內容自動帶入)<ul><li>該階段資料證明附件大概包括如下:<ul><li>憲警單位處理證明文件或肇事責任鑑定書</li><li>診斷、醫瘵費收據</li><li>瘵養費收據或其他補助收據。</li><li>和解書或判決書。</li><li>戶口名簿影本。</li></ul></li><li>照會檢查</li></ul></li><li>理賠審核<ul><li>審核該理賠案件之內容</li><li>調查附上的文件的內容</li><li>有問題發送照會，依內容決定是否退回處理</li></ul></li><li>理賠結果<ul><li>拒賠</li><li>文件不齊全，通知補齊，會回到審核階段或輸入階段</li><li>依約給付，匯款、支票等給付方式</li></ul></li></ol><h2 id="收費流程"><a href="#收費流程" class="headerlink" title="收費流程"></a>收費流程</h2><ol><li>收費保單輸入建檔<ul><li>保單資料資料輸入</li><li>銀行資料等支付資料輸入</li><li>照會檢查</li></ul></li><li>建當輸入審核<ul><li>有問題發送照會，依內容決定是否退回處理</li></ul></li><li>結案</li></ol><h2 id="照會-這個名詞是說在流程中遇到問題，需通知業務員是什麼問題"><a href="#照會-這個名詞是說在流程中遇到問題，需通知業務員是什麼問題" class="headerlink" title="照會(這個名詞是說在流程中遇到問題，需通知業務員是什麼問題)"></a>照會(這個名詞是說在流程中遇到問題，需通知業務員是什麼問題)</h2><ul><li>照會發送</li><li>照會處理(解照會)</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;壽險業簡易系統設計Domain knowledge描述，大概整理個通則。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Web開發常用工具</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210127-java-web-tool.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210127-java-web-tool.html</id>
    <published>2021-01-27T11:47:30.000Z</published>
    <updated>2021-01-27T12:01:07.779Z</updated>
    
    <content type="html"><![CDATA[<p>工作整理常用、過去使用過的文件網站與相關工具整理</p><a id="more"></a><h2 id="Java-相關"><a href="#Java-相關" class="headerlink" title="Java 相關"></a>Java 相關</h2><p><a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">Spring 相關文件官網</a><br><a href="https://hibernate.org/" target="_blank" rel="noopener">Hibernate 官網</a><br><a href="https://www.oracle.com/tw/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">Oracle JDK</a><br><a href="https://poi.apache.org/apidocs/index.html" target="_blank" rel="noopener">Apache POI</a><br><a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">mybatis 官網</a><br><a href="https://www.thymeleaf.org/documentation.html" target="_blank" rel="noopener">Thymeleaf Doc</a><br><a href="https://www.thymeleaf.org/ecosystem.html" target="_blank" rel="noopener">Thymeleaf Plugin</a><br><a href="https://docs.oracle.com/javaee/5/tutorial/doc/bnake.html" target="_blank" rel="noopener">JSTL Oracle doc</a><br><a href="https://docs.oracle.com/javaee/5/jstl/1.1/docs/tlddocs/" target="_blank" rel="noopener">JSTL Oracle doc (tld doc)</a><br><a href="https://howtodoinjava.com/" target="_blank" rel="noopener">Java 教學(英文)</a></p><h2 id="HTML-JavaScript-CSS相關"><a href="#HTML-JavaScript-CSS相關" class="headerlink" title="HTML, JavaScript, CSS相關"></a>HTML, JavaScript, CSS相關</h2><p><a href="https://www.w3schools.com/js/default.asp" target="_blank" rel="noopener">W3C (JavaScript)</a><br><a href="https://www.w3schools.com/css/default.asp" target="_blank" rel="noopener">W3C (CSS)</a><br><a href="https://www.w3schools.com/html/default.asp" target="_blank" rel="noopener">W3C (HTML)</a><br><a href="https://www.w3school.com.cn/html5/index.asp" target="_blank" rel="noopener">W3C.cn (HTML5)</a><br><a href="https://developer.mozilla.org/en-US/docs/Web" target="_blank" rel="noopener">MDN Web Docs 英文 (Web APIs)</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web" target="_blank" rel="noopener">MDN Web Docs 中文 (Web APIs)</a><br><a href="https://api.jquery.com/" target="_blank" rel="noopener">jQuery doc 文件</a><br><a href="https://oscarotero.com/jquery/" target="_blank" rel="noopener">jQuery API 快找</a><br><a href="https://sapui5.hana.ondemand.com/#/api" target="_blank" rel="noopener">SAPUI5 文件</a><br><a href="https://www.jeasyui.com/documentation/index.php" target="_blank" rel="noopener">Easy UI 文件</a><br><a href="https://getbootstrap.com/" target="_blank" rel="noopener">Bootstrap 官網</a><br><a href="https://www.w3schools.com/bootstrap/bootstrap_ver.asp" target="_blank" rel="noopener">w3c Bootstrap 教學</a><br><a href="https://startbootstrap.com/" target="_blank" rel="noopener">Bootstrap 樣板網</a><br><a href="https://datatables.net/" target="_blank" rel="noopener">datatables 表單外掛</a><br><a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">Fontawesome UI icon</a><br><a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse (查詢js api在各家的瀏覽器相容性)</a><br><a href="https://www.oxxostudio.tw/articles/201501/css-flexbox.html" target="_blank" rel="noopener">Flex box 教學(RWD &amp;&amp; CSS3)</a><br><a href="https://www.w3schools.com/css/css3_mediaqueries.asp" target="_blank" rel="noopener">@Media 不同裝置的CSS設計 </a></p><h2 id="開發工具"><a href="#開發工具" class="headerlink" title="開發工具"></a>開發工具</h2><p><a href="https://dbeaver.io/" target="_blank" rel="noopener">DBeaver DB工具</a><br><a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">Eclispe 官網</a><br><a href="https://spring.io/tools" target="_blank" rel="noopener">STS (Eclispe 與 Spring 整合開發工具)</a><br><a href="https://www.itread01.com/content/1546159175.html" target="_blank" rel="noopener">Mybatis generator的使用教學</a><br><a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener">Gradle 官網</a><br><a href="https://www.w3cschool.cn/gradle/" target="_blank" rel="noopener">Gradle 教學網</a><br><a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven 官網</a><br><a href="https://www.w3cschool.cn/maven/tkhr1ht6.html" target="_blank" rel="noopener">Maven 教學網</a><br><a href="https://staruml.io/" target="_blank" rel="noopener">StarUML</a><br><a href="https://www.webtoolkitonline.com/" target="_blank" rel="noopener">web toolkit online(綜合工具)</a></p><h2 id="測試工具"><a href="#測試工具" class="headerlink" title="測試工具"></a>測試工具</h2><p><a href="https://regex101.com/" target="_blank" rel="noopener">Regular Expression 線上驗證工具</a><br><a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">Fiddler</a><br><a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">JMeter</a><br><a href="https://www.postman.com/downloads/" target="_blank" rel="noopener">Postman</a><br><a href="http://dog0416.blogspot.com/2017/06/stress-test-jmeter-beanshell.html" target="_blank" rel="noopener">BeanShell JMeter教學</a><br><a href="https://topic.alibabacloud.com/tc/a/jmeter-bean-shell-use-full_1_28_20186532.html" target="_blank" rel="noopener">BeanShell JMeter使用</a><br><a href="http://sikulix.com/quickstart/" target="_blank" rel="noopener">SikuliX (圖形介面編寫腳本達到自動操作，基於Jython，須裝java &amp;&amp; Python)</a><br><a href="https://igouist.github.io/post/2020/03/sikulix/" target="_blank" rel="noopener">SikuliX (簡易解說)</a></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><a href="http://linux.vbird.org/" target="_blank" rel="noopener">鳥哥</a><br><a href="http://linux.vbird.org/linux_basic/0320bash.php#variable_var" target="_blank" rel="noopener">鳥哥 BASH</a><br><a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts.php" target="_blank" rel="noopener">鳥哥 Shell scripts</a><br><a href="https://www.centos.org/download/" target="_blank" rel="noopener">CentOS 官網</a><br><a href="https://ubuntu.com/download#download" target="_blank" rel="noopener">Ubuntu 官網</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作整理常用、過去使用過的文件網站與相關工具整理&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>時間同步(網路校時)</title>
    <link href="https://hand79.github.io/Blog/posts/Linux/20210127-Linux-shell-sync-time.html"/>
    <id>https://hand79.github.io/Blog/posts/Linux/20210127-Linux-shell-sync-time.html</id>
    <published>2021-01-27T08:30:33.000Z</published>
    <updated>2021-01-27T11:57:42.283Z</updated>
    
    <content type="html"><![CDATA[<p>CentOS 時間同步</p><a id="more"></a><h2 id="CentOS-6"><a href="#CentOS-6" class="headerlink" title="CentOS 6"></a>CentOS 6</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ntpdate pool.ntp.org # ntpdate [ip]</span><br></pre></td></tr></table></figure><h2 id="CentOS-8-7開始提供使用Chrony"><a href="#CentOS-8-7開始提供使用Chrony" class="headerlink" title="CentOS 8 (7開始提供使用Chrony)"></a>CentOS 8 (7開始提供使用Chrony)</h2><ul><li>使用Chrony</li></ul><p>安裝</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install chrony</span><br></pre></td></tr></table></figure><p>啟動</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start chronyd.service 或  systemctl start chronyd</span><br></pre></td></tr></table></figure><p>設置開機後就自動執行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl enable chronyd.service 或  systemctl enable chronyd</span><br></pre></td></tr></table></figure><p>設定檔位於路徑 </p><ul><li>/etc/chrony.conf</li></ul><p>預設值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">server 0.centos.pool.ntp.org iburst</span><br><span class="line">server 1.centos.pool.ntp.org iburst</span><br><span class="line">server 2.centos.pool.ntp.org iburst</span><br><span class="line">server 3.centos.pool.ntp.org iburst</span><br></pre></td></tr></table></figure><p>想改用台灣本地的時間主機，如下台灣本地的時間主機</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">server tock.stdtime.gov.tw prefer</span><br><span class="line">server tick.stdtime.gov.tw</span><br><span class="line">server time.stdtime.gov.tw</span><br></pre></td></tr></table></figure><p>查看 chronyd運行狀態</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status chronyd.service</span><br></pre></td></tr></table></figure><p>查看 chronyc 校時來源server</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chronyc sources</span><br></pre></td></tr></table></figure><p>查看 chronyc 校時來源server狀態</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chronyc sourcestats</span><br></pre></td></tr></table></figure><p>查看最後一次取得的校時資料</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chronyc tracking</span><br></pre></td></tr></table></figure><p>如果系統時間與網路時間差異較大，不想等chrony慢慢校時，手動執行強制校時指令 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chronyc -a makestep</span><br></pre></td></tr></table></figure><p>More info:<a href="http://linux.vbird.org/linux_server/0440ntp/0440ntp-centos5.php#ntpdate" target="_blank" rel="noopener">ntpdate from 鳥哥</a><br>More info: <a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-configuring_ntp_using_the_chrony_suite#sect-differences_between_ntpd_and_chronyd" target="_blank" rel="noopener">RedHat chrony vs ntpdate 差異</a><br>More info:<a href="https://kknews.cc/zh-tw/code/8ga39xl.html" target="_blank" rel="noopener">RHEL8或CentOS8上配置NTP伺服器和客戶端</a><br>More info:<a href="https://blog.gtwang.org/linux/linux-ntp-installation-and-configuration-tutorial/" target="_blank" rel="noopener">Linux 設定 NTP 同步系統時間，自動網路校時教學</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;CentOS 時間同步&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hand79.github.io/Blog/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hand79.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>運行級別 CentOS(6, 7)修改</title>
    <link href="https://hand79.github.io/Blog/posts/Linux/20210127-Linux-shell-runlevel.html"/>
    <id>https://hand79.github.io/Blog/posts/Linux/20210127-Linux-shell-runlevel.html</id>
    <published>2021-01-27T07:34:00.000Z</published>
    <updated>2021-01-27T09:18:18.191Z</updated>
    
    <content type="html"><![CDATA[<p>不同版本用法不太一樣</p><a id="more"></a><p>運行級別</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Default runlevel. The runlevels used are:</span><br><span class="line">#   0 - halt (Do NOT set initdefault to this)</span><br><span class="line">#   1 - Single user mode</span><br><span class="line">#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)</span><br><span class="line">#   3 - Full multiuser mode</span><br><span class="line">#   4 - unused</span><br><span class="line">#   5 - X11</span><br><span class="line">#   6 - reboot (Do NOT set initdefault to this)</span><br></pre></td></tr></table></figure><p>** 從一種運行模式可以切換到另一種運行模式 **</p><ul><li>重啟系統切換運行級別<ul><li>命令行模式——&gt;圖形界面模式：init 5</li><li>圖形界面模式——&gt;命令行模式：init 3</li></ul></li><li>臨時切換<ul><li>命令行模式——&gt; 圖形界面模式：startx</li><li>圖形界面模式——&gt;命令行模式：在X-window圖形操作界面中按Ctrl+Alt+Fn(n=1-6) 就可以進入Console字符操作界面。按Ctrl+Alt+F7即可回到剛才的X-window中。 </li></ul></li></ul><h1 id="CentOS-6"><a href="#CentOS-6" class="headerlink" title="CentOS 6"></a>CentOS 6</h1><p>修改/ etc / inittab文件中的重置運行等級即可。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim &#x2F;etc&#x2F;inittab</span><br></pre></td></tr></table></figure><p>修改內容後，重新啟動。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#默認命令模式</span><br><span class="line">id:3:initdefault:</span><br><span class="line"></span><br><span class="line">#默認GUI模式</span><br><span class="line">id:5:initdefault:</span><br></pre></td></tr></table></figure><h1 id="CentOS-7"><a href="#CentOS-7" class="headerlink" title="CentOS 7"></a>CentOS 7</h1><p>改用Systemd處理了，原有的inittab已無用<br>systemd使用targets的取代了原有的運行級別runlevels。</p><p>默認兩個主要目標：</p><ul><li>multi-user.target  = 原來的運行級別3</li><li>graphic.target = 原來的運行級別5</li></ul><p>查看默認的運行等級</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl get-default</span><br></pre></td></tr></table></figure><p>** 設置默認的運行等級 **</p><p>切換命令模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure><p>切換 GUI模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl isolate graphical.target</span><br></pre></td></tr></table></figure><p>設定開機啟動至命令模式（runlevel 3）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure><p>設定開機啟動至 GUI 模式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl set-default graphical.target</span><br></pre></td></tr></table></figure><p>More info: <a href="https://www.cnblogs.com/rouqinglangzi/p/11077443.html" target="_blank" rel="noopener">參考(Centos修改默认运行级别)</a><br>More info: <a href="http://technote.aven-network.com/852/using-systemctl-control-target" target="_blank" rel="noopener">使用 systemctl 操作系統層級 target</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;不同版本用法不太一樣&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hand79.github.io/Blog/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hand79.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>如果root忘了密碼(Centos 6)</title>
    <link href="https://hand79.github.io/Blog/posts/Linux/20210127-Linux-shell-root-password.html"/>
    <id>https://hand79.github.io/Blog/posts/Linux/20210127-Linux-shell-root-password.html</id>
    <published>2021-01-27T07:30:00.000Z</published>
    <updated>2021-01-27T08:16:27.554Z</updated>
    
    <content type="html"><![CDATA[<p>#如果root忘了密碼，過單用戶模式重設root帳號的密碼，進入到單用戶模式，root不用密碼就可以登入</p><a id="more"></a><p>步驟:<br>開機時在引導時輸入enter-&gt;看到介面輸入e-&gt;選擇kernel-&gt;<br>輸入e-&gt; 在這這行最後面寫 1-&gt;再輸入enter -&gt; 再輸入小b(單用戶模式)-&gt;可以修改root密碼(passwd)</p><p>#安全性的疑慮:<br>用這招必須在當台電腦或機房前才有用(遠程無用)</p><p>More info: <a href="https://kknews.cc/zh-tw/code/k9oxl6q.html" target="_blank" rel="noopener">其他版本相關</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;#如果root忘了密碼，過單用戶模式重設root帳號的密碼，進入到單用戶模式，root不用密碼就可以登入&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hand79.github.io/Blog/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hand79.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>網卡IP查詢</title>
    <link href="https://hand79.github.io/Blog/posts/Linux/20210127-Linux-shell-ip.html"/>
    <id>https://hand79.github.io/Blog/posts/Linux/20210127-Linux-shell-ip.html</id>
    <published>2021-01-27T07:30:00.000Z</published>
    <updated>2021-01-27T08:42:33.824Z</updated>
    
    <content type="html"><![CDATA[<p>#網卡IP查詢</p><a id="more"></a><h2 id="Window"><a href="#Window" class="headerlink" title="Window"></a>Window</h2><ul><li>ipconfig</li></ul><h2 id="Ubuntu-CentOS"><a href="#Ubuntu-CentOS" class="headerlink" title="Ubuntu, CentOS"></a>Ubuntu, CentOS</h2><ul><li>ifconfig</li><li>假如指令無效net-tools需要裝</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install net-tools</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;#網卡IP查詢&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="https://hand79.github.io/Blog/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://hand79.github.io/Blog/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Shallow Copy VS Deep Copy (JavaScript)</title>
    <link href="https://hand79.github.io/Blog/posts/JavaScript/20210127-java-script-obj-copy.html"/>
    <id>https://hand79.github.io/Blog/posts/JavaScript/20210127-java-script-obj-copy.html</id>
    <published>2021-01-27T07:00:00.000Z</published>
    <updated>2021-01-27T07:29:28.089Z</updated>
    
    <content type="html"><![CDATA[<p>Shallow Copy VS Deep Copy　</p><a id="more"></a><p><img src="http://i.imgur.com/abBTAP3.png" alt="Shallow Copy VS Deep Copy"></p><ul><li>Shallow Copy(淺拷貝): 只複製指向某個物件的指標，而不複製物件本身，新舊物件還是共用同一塊記憶體。</li><li>Deep Copy(深拷貝): 會另外創造一個一模一樣的物件，新物件跟原物件不共用記憶體，修改新物件不會改到原物件內容。</li></ul><h2 id="如何-Deep-Copy"><a href="#如何-Deep-Copy" class="headerlink" title="如何 Deep Copy"></a>如何 Deep Copy</h2><ol><li>手動複製(建立一個物件，手動把值弄進去)</li><li>Object.assign(ES6語法，該語法先建立一個空物件，再把指定值塞進去，限單層，多層需另外處理)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class="line">var obj2 &#x3D; Object.assign(&#123;&#125;, obj1);</span><br><span class="line">obj2.b &#x3D; 100;</span><br><span class="line">console.log(obj1); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125; &lt;-- 值不變</span><br><span class="line">console.log(obj2); &#x2F;&#x2F; &#123; a: 1, b: 100, c: 3 &#125;</span><br></pre></td></tr></table></figure><ol start="3"><li>轉成 JSON 再轉回來(用JSON.stringify把物件轉成字串，再用JSON.parse把字串轉成新的物件，多層可以，有function情境不可，function沒辦法轉成JSON)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123; fun: function()&#123; console.log(123) &#125; &#125;;</span><br><span class="line">var obj2 &#x3D; JSON.parse(JSON.stringify(obj1));</span><br><span class="line"></span><br><span class="line">console.log(typeof obj1.fun); &#x2F;&#x2F; &#39;function&#39;</span><br><span class="line">console.log(typeof obj2.fun); &#x2F;&#x2F; &#39;undefined&#39; &lt;-- 會undefined，</span><br></pre></td></tr></table></figure><ol start="4"><li>透過library處理，此處用JQuery處理</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var obj1 &#x3D; &#123;</span><br><span class="line">    a: 1,</span><br><span class="line">    b: &#123; f: &#123; g: 2 &#125; &#125;,</span><br><span class="line">    c: [4, 5, 6]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var obj2 &#x3D; $.extend(true, &#123;&#125;, obj1);</span><br><span class="line">console.log(obj1.b.f &#x3D;&#x3D;&#x3D; obj2.b.f); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Shallow Copy VS Deep Copy　&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://hand79.github.io/Blog/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://hand79.github.io/Blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>資料庫的問題</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210118-database-expansion-1.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210118-database-expansion-1.html</id>
    <published>2021-01-18T06:30:30.000Z</published>
    <updated>2021-02-17T13:38:15.910Z</updated>
    
    <content type="html"><![CDATA[<p>遇上的資料庫相關效能處理問題，處理方式記錄。</p><a id="more"></a><h3 id="讀寫分離架構"><a href="#讀寫分離架構" class="headerlink" title="讀寫分離架構"></a>讀寫分離架構</h3><p>master : 主要用寫的服務，會與 slave進行資料同步。<br>slave : 主要用來讀的服務。</p><ul><li>適用於讀多寫少情況。</li></ul><h3 id="分表"><a href="#分表" class="headerlink" title="分表"></a>分表</h3><ul><li>時機: 單表資料量太大讀寫遇上瓶頸，增加slave、優化索引仍然無法解決時。</li></ul><h3 id="分庫"><a href="#分庫" class="headerlink" title="分庫"></a>分庫</h3><ul><li>時機: 單機讀寫遇上瓶頸，增加slave、優化索引仍然無法解決時。</li><li>目的就在於減少單台資料庫讀寫的負擔，縮短查詢時間。</li></ul><h3 id="DB遇上瓶頸，初步判斷各種可能的解決方法"><a href="#DB遇上瓶頸，初步判斷各種可能的解決方法" class="headerlink" title="DB遇上瓶頸，初步判斷各種可能的解決方法"></a>DB遇上瓶頸，初步判斷各種可能的解決方法</h3><ul><li>IO<ul><li>磁盤讀IO瓶頸，熱點資料太多，資料庫cache放不下，每次查詢時會產生大量的IO，降低查詢速度。<ul><li>圖片、檔案、影片等不存資料庫，降低負擔(檔案放入Amazon S3、FTP server等做存取，DB只做該檔案資料純文字索引)。</li><li>讀寫分離</li><li>另外架cache server 降低資料庫負擔(eg. Redis)。</li><li>分庫和垂直分表 </li></ul></li><li>網絡IO瓶頸，請求的資料太多，網絡帶寬不夠 <ul><li>減少一次請求的資料(這比較實際，有些工程師為了方便一次性查詢把所有資料查回來，但該階段根本用不到的資料(圖片、影片等單次請求)也一起回來了)</li><li>分庫</li></ul></li></ul></li><li>CPU<ul><li>SQL問題，如SQL中包含join，group by，order by，非索引字段條件查詢等，增加CPU運算的操作<ul><li>建立合適的索引，在Application layer進行計算(不透過資料庫處理複雜運算)。</li></ul></li><li>單表資料量太大，查詢時掃描的行太多，SQL效率低，增加CPU運算的操作 <ul><li>水平分表(使用者人數多的時候有機會遇到，根據資料熱點區間分散)。</li></ul></li></ul></li></ul><h2 id="總結"><a href="#總結" class="headerlink" title="總結"></a>總結</h2><p>須根據系統實際狀況處理，沒有一定法則。<br>以下是過取處理案子時的處理方式:</p><ul><li>選擇處理方案優先序:<ol><li>Application layer(應用程式問題)</li><li>檔案相關IO</li><li>快取設計(資料預熱、增加快取Server)、 獨立資料表、靜態常數化(該資料為常用資料)</li><li>讀寫分離(主要調整資料庫設定)</li><li>分區(Partition， 分割資料表，與水平分表(針對資料創資料表)類似但有不同，針對資料內容經由資料庫創建資料的分區，例如: 1~100 1區)</li><li>分表</li><li>分庫</li><li>分庫分表(最不得以的情況，通常這調整幅度比較大，包含資料庫和應用程式的調整)</li></ol></li></ul><p>參考: <a href="https://ithelp.ithome.com.tw/articles/10226783" target="_blank" rel="noopener">資料庫層的擴展 - 讀寫分離架構</a><br>參考: <a href="https://ithelp.ithome.com.tw/articles/10227066" target="_blank" rel="noopener">資料庫層的擴展 - 分庫分表架構</a><br>參考: <a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/742272/" target="_blank" rel="noopener">數據庫怎麼分庫分表，垂直？水平？</a><br>參考: <a href="https://kknews.cc/zh-tw/news/abvzkex.html" target="_blank" rel="noopener">資料庫分庫分表，何時分？怎樣分？</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;遇上的資料庫相關效能處理問題，處理方式記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>CI/CD 相關內容概念</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210107-CI-CD.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210107-CI-CD.html</id>
    <published>2021-01-07T06:30:30.000Z</published>
    <updated>2021-01-07T07:24:49.098Z</updated>
    
    <content type="html"><![CDATA[<p>概念解釋。</p><a id="more"></a><h3 id="Continuous-integration-CI，持續性整合"><a href="#Continuous-integration-CI，持續性整合" class="headerlink" title="Continuous integration(CI，持續性整合)"></a>Continuous integration(CI，持續性整合)</h3><ul><li>將開發人員對應用程序的更改被合併，系統將會通過自動生成應用並運行不同級別的自動化測試（通常是單元測試和整合測試）來驗證，確保這些更改沒有對程式功能造成破壞。測試內容涵蓋了從類和函數到構成整個應用的不同模塊。如果自動化測試發現新代碼和現有代碼之間存在衝突，可以更加輕鬆地快速修復這些錯誤。     </li><li>目的: 完成各程式碼的整合。應用程序的新更改會定期構建，測試並合併到共享存儲庫中，解決在一次開發中有太多應用分支，從而導致相互衝突的問題。</li></ul><h3 id="Continuous-Delivery-CD，持續性交付"><a href="#Continuous-Delivery-CD，持續性交付" class="headerlink" title="Continuous Delivery(CD，持續性交付)"></a>Continuous Delivery(CD，持續性交付)</h3><ul><li>完成CI中生成及單元測試和整合測試的自動化流程後，持續交付可自動將已驗證的程式碼發佈到存儲庫。為了實現高效的持續交付流程，必須確保CI已內置於開發管道。</li><li>目的: 是擁有一個可隨時部署到生產環境的程式庫。</li></ul><h3 id="Continuous-Deployment-CD，持續性部署"><a href="#Continuous-Deployment-CD，持續性部署" class="headerlink" title="Continuous Deployment(CD，持續性部署)"></a>Continuous Deployment(CD，持續性部署)</h3><ul><li>最後的階段是持續部署，自動部署到指定環境。</li><li>目的: 自動將預定的程式版本發佈到程式碼存儲庫的延伸，自動將程式發佈到生產環境。</li></ul><h2 id="CI-CD總結"><a href="#CI-CD總結" class="headerlink" title="CI/CD總結"></a>CI/CD總結</h2><ul><li>CI/CD 就是程式開發完畢後，把開發完成的程式碼進行測試與Code Review，通過後經過合併於主線(Main branch)後直接發佈上線(Prod, UAT等環境)，這樣的過程就是所謂的 CI/CD。</li><li>CI/CD常用工具:    <ul><li>GitLab CI</li><li>Travis CI</li><li>Bamboo (Atlassian家出的 CI)</li><li>Circle CI</li><li>Jenkins</li><li>Ansible </li></ul></li></ul><p>*<em>流程參考 Redhat *</em><br><img src="https://www.redhat.com/cms/managed-files/ci-cd-flow-desktop_1.png" alt="Redhat_CI_CD"></p><h3 id="Unit-Testing-單元測試"><a href="#Unit-Testing-單元測試" class="headerlink" title="Unit Testing (單元測試)"></a>Unit Testing (單元測試)</h3><ul><li>針對程式中的模組來進行正確性檢驗的測試工作，一個單元的定義可以是單個程式、函式、過程等內容，作為一個單元。(對於物件導向程式設計，最小單元就是方法，包括基礎類別（超類）、抽象類、或者衍生類別（子類）中的方法。)</li></ul><h3 id="System-Integration-Testing-SIT，整合測試"><a href="#System-Integration-Testing-SIT，整合測試" class="headerlink" title="System Integration Testing (SIT，整合測試)"></a>System Integration Testing (SIT，整合測試)</h3><ul><li>在單獨的軟體模組被合併作為一個組測試。在單元測試之後和在系統測試之前。整合測試在已經被單元測試檢驗後進行作為它的輸入，組織在更大的集合，和遞送，作為它的輸出，整合系統為系統測試做準備。</li><li>目的: 整合測試的目的是校驗功能、效能和可靠性要求，配置在主設計專案中。</li></ul><h3 id="System-Testing-系統測試"><a href="#System-Testing-系統測試" class="headerlink" title="System Testing (系統測試)"></a>System Testing (系統測試)</h3><ul><li>系統測試的涵蓋面很廣，主要包括功能測試、介面測試、可靠性測試、易用性測試、效能測試。 功能測試主要針對包括功能可用性、功能實現程度（功能流程&amp;業務流程、資料處理&amp;業務資料處理）方面測試。</li><li>壓力測試與效能測試差異<ul><li>壓力測試要求進行超過規定效能指標的測試。例如一個網站請求是100qps，壓力測試就要是採用120qps個同時請求的條件測試。<ul><li>判斷準則： 系統能夠恢復、壓力過程中不要有明顯效能下降</li></ul></li><li>效能測試是就是該系統的效能標準(eg. 80tps)</li></ul></li></ul><h3 id="Stress-Testing-壓力測試"><a href="#Stress-Testing-壓力測試" class="headerlink" title="Stress Testing (壓力測試)"></a>Stress Testing (壓力測試)</h3><ul><li>測驗系統在當下的軟硬體環境下能夠承受的請求有多少，用來計算出系統的極限。</li></ul><h3 id="User-Acceptance-Testing-UAT，使用者驗收測試"><a href="#User-Acceptance-Testing-UAT，使用者驗收測試" class="headerlink" title="User Acceptance Testing(UAT，使用者驗收測試)"></a>User Acceptance Testing(UAT，使用者驗收測試)</h3><ul><li>通常是由一般的使用者（通常這些使用者不瞭解軟體的具體邏輯，但對業務邏輯非常熟悉）進行的測試，因此是面向終端使用者的測試，結束後通常就可以佈署到正式環境了(Production)。</li></ul><p>###　其他</p><ul><li>TPS（每秒事務數）代表每秒執行的事務數量，由資料庫管理系統和用戶用於描述每秒鐘的資料庫操作數。例如，用戶每分鐘執行6個事務，TPS為6 / 60s = 0.10 TPS。</li><li>QPS：Queries Per Second意思是「每秒查詢率」，是一台伺服器每秒能夠相應的”查詢次數”，是對一個特定的查詢伺服器在規定時間內所處理流量多少的衡量標準。<br>More info: <a href="https://kknews.cc/zh-tw/code/nax2lv3.html" target="_blank" rel="noopener">相關參考1</a><br>More info: <a href="https://kknews.cc/news/zejoy8l.html" target="_blank" rel="noopener">相關參考2</a></li></ul><p>More info: <a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88" target="_blank" rel="noopener">Continuous integration(wiki)</a><br>More info: <a href="https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E4%BA%A4%E4%BB%98" target="_blank" rel="noopener">Continuous Delivery(wiki)</a><br>More info: <a href="https://www.redhat.com/zh/topics/devops/what-is-ci-cd" target="_blank" rel="noopener">CI/CD(RedHat)</a><br>More info: <a href="https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95" target="_blank" rel="noopener">Software Testing(wiki)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;概念解釋。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
</feed>
