<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Max&#39;s Blog-程式學習研究記錄</title>
  <icon>https://www.gravatar.com/avatar/d4fa779638e91d085afca3ea034b7703</icon>
  <subtitle>求生是激發人的成長與潛能</subtitle>
  <link href="https://hand79.github.io/Blog/atom.xml" rel="self"/>
  
  <link href="https://hand79.github.io/Blog/"/>
  <updated>2022-09-29T12:22:36.253Z</updated>
  <id>https://hand79.github.io/Blog/</id>
  
  <author>
    <name>MaxHanChen</name>
    <email>maxdjkl@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>UML工具推薦</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20220903-uml-tool.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20220903-uml-tool.html</id>
    <published>2022-09-03T06:30:30.000Z</published>
    <updated>2022-09-29T12:22:36.253Z</updated>
    
    <content type="html"><![CDATA[<p>實務上覺得實用的工具</p><a id="more"></a><h3 id="PlantUML-推薦PG從這開始嘗試使用，跟寫code一樣方便"><a href="#PlantUML-推薦PG從這開始嘗試使用，跟寫code一樣方便" class="headerlink" title="PlantUML (推薦PG從這開始嘗試使用，跟寫code一樣方便)"></a>PlantUML (推薦PG從這開始嘗試使用，跟寫code一樣方便)</h3><ul><li>提供 Online Server 撰寫</li><li><a href="https://plantuml.com/zh/" target="_blank" rel="noopener">PlantUML</a></li></ul><h3 id="StarUML"><a href="#StarUML" class="headerlink" title="StarUML"></a>StarUML</h3><ul><li><a href="https://staruml.io/download" target="_blank" rel="noopener">StarUML</a></li></ul><h3 id="Draw-io"><a href="#Draw-io" class="headerlink" title="Draw.io"></a>Draw.io</h3><ul><li>提供 Online Server 撰寫</li><li>可存成可編輯的PNG</li><li><a href="https://app.diagrams.net/" target="_blank" rel="noopener">Draw.io</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;實務上覺得實用的工具&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>OpenShift基本使用觀念</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20220507-openshift.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20220507-openshift.html</id>
    <published>2022-05-07T09:00:30.000Z</published>
    <updated>2022-05-07T10:09:39.095Z</updated>
    
    <content type="html"><![CDATA[<p>由於專案關係，建了不少服務到OpenShift上面。<br>來開始記錄服務帶起來的基本流程。</p><a id="more"></a><h6 id="建立流程"><a href="#建立流程" class="headerlink" title="建立流程"></a>建立流程</h6><ol><li>先建立一個Project</li></ol><ul><li>這個名稱會影響內部的各專案的網路連結。例如名稱dev-test， 專案內部連結連上這個服務url為xxx.dev-test。(xxx 為專案內的服務名)</li></ul><ol start="2"><li><p>ConfigMaps<br>服務容器的環境變數</p></li><li><p>Services<br>設置服務名稱、port</p></li><li><p>Routes<br>對外URL、對該Route timeout設定</p></li><li><p>NetworkPolicies<br>防火牆、權限設置，這個可影響各專案是否可以內部互通。 若專案間沒設置就只能用外部Routes互通</p></li><li><p>DeploymentConfigs (這個會把Pod帶起來所以最後弄)</p></li></ol><ul><li>設置CPU使用、記憶體使用、 提供的port、服務檢測、服務備援、設定image來源、mount、triggers、termination-log 等設定</li></ul><p>Extra:</p><ul><li>CronJobs (做法類似linux指令)</li><li>ImageStreams (image 放置的地方)</li></ul><p>Deploy Script (視情況調整)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">IsSuccess()&#123;</span><br><span class="line">if [$? !&#x3D; 0]</span><br><span class="line">    then </span><br><span class="line">            echo &quot;$&#123;tput setaf 1&#125; ~~Caution:&quot; $1&quot; fail ! $&#123;tput sgr 0&#125;&quot;</span><br><span class="line">        exit 1</span><br><span class="line">else</span><br><span class="line">            echo &quot;$&#123;tput setaf 2&#125; ~~Execution:&quot; $1&quot; OK ! $&#123;tput sgr 0&#125;&quot;</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">read -p &quot;Please input [DeploymentConfig Name] : &quot; dcName</span><br><span class="line">read -p &quot;Please input [Version] : &quot; version</span><br><span class="line">read -p &quot;Please input [tar location path] : &quot; tar_location</span><br><span class="line">read -p &quot;Please input [OpenShift project] : &quot; openshift_project</span><br><span class="line">read -p &quot;Please input [OpenShift url] : &quot; openshift_url</span><br><span class="line">read -p &quot;Please input [OpenShift account] : &quot; account</span><br><span class="line">read -p &quot;Please input [OpenShift password] : &quot; password</span><br><span class="line"></span><br><span class="line">test -z $&#123;dcName&#125; &amp;&amp; echo &quot;You Must input a DeploymentConfig Name.&quot; &amp;&amp; exit 0</span><br><span class="line">test -z $&#123;version&#125; &amp;&amp; echo &quot;You Must input a version.&quot; &amp;&amp; exit 0</span><br><span class="line"></span><br><span class="line">image_name&#x3D;$dcName</span><br><span class="line">image_tag&#x3D;$version</span><br><span class="line">tar_location&#x3D;&quot;$&#123;tar_location&#125;&#x2F;$&#123;image_name&#125;-$&#123;image_tag&#125;.tar&quot;</span><br><span class="line"></span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class="line">oc login -u $account -p $password</span><br><span class="line">IsSuccess &quot;oc login&quot;</span><br><span class="line">oc project $openshift_project</span><br><span class="line">IsSuccess &quot;switch project&quot;</span><br><span class="line">podman login $openshift_url -p $&#123;oc whoami -t&#125; -u $&#123;oc whoami -t&#125;</span><br><span class="line">IsSuccess &quot;podman login&quot;</span><br><span class="line">podman load -i &quot;$&#123;tar_location&#125;&quot;</span><br><span class="line">IsSuccess &quot;podman load [$&#123;tar_location&#125;]&quot;</span><br><span class="line">podman push &quot;$&#123;openshift_url&#125;&#x2F;$&#123;openshift_project&#125;&#x2F;$&#123;image_name&#125;:$&#123;image_tag&#125;&quot;</span><br><span class="line">IsSuccess &quot;podman push&quot;</span><br><span class="line">oc tag $image_name:$image_tag $image_name:stable</span><br><span class="line">IsSuccess &quot;oc tag [$&#123;image_name&#125;:$&#123;image_tag&#125;] to stable&quot; </span><br><span class="line">oc rollout status dc&#x2F;$dcName</span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;End&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br></pre></td></tr></table></figure><p>more info:<br><a href="http://c.biancheng.net/cpp/view/2739.html" target="_blank" rel="noopener">Shell教程</a><br><a href="https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.4/html/cli_tools/cli-developer-commands#login" target="_blank" rel="noopener">Open shift CLI</a><br><a href="https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/applications/deployments" target="_blank" rel="noopener">Deployment vs DeploymentConfig</a><br><a href="https://blog.51cto.com/u_15127570/2712882" target="_blank" rel="noopener">OpenShift中的Deployment和DeploymentConfig </a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由於專案關係，建了不少服務到OpenShift上面。&lt;br&gt;來開始記錄服務帶起來的基本流程。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Spring 與 Docker 筆記</title>
    <link href="https://hand79.github.io/Blog/posts/Docker/20220306-docker-note-spring.html"/>
    <id>https://hand79.github.io/Blog/posts/Docker/20220306-docker-note-spring.html</id>
    <published>2022-03-06T12:30:20.000Z</published>
    <updated>2022-03-06T14:40:43.324Z</updated>
    
    <content type="html"><![CDATA[<p>基本操作概念與參考整理。</p><a id="more"></a><h3 id="SpringBoot構建Docker鏡像的-3-種方式"><a href="#SpringBoot構建Docker鏡像的-3-種方式" class="headerlink" title="SpringBoot構建Docker鏡像的 3 種方式"></a>SpringBoot構建Docker鏡像的 3 種方式</h3><ul><li>使用 spring-boot-maven-plugin 內置的 build-image.<ul><li>mvn spring-boot:build-image</li></ul></li><li>使用 Google 的 jib-maven-plugin。<ul><li>mvn compile jib:build (Build your container image) - 會推送</li><li>mvn compile jib:dockerBuild (Build to Docker daemon) - local</li><li>mvn compile jib:buildTar  - local</li></ul></li><li>使用 dockerfle-maven-plugin。</li></ul><h3 id="一般docker打包流程"><a href="#一般docker打包流程" class="headerlink" title="一般docker打包流程"></a>一般docker打包流程</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">+---------+     +---------+           +-----------------------------------------------+</span><br><span class="line">| Project |----&gt;|   JAR   |-------+   |   Docker Daemon                               |</span><br><span class="line">+---------+     +---------+       |   | +---------------+  build  +-----------------+ |     +------------------+</span><br><span class="line">                                  +----&gt;| Build context |--------&gt;| Container Image |------&gt;| Container Image  |</span><br><span class="line">                +------------+    |   | +---------------+         | (docker cache)  | |     | (registry)       |</span><br><span class="line">                | Dockerfile |----+   |                           +-----------------+ |     +------------------+</span><br><span class="line">                +------------+        +-----------------------------------------------+</span><br></pre></td></tr></table></figure><h3 id="JIB-打包-唯一無須本機須安裝docker環境，就可打包成tarball"><a href="#JIB-打包-唯一無須本機須安裝docker環境，就可打包成tarball" class="headerlink" title="JIB 打包(唯一無須本機須安裝docker環境，就可打包成tarball)"></a>JIB 打包(唯一無須本機須安裝docker環境，就可打包成tarball)</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">+---------+       Jib      +------------------+</span><br><span class="line">| Project |---------------&gt;| Container Image  |</span><br><span class="line">+---------+                | (registry)       |</span><br><span class="line">                           +------------------+</span><br></pre></td></tr></table></figure><h3 id="參考"><a href="#參考" class="headerlink" title="參考"></a>參考</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">      &lt;groupId&gt;com.google.cloud.tools&lt;&#x2F;groupId&gt;</span><br><span class="line">      &lt;artifactId&gt;jib-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class="line">      &lt;version&gt;$&#123;jib.version&#125;&lt;&#x2F;version&gt;</span><br><span class="line">      &lt;configuration&gt;</span><br><span class="line">        &lt;skip&gt;$&#123;jib.skip&#125;&lt;&#x2F;skip&gt;</span><br><span class="line">        &lt;!-- 配置基礎image--&gt;</span><br><span class="line">        &lt;from&gt;</span><br><span class="line">          &lt;image&gt;openjdk:8-jre-alpine&lt;&#x2F;image&gt;</span><br><span class="line">        &lt;&#x2F;from&gt;</span><br><span class="line">        &lt;!-- 配置推送地址，倉庫名，image名稱--&gt;</span><br><span class="line">        &lt;to&gt;</span><br><span class="line">          &lt;image&gt;$&#123;推送地址&#125;&#x2F;$&#123;倉庫名&#125;&#x2F;$&#123;image名稱&#125;&lt;&#x2F;image&gt;</span><br><span class="line">          &lt;tags&gt;</span><br><span class="line">            &lt;!-- &lt;tag&gt;$&#123;jib.repository.name&#125;&lt;&#x2F;tag&gt;--&gt;</span><br><span class="line">            &lt;!-- &lt;tag&gt;$&#123;version&#125;&lt;&#x2F;tag&gt;--&gt;</span><br><span class="line">          &lt;&#x2F;tags&gt;</span><br><span class="line">          &lt;auth&gt;</span><br><span class="line">            &lt;username&gt;$&#123;帳號&#125;&lt;&#x2F;username&gt;</span><br><span class="line">            &lt;password&gt;$&#123;密碼&#125;&lt;&#x2F;password&gt;</span><br><span class="line">          &lt;&#x2F;auth&gt;</span><br><span class="line">        &lt;&#x2F;to&gt;</span><br><span class="line">        &lt;!-- jib默認不推送到非https的私服--&gt;</span><br><span class="line">        &lt;!--          &lt;allowInsecureRegistries&gt;true&lt;&#x2F;allowInsecureRegistries&gt;--&gt;</span><br><span class="line">        &lt;container&gt;</span><br><span class="line">          &lt;mainClass&gt;$&#123;jib.main.class&#125;&lt;&#x2F;mainClass&gt;</span><br><span class="line">          &lt;labels&gt;</span><br><span class="line">            &lt;name&gt;$&#123;artifactId&#125;&lt;&#x2F;name&gt;</span><br><span class="line">          &lt;&#x2F;labels&gt;</span><br><span class="line">  &lt;ports&gt;</span><br><span class="line">&lt;port&gt;8080&lt;&#x2F;port&gt;</span><br><span class="line">&lt;port&gt;8081&lt;&#x2F;port&gt;</span><br><span class="line">  &lt;&#x2F;ports&gt;</span><br><span class="line">        &lt;&#x2F;container&gt;</span><br><span class="line">      &lt;&#x2F;configuration&gt;</span><br><span class="line">      &lt;!--綁定到maven lifecicle--&gt;</span><br><span class="line">      &lt;!--        &lt;executions&gt;--&gt;</span><br><span class="line">      &lt;!--          &lt;execution&gt;--&gt;</span><br><span class="line">      &lt;!--            &lt;phase&gt;package&lt;&#x2F;phase&gt;--&gt;</span><br><span class="line">      &lt;!--            &lt;goals&gt;--&gt;</span><br><span class="line">      &lt;!--              &lt;goal&gt;build&lt;&#x2F;goal&gt;--&gt;</span><br><span class="line">      &lt;!--            &lt;&#x2F;goals&gt;--&gt;</span><br><span class="line">      &lt;!--          &lt;&#x2F;execution&gt;--&gt;</span><br><span class="line">      &lt;!--        &lt;&#x2F;executions&gt;--&gt;</span><br><span class="line">    &lt;&#x2F;plugin&gt;</span><br><span class="line">  &lt;&#x2F;plugins&gt;</span><br></pre></td></tr></table></figure><h3 id="Maven-plugin-比較"><a href="#Maven-plugin-比較" class="headerlink" title="Maven plugin 比較"></a>Maven plugin 比較</h3><p><img src="https://pic1.xuehuaimg.com/proxy/csdn/https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2MwMDAxZTY5MmUxNTQ5NGFhOGQ2MmFmOWE2NmVlMDli?x-oss-process=image/format,png" alt="Maven plugin 比較"></p><p>註:</p><ul><li>SpringBoot 原生的方式，什麼都不需要自己做，直接就能用。</li><li>最有特點的是 Jib，不需要你本地安裝 Docker，可以直接推送到指定的倉庫。 </li><li>前2個與比較吃網路環境狀態</li></ul><p>參考: <a href="https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin" target="_blank" rel="noopener">Jib 官網</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基本操作概念與參考整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://hand79.github.io/Blog/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://hand79.github.io/Blog/tags/Docker/"/>
    
    <category term="Java" scheme="https://hand79.github.io/Blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>Docker 筆記</title>
    <link href="https://hand79.github.io/Blog/posts/Docker/20220306-docker-note.html"/>
    <id>https://hand79.github.io/Blog/posts/Docker/20220306-docker-note.html</id>
    <published>2022-03-06T11:30:20.000Z</published>
    <updated>2022-03-06T13:41:11.832Z</updated>
    
    <content type="html"><![CDATA[<p>基本操作概念與指令整理。</p><a id="more"></a><h3 id="Docker-安裝方式-在Windows-下"><a href="#Docker-安裝方式-在Windows-下" class="headerlink" title="Docker 安裝方式(在Windows 下)"></a>Docker 安裝方式(在Windows 下)</h3><ul><li>Docker Toolbox (這個目前用下來最靈活，但目前官方已不再著手開發)</li><li>Docker Desktop (需要Hyper-V，Windows 10專業版以上才有的Hyper-V虛擬技術可用)</li></ul><p>WSL 2 backend(Windows 需要裝 Linux kernel，可從微軟商店下載):</p><ul><li>Windows 11 64-bit: Home or Pro version 21H2 or higher, or Enterprise or Education version 21H2 or higher.</li><li>Windows 10 64-bit: Home or Pro 2004 (build 19041) or higher, or Enterprise or Education 1909 (build 18363) or higher.</li></ul><p>Hyper-V: </p><ul><li>Windows 11 64-bit: Pro version 21H2 or higher, or Enterprise or Education version 21H2 or higher.</li><li>Windows 10 64-bit: Pro 2004 (build 19041) or higher, or Enterprise or Education 1909 (build 18363) or higher.</li></ul><p>註:<br>目前VMware 、  Virtualbox 、BlueStack是可以在Hyper-V啟動，但啟動的速度有待改善，若有需要同時使用這些軟體的建議用Toolbox的安裝方式。</p><p><a href="https://docs.docker.com/desktop/windows/install/" target="_blank" rel="noopener">Docker Desktop 安裝文件</a><br><a href="https://github.com/docker-archive/toolbox/releases" target="_blank" rel="noopener">Docker Toolbox 安裝壓縮檔</a></p><h3 id="存放Docker映像檔的地方"><a href="#存放Docker映像檔的地方" class="headerlink" title="存放Docker映像檔的地方"></a>存放Docker映像檔的地方</h3><ul><li>官方的Docker Hub: 預設的下載來源</li><li>非官方的公開Docker Registry：如果你要從這些地方下載，就必須在下載時指定完整的位址名稱，也可能需要該網站的認證金鑰，或是在Docker執行的設定檔中先設定好</li><li>私有的Docker Registry：公司內部可以建立私有的Registry以保證不會用到來源不明的映像檔 </li></ul><h3 id="Docker-Hub的個人映像檔名稱"><a href="#Docker-Hub的個人映像檔名稱" class="headerlink" title="Docker Hub的個人映像檔名稱"></a>Docker Hub的個人映像檔名稱</h3><ul><li>標準的Docker Hub的個人映像檔名稱格式: <user name>/<repo name>:<tag name><ul><li>user name：使用者名稱。在Docker Hub上每個使用者都有一個獨立的名稱</li><li>repo name：倉庫名稱。在Docker Hub上的每一個使用者，都可以建立自己的倉庫，倉庫中可以放多個映像檔。</li><li>tag name：要分辨同一個倉庫中的不同映像檔，就要用tag name來區分。</li></ul><ul><li>如果該倉庫中只有一個映像檔，則tag name可以省略。</li><li>如果該倉庫中有多個映像檔，在沒有指定tag name時，以最新的一個為主。</li><li>同一個映像檔可以有多個tag name，從相同的映像檔ID看，可看做是別名，也可利用做版控。</li></ul></tag></repo></user></li></ul><h3 id="Docker-操作指令"><a href="#Docker-操作指令" class="headerlink" title="Docker 操作指令"></a>Docker 操作指令</h3><ul><li><p>docker info : 列出和系統相關的資訊，如image數、Container數、檔案系統目錄、Linux核心版本，使用Linux版本、CPU及記憶體等。</p></li><li><p>docker version : 列出目前Docker的版本</p></li><li><p>docker images: 列出本機image</p><ul><li>-a：列出完整的image層次資訊。每個映像檔是由不同層次組成的，我們會在稍後說明。</li><li>-q：只列出image id。這在做映像檔批次處理時很方便。</li></ul></li><li><p>docker pull :  就預設從官方的Registry下載(registry.hub.docker.com)(eg. docker pull ubuntu:latest)</p><ul><li>-a: 將某一個倉庫的所有image都下載</li></ul></li><li><p>docker save : 打成tarball(eg. docker save -o demo.tar user/demo)</p><ul><li>-o Write to a file, instead of STDOUT</li></ul></li><li><p>docker load : 載入tarball還原回image(eg. docker load –input demo.tar)</p><ul><li>-i Read from tar archive file, instead of STDIN</li></ul></li><li><p>docker rmi : 刪除映像檔</p><ul><li>-f 強迫刪除</li><li>-no-prune=true這個參數，只殺掉有tag name的image。</li></ul></li><li><p>docker rmi -f $(docker images -aq) : 一次刪掉所有image (Linux的批次指令) </p></li><li><p>docker tag : 給予image 一個tag名稱</p></li><li><p>docker build : 使用 Dockerfile create image </p><ul><li><a href="https://docs.docker.com/engine/reference/commandline/build/" target="_blank" rel="noopener">Docker build Options</a></li></ul></li><li><p>docker history : 查看image歷史紀錄</p></li><li><p>docker push: 上傳image (若沒有登入會提示你輸入帳號、密碼及電子郵件，可以先使用docker login 處理) </p></li></ul><h3 id="Docker有關Container的指令"><a href="#Docker有關Container的指令" class="headerlink" title="Docker有關Container的指令"></a>Docker有關Container的指令</h3><p>Container和image之間的操作:</p><ul><li>commit：將Container的改變存入image</li><li>export：將Container存成快照</li><li>import：從Container快照恢復成image   </li></ul><p>Container執行操作:</p><ul><li>create：建立Container並執行指令</li><li>run：同create<ul><li>-d 背景執行</li><li>-p 對外port號(eg. docker run -p 8080:8080 -p 8081:8081 demo)</li><li>–name Container名稱</li><li>-t：attach時Container的螢幕會接到原來的螢幕上。</li><li>-i：attach時鍵盤輸入會被Container接手<br>註: docker run -it 會切入到要執行 Container內部終端操作介面</li></ul></li><li>kill：刪除執行中的Container，但Container還是存在，只是沒啟動。</li><li>rm：刪除Container(停止或運行中都行)，Container完整移除</li><li>pause：暫停執行中的Container，仍暫有記憶體停，服務不中斷</li><li>unpause：恢復暫停中的Container</li><li>stop：停止執行中的Container，但不暫有記憶體，服務中斷</li><li>start：啟動停止中的Container</li><li>restart：重新啟動Container</li><li>wait：讓Container暫停直到Container停止為止</li><li>rename： 更名Container</li></ul><p>查詢Container的狀態:  </p><ul><li>inspect：檢查Container的狀態</li><li>stats：查看Container的CPU、記憶體及網路使用</li><li>port：查看Container的通訊埠使用</li><li>ps：查看Container使用狀態</li><li>top：查看Container在主系統中的記憶體使用</li><li>dip：查看Container的IP</li><li>dpid：查看Container的pid</li></ul><p>Container執行時的操作:</p><ul><li>docker attach : 進入執行中Container內部終端  (進入可用exit 離開該Container)<br>註: 不建議用，該指令受限於啟動時的參數影響之後的操作結果。如果知道了entrypoint或者有程式正在執行，通過docker attach進入之後是不能執行操作的，因為退出就會終止Container的運行(–sig-proxy=false 需下這個參數防止)。</li><li>docker exec : 在外部向Container內執行指令。推薦使用該指令代替docker attach做日常維運用途</li><li>docker denter ：進入Container</li><li>docker logs ： 將Container內的輸出顯示</li></ul><p>Container和主系統之間的操作:</p><ul><li>cp：複製Container內的檔案到主系統</li><li>diff：列出兩個Container之間檔案系統差異</li><li>events：列出某個時間點之前或之後的事件</li></ul><p>More info: <a href="https://www.runoob.com/docker/docker-command-manual.html" target="_blank" rel="noopener">Docker 命令大全</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;基本操作概念與指令整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="https://hand79.github.io/Blog/categories/Docker/"/>
    
    
    <category term="Docker" scheme="https://hand79.github.io/Blog/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>reCAPTCHA v2(Google)</title>
    <link href="https://hand79.github.io/Blog/posts/JavaScript/20220303-javascript-reCAPTCHA-v2.html"/>
    <id>https://hand79.github.io/Blog/posts/JavaScript/20220303-javascript-reCAPTCHA-v2.html</id>
    <published>2022-03-03T11:53:39.796Z</published>
    <updated>2021-10-03T15:43:11.862Z</updated>
    
    <content type="html"><![CDATA[<p>最近專案碰到的東西，研究一下該驗證機制的應用。</p><a id="more"></a><p>reCAPTCHA v2 目前普遍網站使用者常看到的模式，以下為google 提供的範例demo執行後的樣子。(目前僅供demo UI 樣式)</p><p>拿到Token後進行後台驗證(會用到私鑰)， <a href="https://developers.google.com/recaptcha/docs/verify" target="_blank" rel="noopener">Verifying the user’s response</a> 。</p><script src="https://www.google.com/recaptcha/api.js?onload=onloadCallback&render=explicit" async defer></script><script type="text/javascript">var site_key = "6LcGY6QcAAAAAD3IvqNqOPVW_l0U_3IeChVOL6nt";      var verifyCallback = function(response) {        alert(response);      };      var widgetId1;      var widgetId2;      var onloadCallback = function() {        // Renders the HTML element with id 'example1' as a reCAPTCHA widget.        // The id of the reCAPTCHA widget is assigned to 'widgetId1'.        widgetId1 = grecaptcha.render('example1', {          'sitekey' : site_key,          'theme' : 'light'        });        widgetId2 = grecaptcha.render(document.getElementById('example2'), {          'sitekey' : site_key        });        grecaptcha.render('example3', {          'sitekey' : site_key,          'callback' : verifyCallback,          'theme' : 'dark'        });      };</script><!-- The g-recaptcha-response string displays in an alert message upon submit. --><form action="javascript:alert(grecaptcha.getResponse(widgetId1));">   <div id="example1"></div>   <br>     <input type="submit" value="getResponse"></form><br><!-- Resets reCAPTCHA widgetId2 upon submit. --><form action="javascript:grecaptcha.reset(widgetId2);"><div id="example2"></div><br><input type="submit" value="reset"></form><br><!-- POSTs back to the page's URL upon submit with a g-recaptcha-response POST parameter. --><form action="?" method="POST"> <div id="example3"></div>   <br>   <input type="submit" value="Submit"></form><p>參考: <a href="https://support.google.com/a/answer/1217728?hl=zh-Hant" target="_blank" rel="noopener">什麼是人機驗證 (Captcha)？</a><br>參考: <a href="https://medium.com/@d101201007/google-recaptcha%E6%A9%9F%E5%99%A8%E4%BA%BA%E9%A9%97%E8%AD%89-%E6%95%99%E5%AD%B8-php%E7%AF%84%E4%BE%8B-3685a394dce2" target="_blank" rel="noopener">Google reCAPTCHA機器人驗證 教學 PHP範例</a><br>參考: <a href="https://www.google.com/recaptcha/about/" target="_blank" rel="noopener">recaptcha Google 官網</a><br>參考: <a href="https://developers.google.com/recaptcha/docs/v3" target="_blank" rel="noopener">reCAPTCHA v3</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近專案碰到的東西，研究一下該驗證機制的應用。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://hand79.github.io/Blog/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://hand79.github.io/Blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>連線DB2有時會遇上java.io.CharConversionException</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20211127-DB2-CharConversionException.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20211127-DB2-CharConversionException.html</id>
    <published>2021-11-27T12:47:30.000Z</published>
    <updated>2021-11-27T15:40:50.147Z</updated>
    
    <content type="html"><![CDATA[<p>之前做的案子遇啟動時或連接時，有時候會遇上的問題，與資料編碼轉相關，留個解法。</p><a id="more"></a><p>問題:<br>db2.jcc.charsetDecoderEncoder=3 so that instead of throwing an exception the JCC driver returns the Unicode REPLACEMENT CHARACTER (U+FFFD) in place of a sequence of bytes that is not a valid UTF-8 string</p><p>解法:<br>在java_opts後面加上參數(-Ddb2.jcc.charsetDecoderEncoder=3)<br>註: 在tomcat或JBoss啟動放上參數即可</p><h3 id="參考"><a href="#參考" class="headerlink" title="參考:"></a>參考:</h3><p>more info:<a href="https://stackoverflow.com/questions/42685541/sqoop-error-for-java-io-charconversionexception-which-is-non-utf-8-charactor" target="_blank" rel="noopener">Sqoop error for java.io.charconversionException which is non UTF-8 charactor</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前做的案子遇啟動時或連接時，有時候會遇上的問題，與資料編碼轉相關，留個解法。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>reCAPTCHA v3(Google)</title>
    <link href="https://hand79.github.io/Blog/posts/JavaScript/20211003-javascript-reCAPTCHA-v3.html"/>
    <id>https://hand79.github.io/Blog/posts/JavaScript/20211003-javascript-reCAPTCHA-v3.html</id>
    <published>2021-10-03T12:20:20.000Z</published>
    <updated>2021-10-03T15:43:19.726Z</updated>
    
    <content type="html"><![CDATA[<p>這個是reCAPTCHA v3 跟v2的做法不太一樣，這作法是為了使用者別再點”我不是機器人”的等類似的選項，是對使用者體驗是個好事，<br>不過這分數的機制作法，在某些情況可能會誤判，各家瀏覽器分數不太一樣。(目前僅供demo UI 樣式)</p><a id="more"></a><p>reCAPTCHA v3多了特有的 2 個值：action、score，其中這個分數越高代表非機器人。</p><ul><li>action: 送驗證時要填的，限填英文、數字、斜線。當作「貼標籤」來用，為這次的驗證貼上一個標籤，在後台的報表中會看到。</li><li>store: 後端向 Google 發 POST 後，response 裡會帶上的值，數值是 0 到 1的範圍。(  0 代表是機器人，1 代表是真人。)</li></ul><p>拿到Token後進行後台驗證(會用到私鑰)， <a href="https://developers.google.com/recaptcha/docs/verify" target="_blank" rel="noopener">Verifying the user’s response</a> 。</p><script src="https://www.google.com/recaptcha/api.js?render=6Lc7RKQcAAAAACuaIO-vd-Gi2mEMU9MdQBTvFg2Z" async defer></script><p>HTML code :</p><script>   function onSubmit(token) {     alert("送去後端驗證用的token: " + token);   }</script><p><button class="g-recaptcha" data-sitekey="6Lc7RKQcAAAAACuaIO-vd-Gi2mEMU9MdQBTvFg2Z" data-callback="onSubmit" data-action="submit">提交</button></p><p>參考: <a href="https://support.google.com/a/answer/1217728?hl=zh-Hant" target="_blank" rel="noopener">什麼是人機驗證 (Captcha)？</a><br>參考: <a href="https://medium.com/@d101201007/google-recaptcha%E6%A9%9F%E5%99%A8%E4%BA%BA%E9%A9%97%E8%AD%89-%E6%95%99%E5%AD%B8-php%E7%AF%84%E4%BE%8B-3685a394dce2" target="_blank" rel="noopener">Google reCAPTCHA機器人驗證 教學 PHP範例</a><br>參考: <a href="https://www.google.com/recaptcha/about/" target="_blank" rel="noopener">recaptcha Google 官網</a><br>參考: <a href="https://developers.google.com/recaptcha/docs/v3" target="_blank" rel="noopener">reCAPTCHA v3</a><br>參考: <a href="https://recaptcha-demo.appspot.com/" target="_blank" rel="noopener">recaptcha-demo.appspot.com</a><br>參考: <a href="https://letswritetw.github.io/letswrite-recaptcha-v3/gas.html" target="_blank" rel="noopener">reCAPTCHA v3 使用範例</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;這個是reCAPTCHA v3 跟v2的做法不太一樣，這作法是為了使用者別再點”我不是機器人”的等類似的選項，是對使用者體驗是個好事，&lt;br&gt;不過這分數的機制作法，在某些情況可能會誤判，各家瀏覽器分數不太一樣。(目前僅供demo UI 樣式)&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://hand79.github.io/Blog/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://hand79.github.io/Blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>Java 8 to 17 各版本功能變化</title>
    <link href="https://hand79.github.io/Blog/posts/Java/20210926-java-feature-version-history.html"/>
    <id>https://hand79.github.io/Blog/posts/Java/20210926-java-feature-version-history.html</id>
    <published>2021-09-26T12:47:33.000Z</published>
    <updated>2021-09-26T14:10:38.942Z</updated>
    
    <content type="html"><![CDATA[<p>有鑑於國外Java更新已經到那麼遠了，整理一些資訊留存，以便後續追蹤新版本功能特色的資料。</p><p>more info:<a href="https://advancedweb.hu/a-categorized-list-of-all-java-and-jvm-features-since-jdk-8-to-17/" target="_blank" rel="noopener">A categorized list of all Java and JVM features since JDK 8 to 17</a><br>more info:<a href="https://openjdk.java.net/projects/jdk/" target="_blank" rel="noopener">JDK Project(openjdk官網)</a><br>more info:<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/new-features/java%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">java新特性总结.md</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有鑑於國外Java更新已經到那麼遠了，整理一些資訊留存，以便後續追蹤新版本功能特色的資料。&lt;/p&gt;
&lt;p&gt;more info:&lt;a href=&quot;https://advancedweb.hu/a-categorized-list-of-all-java-and-jvm-fea</summary>
      
    
    
    
    <category term="Java" scheme="https://hand79.github.io/Blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://hand79.github.io/Blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>專案遇上Win10 MAC Address權限設定問題與網路密碼更新的問題</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210815-project-issue-0001.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210815-project-issue-0001.html</id>
    <published>2021-08-15T14:47:30.000Z</published>
    <updated>2021-08-15T15:04:48.333Z</updated>
    
    <content type="html"><![CDATA[<p>專案遇上Win10 MAC Address權限設定問題與網路密碼更新的問題</p><a id="more"></a><h1 id="MAC-Address-相關"><a href="#MAC-Address-相關" class="headerlink" title="MAC Address 相關"></a>MAC Address 相關</h1><h3 id="Win10"><a href="#Win10" class="headerlink" title="Win10"></a>Win10</h3><ul><li>MAC Address 查詢方法， <a href="https://www.kocpc.com.tw/archives/310582" target="_blank" rel="noopener">如何在 Windows 10 上查找 MAC 位址（實體位址）？ 5 個方法一次教給你</a></li><li>Win10 新增的功能(<a href="https://support.microsoft.com/zh-tw/windows/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%A8%E6%A9%9F%E7%A1%AC%E9%AB%94%E4%BD%8D%E5%9D%80-ac58de34-35fc-31ff-c650-823fc48eb1bc" target="_blank" rel="noopener">隨機硬體位址</a>)<h3 id="Android-MAC-Address-隨機位址的發展歷程"><a href="#Android-MAC-Address-隨機位址的發展歷程" class="headerlink" title="Android - MAC Address 隨機位址的發展歷程"></a>Android - MAC Address 隨機位址的發展歷程</h3></li><li>從 Android 8.0 開始，Android 設備在未連接到網絡的情況下探測新網絡時，會使用隨機分配的 MAC 地址。</li><li>在 Android 9 中，您可以啟用一個開發者選項（默認處於停用狀態），使設備在連接到 WLAN 網絡時使用隨機分配的 MAC 地址。</li><li>在 Android 10 中，默認為客戶端模式、SoftAp 和 WLAN 直連啟用隨機分配 MAC 地址功能。 隨機分配 MAC 地址可防止監聽器使用 MAC 地址來生成設備活動的歷史記錄，從而加強對用戶隱私的保護。 此外，在 Wi-Fi 感知和 Wi-Fi RTT 操作中也會使用隨機分配的 MAC 地址。</li></ul><p>因此需要固定MAC 請記得 WIN10把隨機硬體位址的功能關掉，Andriod 則參考 <a href="(https://support.hdeone.com/hc/zh-tw/articles/360000647761">在Android 10的智慧手機上安裝登錄憑證</a>該文處理即可</p><p>#網域密碼原則查詢 (win cmd 常用指令)<br>當不知道為何不能更新的密碼的時候，可以更明確的跟當地網管敘述問題何在。</p><ul><li>net accounts /domain </li><li>net user 帳號 /domain 指令即可得知每個使用者密碼原則<br><a href="http://xmrongta.com/EFNET/src/_Common/AppUtil/Help/Program/pwdchange.pdf" target="_blank" rel="noopener">網域密碼變更處理原則</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;專案遇上Win10 MAC Address權限設定問題與網路密碼更新的問題&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Oracle - Automatic Workload Repository (AWR) Report</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210405-oracle-awr-report.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210405-oracle-awr-report.html</id>
    <published>2021-04-05T12:20:30.000Z</published>
    <updated>2021-04-05T14:02:35.682Z</updated>
    
    <content type="html"><![CDATA[<p>最近被抓來看效能問題，做點查詢相關資料記錄。</p><a id="more"></a><p><a href="https://iter01.com/266908.html" target="_blank" rel="noopener">Oracle AWR報告指標全解析</a><br><a href="https://oracle-base.com/articles/10g/automatic-workload-repository-10g" target="_blank" rel="noopener">Automatic Workload Repository (AWR) in Oracle Database 10g - oracle-base </a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近被抓來看效能問題，做點查詢相關資料記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Oracle - Select指定傳回筆數</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210404-oracle-sql-select-rownum.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210404-oracle-sql-select-rownum.html</id>
    <published>2021-04-04T12:20:30.000Z</published>
    <updated>2021-04-05T13:41:21.914Z</updated>
    
    <content type="html"><![CDATA[<p>由於Oracle不支持Select Top語句，所以在Oracle中經常是用Order By跟rownum的組合來實現Select Top N的查詢，<br>也跟PostgreSQL下的方法不一樣，不是用limit限制資料筆數，因此做記錄。</p><p>OS: 整理完後我開始懷念PostgreSQL語法的簡潔…</p><a id="more"></a><p>Oracle中 Select指令沒有類似LIMIT的參數可以使用來限制傳回資料的筆數，但是可以利用 ORACLE中的Rownum的值作一點手腳來限制傳回值的範圍。</p><h4 id="ROWNUM-說明："><a href="#ROWNUM-說明：" class="headerlink" title="ROWNUM 說明："></a>ROWNUM 說明：</h4><ul><li>rownum不能以任何表的名稱作為前綴字。</li><li>Oracle 使用 rownum 作為查詢結果行的編號，第一行是1，第二行是2， 以此類推，可以用於限制查詢返回的總行數。</li><li>rownum的值在”查詢結果輸出時自動產生”，因此第一條始終是1。</li><li>Oracle中的rownum的是在查找資料的時候產生的序號，所以想對指定排序的數據去指定的rowmun行數據就必須注意了。</li><li>要注意的是在使用rownum時，只有當Order By 的字段是主鍵或索引時，查詢結果才會先排序再計算rownum,但是，對非主鍵欄位進行排序時卻不是。<br>出現這種的原因是：Oracle 先按物理存儲位置（rowid）順序取出滿足rownum 條件的記錄，即物理位置上的前5條數據，然後在對這些數據按照Order By 的字段進行排序，而不是我們所期望的先排序、再取特定記錄數。(因此排序的欄位建議是有索引的欄位)</li><li>若無索引或主鍵，只能用子查詢來實現先排序。(注意查詢效能的問題)</li></ul><p>1、ROWNUM 是偽列，必須要有返回結果後，每條返回記錄就會對應產生一個ROWNUM數值；<br>2、返回結果記錄的ROWNUM 是從1 開始排序的，因此第一條始終是1;這樣，當查詢到第一條記錄時，該記錄的ROWNUM 為1，但條件要求ROWNUM&gt;1，因此不符合，繼續查詢下一條；因為前面沒有符合要求的記錄，因此下一條記錄過來後，其ROWNUM 還是為1，如此循環，就不會產生結果。</p><h4 id="分頁顯示實作"><a href="#分頁顯示實作" class="headerlink" title="分頁顯示實作:"></a>分頁顯示實作:</h4><p>通用的作法:<br>select * from (子查詢) WHERE rownum Between 初始列  AND 尾列;</p><p>Tips:</p><ul><li>很多開發者在確認某個表中是否有相應數據時，喜歡加上ROWNUM=1，其想法就是只要存在一條數據就說明有相應數據，查詢就可以直接返回了，這樣就能提高性能了。<br>但是在Oracle 10G之前，使用rownum=1 是不能達到預期的性能效果的，而是需要通過&lt;2 或&lt;=1 作為過濾條件才能達到預期效果。</li></ul><p><a href="https://blog.csdn.net/zxh2075/article/details/77110736" target="_blank" rel="noopener">Oracle rownum 用法詳解</a><br><a href="https://blog.csdn.net/bbliutao/article/details/8531091" target="_blank" rel="noopener">Oracle rownum 注意事項</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由於Oracle不支持Select Top語句，所以在Oracle中經常是用Order By跟rownum的組合來實現Select Top N的查詢，&lt;br&gt;也跟PostgreSQL下的方法不一樣，不是用limit限制資料筆數，因此做記錄。&lt;/p&gt;
&lt;p&gt;OS: 整理完後我開始懷念PostgreSQL語法的簡潔…&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Oracle - 開發常用查詢語法</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210403-oracle-daily-sql.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210403-oracle-daily-sql.html</id>
    <published>2021-04-03T12:20:30.000Z</published>
    <updated>2021-04-05T14:22:55.662Z</updated>
    
    <content type="html"><![CDATA[<p>做個開發常使用的查詢記錄。</p><a id="more"></a><p>– 查詢版本<br>SELECT * FROM v$version;<br>SELECT * FROM product_component_version;</p><p>– 目前資料庫的語系<br>SELECT * FROM nls_database_parameters WHERE parameter = ‘NLS_CHARACTERSET’;</p><p>– 查詢目前資料庫名稱<br>SELECT NAME FROM v$database;</p><p>– 查詢session連線數<br>select count(*) from v$session；</p><p>–當前的連接數<br>select count(*) from v$process</p><p>– 查看不同使用者的連接數<br>select username,count(username) from v$session where username is not null group by username;</p><p>– 查詢oracle的併發連接數<br>select count(*) from v$session where status=’ACTIVE’;</p><p>– 資料庫允許的最大連接數<br>select value from v$parameter where name = ‘processes’ </p><p>– 修改最大連接數:<br>alter system set processes = 300 scope = spfile;</p><p>– 重啟資料庫:<br>shutdown immediate;<br>startup;</p><p>–查看當前有哪些使用者正在使用資料<br>SELECT osuser, a.username,cpu_time/executions/1000000||’s’, sql_fulltext,machine<br>from v$session a, v$sqlarea b<br>where a.sql_address =b.address order by cpu_time/executions desc;</p><p>– 按機器名分組查<br>select username,machine,count(username) from v$session where username is not null group by username,machine;</p><p>– 查看使用者或角色系統許可權(直接賦值給使用者或角色的系統許可權)：<br>select * from dba_sys_privs;<br>select * from user_sys_privs;</p><p>– 查看角色(只能查看登陸使用者擁有的角色)所包含的許可權<br>select * from role_sys_privs;</p><p>– 查看所有角色：<br>select * from dba_roles;</p><p>– 查看所有使用者<br>select * from all_users;</p><p>– 查看使用者或角色所擁有的角色：<br>select * from dba_role_privs;<br>select * from user_role_privs;</p><p>– 查看使用者物件使用權限：<br>select * from dba_tab_privs;<br>select * from all_tab_privs;<br>select * from user_tab_privs;</p><p>– 查看哪些使用者有sysdba或sysoper系統許可權(查詢時需要相應許可權)<br>select * from V$PWFILE_USERS; </p><p>– 查詢所有 Table<br>SELECT * FROM USER_OBJECTS;<br>SELECT * FROM USER_OBJECTS ORDER BY OBJECT_NAME;</p><p>– 查詢所有 Table &amp; 欄位<br>SELECT * FROM user_tab_columns ORDER BY TABLE_NAME;<br>SELECT * FROM user_tab_columns WHERE table_name = UPPER(‘表格名稱’) ORDER BY TABLE_NAME;</p><p>– 取得 TABLE 的欄位<br>desc UPPER(‘表格名稱’);</p><p>– 取得 Table 註解<br>SELECT table_name, comments<br>FROM sys.user_tab_comments<br>WHERE table_type =’TABLE’<br>AND comments IS NOT NULL;</p><p>SELECT table_name, comments FROM sys.user_tab_comments WHERE table_name = UPPER(‘表格名稱’);</p><p>– 取得 Column 註解<br>SELECT table_name, column_name, comments FROM sys.user_col_comments<br>WHERE comments IS NOT NULL;</p><p>SELECT table_name, column_name, comments FROM sys.user_col_comments WHERE table_name = UPPER(‘表格名稱’);</p><p>–登入的帳號在目前資料庫中可以存取的DBA的資料表<br>SELECT * FROM DBA_TABLES</p><p>–登入的帳號在目前資料庫中可以存取的所有的資料表<br>SELECT * FROM ALL_TABLES</p><p>–登入的帳號在目前資料庫中可以存取的自己的資料表<br>SELECT * FROM USER_TABLES</p><p><a href="https://evanswa29.pixnet.net/blog/post/67924368-oracle%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%A9%A2%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E9%80%A3%E6%8E%A5%E6%95%B8%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%80%85" target="_blank" rel="noopener">Oracle常用查詢資料庫的連接數以及使用者</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;做個開發常使用的查詢記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Oracle - Sequence (流水號與工作流(JBPM取流水號)的問題)</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210317-java-oracle-sequence.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210317-java-oracle-sequence.html</id>
    <published>2021-03-17T12:20:30.000Z</published>
    <updated>2021-03-17T12:34:08.965Z</updated>
    
    <content type="html"><![CDATA[<p>最近接的案子遇到了不少坑，做個典型的記錄，看到了某功能取工作流的底層排序，排序用”流水號”做排序取號的依據要非常注意。(被坑歪了)</p><a id="more"></a><p>有時候最新的動作會取到較小的號，導致排序流水號排序時，遇流程要回退的問題。<br>解決方法:</p><ol><li>設計時間欄位做排序處理</li><li>不用自動取流水號</li></ol><p><a href="https://cloud.tencent.com/developer/article/1555342" target="_blank" rel="noopener">Oracle sequence 跳号知多少</a><br><a href="https://bbs.csdn.net/topics/390821969" target="_blank" rel="noopener">Oracle sequence 不连续、相差太大问题</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近接的案子遇到了不少坑，做個典型的記錄，看到了某功能取工作流的底層排序，排序用”流水號”做排序取號的依據要非常注意。(被坑歪了)&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Postgres Observability</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210316-postgres-observability.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210316-postgres-observability.html</id>
    <published>2021-03-16T13:50:30.000Z</published>
    <updated>2021-03-16T23:13:48.173Z</updated>
    
    <content type="html"><![CDATA[<p>覺得這網站Postgres整理的不錯，進行留存。</p><p>網站: <a href="https://pgstats.dev/" target="_blank" rel="noopener">《 Postgres Observability》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;覺得這網站Postgres整理的不錯，進行留存。&lt;/p&gt;
&lt;p&gt;網站: &lt;a href=&quot;https://pgstats.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《 Postgres Observability》&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Domain-Driven Design (DDD)</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210217-domain-driven-design.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210217-domain-driven-design.html</id>
    <published>2021-02-17T11:30:30.000Z</published>
    <updated>2021-02-17T13:30:46.688Z</updated>
    
    <content type="html"><![CDATA[<p>閱讀DDD相關文章重點整理。</p><a id="more"></a> <h2 id="Domain-Driven-Design"><a href="#Domain-Driven-Design" class="headerlink" title="Domain-Driven Design"></a>Domain-Driven Design</h2><p>價值: 把將商業領域的知識映照到程式碼中，解放「程式歸程式，業務歸業務」的傳統思維</p><h2 id="模型中有以下概念"><a href="#模型中有以下概念" class="headerlink" title="模型中有以下概念"></a>模型中有以下概念</h2><ul><li>上下文（Context）: 詞或句子出現的位置。</li><li>領域（Domain）: 知識，影響，或活動。客戶使用軟體要處理旳問題種類即為軟體的領域。</li><li>模型（Model）: 一類描述域的不同方面並可用於解決相關問題的系統化的抽象。</li><li>統一術語（Ubiquitous Language）: 一種團隊成員使用，為了描述域模型而構造的語言。 用於如下:<ul><li>User story 或RFC</li><li>任意的會議</li><li>書信往來</li><li>技術文件</li><li>流程或是行程</li><li>程式碼</li></ul></li></ul><h2 id="Building-blocks"><a href="#Building-blocks" class="headerlink" title="Building blocks"></a>Building blocks</h2><p>在領域驅動設計一書中[2]闡述了一些高層次的概念和實踐，比如通用語言，這意味著領域模型應該形成領域專家為描述系統需求而提供的共同語言，同樣的，這些語言也需要能夠被商業使用者或贊助商和軟體開發商使用。本書專注於將領域層描述為具有多層體系結構的物件導向系統中的常見層次之一。在 DDD 中，有表示，建立和檢索域模型的工件：</p><ul><li>Entity: 一個不由自身屬性定義而是由標識線和它的身分定義的物件。<br>例如：大多數航空公司在每次航班上都獨特地區分每個座位。每個席位都是在這種情況下的一個實體。不過，西南航空，EasyJet 和瑞安航空並沒有區分每個座位；所有的座位都是一樣的。在這種情況下，一個席位實際上是一個Value Object</li><li>Value Object: 只包含元素屬性的不可變物件。<br>例如：當人們交換名片時，他們一般不會區分每張獨特的名片；他們只關心印在卡片上的資訊。在這種情況下，名片是 Value Object</li><li>Service: 強調與其他物件的關係，只定義了可以為客戶做什麼，不應該替代 Entity 和 Value Object 的所有行為。</li><li>Module: 一種表達機制，劃分代碼和概念。</li><li>Factory: 對於那些需要建立特定域物件的方法應該委派給工廠物件，因為這樣可以更容易的替換實現。</li><li>Repository: 對於檢索特定域物件的方法應該委派給 Repository 物件，因為這樣可以很容易地互換替代儲存的實現。</li><li>Aggregate: 由 ROOT ENTITY 繫結在一起的物件的集合，也稱為聚合根。聚合根通過禁止外部物件保持對其成員的參照來保證在聚合內進行的更改的一致性。<br>例如：駕駛汽車時，不必擔心向前移動車輪，使發動機燃燒火花和燃料等。你只是在開車。在這種情況下，汽車是其他幾個物件的集合，並作為所有其他系統的聚合根</li><li>Domain Event: 一個域物件定義了一個事件。域事件是域專家所關心的事件。</li></ul><h2 id="貧血模型-Anemic-Model"><a href="#貧血模型-Anemic-Model" class="headerlink" title="貧血模型 (Anemic Model)"></a>貧血模型 (Anemic Model)</h2><p>特徵:<br>其中包含物件，許多物件會以領域空間中的名詞來命名，而且這些物件會透過真實領域模型所具有的豐富關聯性和結構來連接。<br>從行為上會看出端倪，並了解這些物件上幾乎沒有任何行為，比較像是一組 getter 和 setter。<br>使用 Anemic 領域模型時，會從一組擷取所有領域或商務邏輯的服務物件 (service，傳統上稱為「商務層」**) 來使用這些資料模型。 商務層位於資料模型最上層，其使用資料模型的方式就像是資料一樣。</p><p>重點節錄(來自微軟)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Anemic 領域模型只是程序樣式設計。 Anemic 實體物件不是真正的物件，因為它們缺少行為 (方法)。</span><br><span class="line">它們只會保存資料屬性，因此不是物件導向設計。</span><br><span class="line"></span><br><span class="line">藉由將所有的行為放入服務物件（商務層）中，您基本上會得到spaghetti 程式碼或交易腳本，</span><br><span class="line">因此您會失去領域模型所提供的優點。</span><br><span class="line"></span><br><span class="line">即便如此，如果您的微服務或限定內容很簡單 (CRUD 服務)，只有資料屬性之實體物件形式的 Anemic 領域模型便已足夠，</span><br><span class="line">而且可能不值得實作更複雜的 DDD 模式。 在此情況下，它只是持續性模型，因為您刻意建立只有 CRUD 用途資料的實體。</span><br><span class="line"></span><br><span class="line">這就是為什麼微服務架構對於根據每個限定內容之多架構方法很理想的原因。 </span><br><span class="line">例如，在 eShopOnContainers 中，</span><br><span class="line">訂購微服務會實作 DDD 模式，但目錄微服務是簡易 CRUD 服務，因此不會實作此模式。</span><br><span class="line">它其實取決於您實作的內容。 如果您要建立的微服務夠簡單 (例如 CRUD 服務)，遵循 Anemic 領域模型就不是反模式。</span><br><span class="line"></span><br><span class="line"> 不過，如果您需要處理微服務網域的複雜性，</span><br><span class="line"> 而此領域有許多不斷改變的商務規則，則 anemic 領域模型可能是該微服務或限定內容的反模式。</span><br><span class="line"> 在此情況下，將它設計為具有實體的豐富模型可能會相當有利於這類微服務的長期成功，</span><br><span class="line"> 因為這些實體包含資料加上行為，並實作額外的 DDD 模式 (彙總、值物件等)。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20171108161155976?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHJvdWJsZXNob290ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Anemic Model "></p><h2 id="豐富領域模型-Rich-Domain-Model"><a href="#豐富領域模型-Rich-Domain-Model" class="headerlink" title="豐富領域模型(Rich Domain Model)"></a>豐富領域模型(Rich Domain Model)</h2><p><img src="https://img-blog.csdn.net/20171108161246317?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHJvdWJsZXNob290ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Rich Domain Model "></p><p>架構參考:</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/95ed0cc001e94a8ba9f32666113169c9.png" alt="傳統架構 "></p><p>架構轉成DDD</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/d92764a7963f43068273133f9a1ac6f9.png" alt="DDD 之後"></p><h2 id="閱讀參考"><a href="#閱讀參考" class="headerlink" title="閱讀參考"></a>閱讀參考</h2><p>程式架構:<br><a href="https://developer.aliyun.com/article/716908" target="_blank" rel="noopener">阿里技术专家详解 DDD 系列- Domain Primitive</a><br><a href="https://developer.aliyun.com/article/719251" target="_blank" rel="noopener">阿里技术专家详解DDD系列 第二弹 - 应用架构</a><br><a href="https://juejin.cn/post/6845166890554228744" target="_blank" rel="noopener">阿里技术专家详解DDD系列 第三讲 - Repository模式 </a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650414919&idx=1&sn=0ad1df1a1b0e2488f7faa21008fdbdd0&chksm=8396d75fb4e15e49341b07022780dcb8dca66a0efb7f129d4de86a5ef5d8a890f6e0d2fd6432&scene=132#wechat_redirect" target="_blank" rel="noopener">DDD系列第四讲：领域层设计规范 </a></p><p>其他:<br><a href="https://blog.csdn.net/troubleshooter/article/details/78479984" target="_blank" rel="noopener">什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？</a><br><a href="https://blog.csdn.net/johnstrive/article/details/16805121?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control" target="_blank" rel="noopener">领域模型驱动设计（Domain Driven Design）入门概述</a><br><a href="https://blog.csdn.net/iteye_3055/article/details/82106174?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.control" target="_blank" rel="noopener">领域驱动设计(Domain Driven Design)参考架构详解</a><br><a href="https://docs.microsoft.com/zh-tw/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-domain-model" target="_blank" rel="noopener">微服務 - 架構電子書 (微軟) - 設計微服務領域模型</a><br><a href="https://ithelp.ithome.com.tw/articles/10216645" target="_blank" rel="noopener">關於 Domain-Driven Design 以及他的魅力　(這個上面寫的程式範例不太好，看其他文章範例)</a><br><a href="https://medium.com/tradeshift-engineering/my-vision-as-a-software-engineer-about-ddd-domain-driven-design-part-2-973bcf5a9848" target="_blank" rel="noopener">My vision, as a Software Engineer, about DDD (Domain Driven Design) — Part 2 (Java 為範例)</a><br><a href="https://hackmd.io/@ballfish/DDD" target="_blank" rel="noopener">Domain Driven Design</a><br><a href="https://www.cnblogs.com/daoqidelv/p/7648392.html" target="_blank" rel="noopener">【DDD】领域驱动设计实践 —— Domain层实现</a><br><a href="https://t.codebug.vip/questions-2083339.htm" target="_blank" rel="noopener">DDD 程式設計範例討論</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;閱讀DDD相關文章重點整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>資料庫Connection pool設定</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210217-database-connection-pool.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210217-database-connection-pool.html</id>
    <published>2021-02-17T09:30:30.000Z</published>
    <updated>2021-02-17T13:39:03.307Z</updated>
    
    <content type="html"><![CDATA[<p>相關文章重點整理。</p><a id="more"></a> <h2 id="誤區"><a href="#誤區" class="headerlink" title="誤區"></a>誤區</h2><p>資料庫連線池的大小越大越好? Ans: 絕對不是</p><h2 id="正確觀念"><a href="#正確觀念" class="headerlink" title="正確觀念"></a>正確觀念</h2><p>(maximumPoolSize: 連線池中允許的最大連線數) 連線數 = ((核心數 * 2) + 有效磁碟數)</p><h2 id="主要影響資料庫的效能瓶頸因素"><a href="#主要影響資料庫的效能瓶頸因素" class="headerlink" title="主要影響資料庫的效能瓶頸因素"></a>主要影響資料庫的效能瓶頸因素</h2><ul><li>CPU</li><li>磁碟 IO (SSD由於不像傳統硬碟需要定址、旋轉碟片，因此更少的阻塞 ，會更近似於CPU核心數)</li><li>網路 IO </li><li>SQL語法 </li></ul><p><a href="https://www.itread01.com/content/1547137124.html" target="_blank" rel="noopener">資料庫連線池DataSource (解釋連線池為何要使用)</a><br><a href="https://www.mdeditor.tw/pl/2FBd/zh-tw" target="_blank" rel="noopener">如何正確設定資料庫連線池的大小？</a><br><a href="https://www.youtube.com/watch?v=xNDnVOCdvQ0" target="_blank" rel="noopener">OLTP Performance - Concurrent Mid-Tier Connections (Oracle Learning Youtube)</a><br><a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">HikariCP 設定參數 (Github)</a><br><a href="https://www.mdeditor.tw/pl/piUT/zh-tw" target="_blank" rel="noopener">HikariCP 設定參數 (翻譯)</a><br><a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing" target="_blank" rel="noopener">About Pool Sizing - HikariCP (Github)</a><br><a href="https://www.itread01.com/content/1548895884.html" target="_blank" rel="noopener">Springboot datasource 常用配置說明</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;相關文章重點整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>SOA架構 與 Microservice</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210205-microservice-soa.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210205-microservice-soa.html</id>
    <published>2021-02-04T15:07:30.000Z</published>
    <updated>2021-02-04T15:09:56.475Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇到問題查詢的資料，做個整理。</p><a id="more"></a><h2 id="Service-Oriented-Architecture-SOA-服務導向架構"><a href="#Service-Oriented-Architecture-SOA-服務導向架構" class="headerlink" title="Service Oriented Architecture(SOA) 服務導向架構"></a>Service Oriented Architecture(SOA) 服務導向架構</h2><p>特性:</p><ul><li>針對某特定要求的輸出，該服務就是運作一項商業邏輯</li><li>具有完備的特性（self-contained）</li><li>消費者並不需要瞭解此服務的運作過程</li><li>可能由底層其他服務組成</li></ul><p>原則:</p><ul><li>可重複使用、粒度、模組性、可組合型、物件化原件、構件化以及具互動操作性</li><li>符合開放標準（通用的或行業的）</li><li>服務的識別和分類，提供和發布，監控和跟蹤。</li></ul><h2 id="SOA-所解決的核心問題"><a href="#SOA-所解決的核心問題" class="headerlink" title="SOA 所解決的核心問題"></a>SOA 所解決的核心問題</h2><ul><li>系統整合(技術層面)</li><li>系統的服務化(技術層面)</li><li>業務的服務化(是以業務驅動把一個 業務單元封裝成一項服務）</li></ul><p><img src="https://img-blog.csdnimg.cn/20181029125611787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4X0Zyb2xm,size_27,color_FFFFFF,t_70" alt="SOA"></p><h2 id="Microservices-微服務"><a href="#Microservices-微服務" class="headerlink" title="Microservices 微服務"></a>Microservices 微服務</h2><ul><li>通過服務實現元件化</li><li>按業務能力來劃分服務和開發團隊</li><li>去中心化</li><li>基礎設施自動化（devops、自動化部署）<br>與服務導向架構（Service-Oriented Architecture）不同，後者是整合各種業務的應用程式，但微服務只屬於一個應用程式。(強調單一業務組件化)</li></ul><h2 id="Microservices-特性"><a href="#Microservices-特性" class="headerlink" title="Microservices 特性"></a>Microservices 特性</h2><ul><li>每個服務都容易被取代。</li><li>服務是以能力來組織的，例如使用者介面、前端、推薦系統、帳單或是物流等。</li><li>由於功能被拆成多個服務，因此可以由不同的程式語言、資料庫實作。</li><li>架構是對稱而非分層（即生產者與消費者的關係）</li></ul><p><img src="http://www.45fan.com/uploads/allimg/190414/03110Jc9-1.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTI1MzAw,size_16,color_FFFFFF,t_70" alt="Microservices"></p><h2 id="Microservices-資料庫三種設計模式"><a href="#Microservices-資料庫三種設計模式" class="headerlink" title="Microservices 資料庫三種設計模式"></a>Microservices 資料庫三種設計模式</h2><ol><li>每個服務都各有一個數據庫，同屬性的服務可共享同個資料庫。</li><li>所有服務都共享同個資料庫，但是不同表格，並且不會跨域存取。</li><li>每個服務都有自己的資料庫，就算是同屬性的也是，資料庫並不會共</li></ol><p>資料庫的可棄性:<br>實踐微服務架構中有許多的做法。但是其中一種的做法是將資料庫視作短期的儲存空間而不是長期的資料。因為他們可以在上線時從事件中心回覆，因此可以快速的從記憶體中快速存取（例：Redis）作為資料庫伺服器。這種做法需要將每個請求當作事件來進行廣播，這樣就可以從事件儲存中心重播所有的事件。</p><p>在微服務中，則通過 API 調用來完成。這些模塊或者服務間調用，大部分時候是為了共享數據。<br>共享數據最賤的方式當然就是採用一種共享資料庫的模式，也就是單體應用常用的方式。應用可以有多個系統模塊，但一般都是只有一個資料庫。</p><p><img src="https://twgreatdaily.com/images/elastic/SnG/SnG8WHMBiuFnsJQVaRyz.jpg" alt="一庫一服  vs 一庫多服"></p><p>一庫多服，這種架構模式通常會被認為是 微服務架構下的反範式，它的問題在於:</p><ul><li>單點故障：一個資料庫倒下，整批服務全部停止。何來的服務獨立性？</li><li>數據在同一個地方，會給貪圖方便的開發或者 DBA 工程師編寫很多數據間高度依賴的程序或者工具。</li><li>無法針對某一個服務進行精準優化或擴展。<br>所以一般推薦的做法，是為每一個微服務準備一個單獨的資料庫，也即一庫一服(Database per Service)模式。這種模式更加適合微服務架構，它滿足每一個服務是獨立開發、獨立部署、獨立擴展的特性。需要對一個服務進行升級或者數據架構改動的時候，不會影響到其他的服務。需要對某個服務進行擴展的時候，也可以手術式的對某一個服務進行局部擴容。</li></ul><h2 id="微服務的切割"><a href="#微服務的切割" class="headerlink" title="微服務的切割"></a>微服務的切割</h2><ol><li>domain-driven design (DDD) 領域驅動設計</li></ol><ul><li>Infrastructure（基礎實施層）</li><li>Domain（領域層）</li><li>Application（應用層）</li><li>Interfaces（表示層，也叫用戶界面層或是接口層）</li></ul><p><img src="https://res.cloudinary.com/dgzowpeqr/image/upload/v1562839291/levp4f9usxwzlrlk1dou.jpg" alt="domain-driven design(DDD)"></p><ol start="2"><li>資料結構</li></ol><h2 id="微服務的利和弊"><a href="#微服務的利和弊" class="headerlink" title="微服務的利和弊"></a>微服務的利和弊</h2><p><img src="https://res.cloudinary.com/dgzowpeqr/image/upload/v1562839370/wgkwtaplr4keahh9ojsa.jpg" alt="Microservices 利與弊"></p><ul><li>利: 單一服務組件化、可獨立部署、技術多樣性</li><li>弊: 分佈式的系統複雜性(各別服務的溝通複雜化)、最終一致性、運維複雜性</li></ul><h2 id="微服務-設計模式"><a href="#微服務-設計模式" class="headerlink" title="微服務(設計模式)"></a>微服務(設計模式)</h2><p><img src="https://codertw.com/wp-content/uploads/img/15JGg8G9K0.jpg" alt="鏈式設計模式"></p><p><img src="https://codertw.com/wp-content/uploads/img/IEq6ZUD3Og.jpg" alt="聚合器設計模式"></p><p><img src="https://i.iter01.com/images/a65374eb32d49af469d0f73fa247e018af4ad67156d77ca20232556c48804cb6.png" alt="代理設計模式"></p><p><img src="https://i.iter01.com/images/a6d2c4c0b8e7cde26918b623c0fdd67f0603e723d1090c6197711638a0a8b3f7.png" alt="分支設計模式"></p><p><img src="https://codertw.com/wp-content/uploads/img/2hmI3o1N3Y.jpg" alt="資料庫共享模式"></p><p><img src="https://codertw.com/wp-content/uploads/img/M2dJFZmv5O.jpg" alt="異部消息設計模式"></p><h2 id="Service-Oriented-Architecture-與-Microservice-差別"><a href="#Service-Oriented-Architecture-與-Microservice-差別" class="headerlink" title="Service Oriented Architecture 與 Microservice 差別"></a>Service Oriented Architecture 與 Microservice 差別</h2><ul><li>微服務不再強調傳統SOA架構裡面比較重的ESB(企業服務匯流排)，進入到單個業務系統內部實現真正的元件化。</li><li>SOA注重的是系統整合方面，而微服務關注的是組件服務完全分離 。<br>more info:<a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener">Microservices wiki 英文</a><br>more info:<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99" target="_blank" rel="noopener">微服務(Microservices) wiki</a><br>more info:<a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/735003/" target="_blank" rel="noopener">微服務(Microservices) 設計模式</a><br>more info:<a href="https://iter01.com/513031.html" target="_blank" rel="noopener">架構設計思想-微服務架構設計模式</a><br>more info:<a href="https://twgreatdaily.com/I_S-V3MBfGB4SiUw1uN0.html" target="_blank" rel="noopener">如何在微服務架構下進行數據設計？</a><br>more info:<a href="https://www.cnblogs.com/takumicx/p/10021538.html" target="_blank" rel="noopener">微服務-柔性事务</a><br>more info:<a href="https://www.itread01.com/content/1542762129.html" target="_blank" rel="noopener">微服務-DB規劃</a><br>more info:<a href="https://morosedog.gitlab.io/technology-20200304-tech-10/" target="_blank" rel="noopener">技術觀念 | 淺談分散式系統 - 微服務淺談</a><br>more info:<a href="https://blog.csdn.net/xybelieve1990/article/details/84958671" target="_blank" rel="noopener">关于分布式事务BASE模型和柔性事务TCC</a><br>more info:<a href="https://www.itread01.com/content/1542394146.html" target="_blank" rel="noopener">SOA架構和微服務架構的比較</a><br>more info:<a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/588191/" target="_blank" rel="noopener">架構師必看：微服務架構綜述</a><br>more info:<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">SOA Wiki</a><br>more info:<a href="https://www.ipshop.xyz/16625.html" target="_blank" rel="noopener">我只是下了個訂單，鬼知道我在微服務里經歷了什麼？ (DDD 領域驅動設計-微服務切割-訂單設計)</a><br>more info:<a href="https://kknews.cc/zh-tw/news/p95rx6e.html" target="_blank" rel="noopener">老司機避坑指南：如何快速搞定微服務架構？</a><br>more info:<a href="https://www.martinfowler.com/articles/microservices.html#HowBigIsAMicroservice" target="_blank" rel="noopener">martinfowler blog原文</a><br>more info:<a href="https://dzone.com/articles/6-data-management-patterns-for-microservices-1" target="_blank" rel="noopener">6 Data Management Patterns for Microservices</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前遇到問題查詢的資料，做個整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>MVC模式 與 三層架構</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210202-mvc-tier.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210202-mvc-tier.html</id>
    <published>2021-02-02T12:07:30.000Z</published>
    <updated>2021-02-04T16:06:10.337Z</updated>
    
    <content type="html"><![CDATA[<p>MVC與三層架構解釋整理。</p><a id="more"></a><h2 id="MVC模式（Model–view–controller）"><a href="#MVC模式（Model–view–controller）" class="headerlink" title="MVC模式（Model–view–controller）"></a>MVC模式（Model–view–controller）</h2><p>是軟體工程中的一種軟體架構模式，把軟體系統分為三個基本部分：</p><ul><li>模型（Model): 用於封裝與應用程式的業務邏輯相關的資料以及對資料的處理方法。「 Model 」有對資料直接存取的權力，例如對資料庫的存取。<ul><li>「Model」不依賴「View」和「Controller」，也就是說， Model 不關心它會被如何顯示或是如何被操作。</li><li>但是 Model 中資料的變化一般會通過一種重新整理機制被公布。為了實現這種機制，那些用於監視此 Model 的 View 必須事先在此 Model 上註冊，從而，View 可以了解在資料 Model 上發生的改變。（比如：觀察者模式（軟體設計模式））</li></ul></li><li>視圖（View）:能夠實現資料有目的的顯示（理論上，這不是必需的）。在 View 中一般沒有程式上的邏輯。為了實現 View 上的重新整理功能，View 需要存取它監視的資料模型（Model），因此應該事先在被它監視的資料那裡註冊。 </li><li>控制器（Controller）: 起到不同層面間的組織作用，用於控制應用程式的流程。它處理事件並作出回應。「事件」包括使用者的行為和資料 Model 上的改變。</li></ul><p>MVC模式在概念上強調 Model, View, Controller 的分離，各個模組也遵循著由 Controller 來處理訊息，Model 掌管資料來源，View 負責資料顯示的職責分離原則，因此在實作上，MVC 模式的 Framework 通常會將 MVC 三個部份分離實作：</p><ul><li>Model 負責資料存取，較現代的 Framework 都會建議使用獨立的資料物件 (DTO, POCO, POJO 等) 來替代弱型別的集合物件。資料存取的程式碼會使用 Data Access 的程式碼或是 ORM-based Framework，也可以進一步使用 Repository Pattern 與 Unit of Works Pattern 來切割資料來源的相依性。</li><li>Controller 負責處理訊息，較高階的 Framework 會有一個預設的實作來作為 Controller 的基礎，例如 Spring 的 DispatcherServlet 或是 ASP.NET MVC 的 Controller 等，在職責分離原則的基礎上，每個 Controller 負責的部份不同，因此會將各個 Controller 切割成不同的檔案以利維護。</li><li>View 負責顯示資料，這個部份多為前端應用，而 Controller 會有一個機制將處理的結果 (可能是 Model, 集合或是狀態等) 交給 View，然後由 View 來決定怎麼顯示。例如 Spring Framework 使用 JSP 或相應技術，ASP.NET MVC 則使用 Razor 處理資料的顯示。</li></ul><h2 id="三層架構-3-tier-architecture"><a href="#三層架構-3-tier-architecture" class="headerlink" title="三層架構(3-tier architecture)"></a>三層架構(3-tier architecture)</h2><p>是一種軟體抽象的層次結構，從”整個應用程式架構的角度”來區分為三層。 </p><p>目的: 高內聚，低耦合的思想<br>優點: </p><ul><li>利於標準化</li><li>降低層與層之間的依賴</li><li>利於各層邏輯的復用，資源重用性好</li><li>開發人員可以只關注整個結構中的其中某一層</li><li>具有良好的開放性和可擴充性，維護和升級方便</li><li>提高系統的安全性</li></ul><p>缺點: </p><ul><li>有時會導致連動的修改。</li><li>如果在表現層中需要增加一個功能，為保證其設計符合分層式結構，可能需要在相應的商業邏輯層和資料存取層中都增加相應的程式碼。</li><li>相對於不分層，降低了系統的性能。</li><li>如果不採用分層式結構，很多業務可以直接造訪資料庫，以此獲取相應的數據，如今卻必須通過中間層來完成。</li><li>增加了開發成本。</li></ul><p>分層:</p><ul><li>表現層（Presentation layer）：通俗講就是展現給使用者的介面，即使用者在使用一個系統的時候他的所見所得。</li><li>業務邏輯層（Business Logic Layer）：針對具體問題的操作，也可以說是對資料層的操作，對資料業務邏輯處理。</li><li>資料訪問層（Data Access Layer）：該層所做事務直接運算元據庫，針對資料的增添、移除、修改、查找等。</li></ul><p><img src="https://www.itsfun.com.tw/cacheimg/d7/ce/3cf976ce330db425f6eb1a22d824.jpg" alt="3-tier architecture"></p><p><img src="https://qph.fs.quoracdn.net/main-qimg-91d0a36c056cce85cd3a941a730ef053" alt="3-tier architecture-en"></p><h2 id="兩者的差異"><a href="#兩者的差異" class="headerlink" title="兩者的差異"></a>兩者的差異</h2><ul><li>三層架構是一個分層式的軟件體系架構設計。 MVC是一個設計模式，它是根據項目的具體需求來決定是否適用於該項目。</li><li>三層架構的目的著重點是”高內聚，低耦合”，即解耦。 MVC的目的則是實現Web系統的職能分工，即職責劃分。</li><li>三層側重的是整體的一個解耦。 MVC側重的是web系統的解耦，即側重jsp和Servlet的一個解耦。</li><li>三層架構的分層模式是典型的上下關系，上層依賴於下層。 MVC作為表現模式是不存在上下關系的，而是相互協作關系。</li></ul><p>more info:<a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC Wiki</a><br>more info:<a href="https://shunnien.github.io/2017/07/29/3-tier-and-mvc-introduction/" target="_blank" rel="noopener">三層結構與 Asp.Net MVC 的簡介 Wiki</a><br>more info:<a href="https://www.itread01.com/content/1514351052.html" target="_blank" rel="noopener">三層架構與MVC的區別</a><br>more info:<a href="https://www.itread01.com/content/1514351052.html" target="_blank" rel="noopener">三層架構與MVC的區別</a><br>more info:[softwareengineering討論區]<a href="https://softwareengineering.stackexchange.com/questions/299836/difference-between-3-tier-architecture-and-mvc-model-view-controller-in-asp-n" target="_blank" rel="noopener">https://softwareengineering.stackexchange.com/questions/299836/difference-between-3-tier-architecture-and-mvc-model-view-controller-in-asp-n</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MVC與三層架構解釋整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Spring註解 @Component @Service, @Controller, @Repository</title>
    <link href="https://hand79.github.io/Blog/posts/Java/20210201-spring-annotation-component.html"/>
    <id>https://hand79.github.io/Blog/posts/Java/20210201-spring-annotation-component.html</id>
    <published>2021-02-01T14:47:33.000Z</published>
    <updated>2021-02-04T13:51:20.482Z</updated>
    
    <content type="html"><![CDATA[<p>以前留下整理的資料的記錄。</p><a id="more"></a><h2 id="spring註解"><a href="#spring註解" class="headerlink" title="spring註解"></a>spring註解</h2><p>@Component, @Service, @Controller, @Repository是spring註解，註解後可以被spring框架所掃描並註入到spring容器來進行管理</p><ul><li>@Component是通用註解，其他三個註解是這個註解的拓展，並且具有了特定的功能(generic stereotype for any Spring-managed component)。</li><li>@Repository註解在持久層中，具有將數據庫操作拋出的原生異常翻譯轉化為spring的持久層異常的功能。(stereotype for persistence layer)</li><li>@Controller層是spring-mvc的註解，具有將請求進行轉發，重定向的功能。(stereotype for presentation layer)</li><li>@Service層是業務邏輯層註解，這個註解只是標註該類處於業務邏輯層。 (stereotype for service layer)<br>用這些註解對應用進行分層之後，就能將請求處理，義務邏輯處理，數據庫操作處理分離出來，為代碼解耦，也方便了以後項目的維護和開發。</li></ul><p>註解:<br>Spring2.0時提供的: @Repository(在Spring2.5有修改部分內容)<br>Spring2.5時提供的: @Component, @Controller, @Service</p><p>more info:<a href="https://stackoverflow.com/posts/6897038/edit" target="_blank" rel="noopener">stackoverflow 參考</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html" target="_blank" rel="noopener">@Repository doc</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html" target="_blank" rel="noopener">@Component doc</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html" target="_blank" rel="noopener">@Controller doc</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html" target="_blank" rel="noopener">@Service doc</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前留下整理的資料的記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://hand79.github.io/Blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://hand79.github.io/Blog/tags/Java/"/>
    
    <category term="Spring" scheme="https://hand79.github.io/Blog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>悲觀鎖與樂觀鎖(資料庫交易)</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210201-locking-pessimistic-optimistic.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210201-locking-pessimistic-optimistic.html</id>
    <published>2021-02-01T11:47:30.000Z</published>
    <updated>2021-02-04T10:54:54.350Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇上的問題，劃個重點留個整理記錄。</p><a id="more"></a><p>資料庫交易特性ACID中的交易隔離(Isolation)通常利用「鎖(locking)」來實現，目的為避免同一筆資料在併行交易(concurrent transaction)中被不同的交易同時修改以確保資料的完整性。<br>交易鎖又分為「悲觀鎖(pessimistic locking)」與「樂觀鎖(optimistic locking)」。</p><p>常用鎖處理的例子: 電商商品庫存、銀行轉帳業務</p><p>##悲觀鎖(Pessimistic Locking)<br>時機: 悲觀並行控制主要用於資料爭用激烈的環境或發生並發衝突時，”使用鎖保護資料的成本”要低於”回復交易的成本”的環境中。</p><ul><li>悲觀並行控制實際上是「先取鎖再訪問」的保守策略，為資料處理的安全提供了保證。</li><li>在效率方面，處理加鎖的機制會讓資料庫產生額外的開銷，還有增加產生”死鎖”的機會</li><li>在只讀型交易處理中由於不會產生衝突，就沒必要使用鎖，這樣做只能增加系統負載，還有會降低了並行性。</li><li>一個交易如果鎖定了某行資料，其他交易就必須等待該交易處理完才可以處理那行資料。(當下資料有對其他執行存取有排他性)<br>典型的使用: synchronized (java)</li></ul><p>##樂觀鎖(Optimistic Locking)<br>時機: 樂觀並行控制多數用於”資料爭用不大”、”衝突較少的環境”中，”偶爾回復交易的成本”會低於”讀取資料時鎖定資料的成本”，因此可以獲得”比其他並行控制方法更高的吞吐量”。</p><ul><li>假設”多使用者並行的交易在處理時不會彼此互相影響”，”各交易能夠在不產生鎖”的情況下”處理各自影響的那部分資料”。在提交資料更新之前，每個交易會”先檢查在該交易讀取資料後，有沒有其他交易又修改了該資料”。如果其他交易有更新的話，正在提交的交易會進行rollback。</li></ul><p>缺點: 樂觀並行控制相信交易之間的資料競爭(data race)的概率是比較小的，因此儘可能直接做下去，直到提交的時候才去鎖定，所以不會產生任何鎖和死結。但如果直接簡單這麽做，還是有可能會遇到不可預期的結果，例如兩個交易都讀取了資料庫的某一行，經過修改以後寫回資料庫，這時就遇到了問題。(ABA问题) </p><ul><li>需要添加重試機制，舉個例子: 資料異動時衝突(JPA中的@version)，重新在執行失敗的動作</li></ul><h4 id="樂觀並行控制的交易包括以下階段："><a href="#樂觀並行控制的交易包括以下階段：" class="headerlink" title="樂觀並行控制的交易包括以下階段："></a>樂觀並行控制的交易包括以下階段：</h4><ul><li>讀取：交易將資料讀入快取，這時系統會給交易分派一個時間戳。</li><li>校驗：交易執行完畢後，進行提交。這時同步校驗所有交易，如果交易所讀取的資料在讀取之後又被其他交易修改，則產生衝突，交易被中斷回復。</li><li>寫入：通過校驗階段後，將更新的資料寫入資料庫。<br>典型的使用: Compare and Swap (CAS)、 AtomicReference class、 @Version(Java JPA中的@version 版本控制處理方式)</li></ul><p>##總結<br>樂觀鎖適用於讀大於寫、衝突少的的場景(省去了鎖的開銷，加大了系統的整個吞吐量。如果經常產生衝突，上層應用會不斷的進行retry可能須考慮是否用悲觀鎖)<br>悲觀鎖寫大於讀、衝突大的的場景(併發量不大且不允許髒讀適合)</p><p>more info:<a href="https://www.cnblogs.com/kismetv/p/10787228.html" target="_blank" rel="noopener">資料參考</a><br>more info:<a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank" rel="noopener">Optimistic Concurrency wiki</a><br>more info:<a href="https://zh.wikipedia.org/wiki/%E6%82%B2%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">Pessimistic Concurrency wiki</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前遇上的問題，劃個重點留個整理記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
</feed>
