<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Max&#39;s Blog-程式學習研究記錄</title>
  <icon>https://www.gravatar.com/avatar/d4fa779638e91d085afca3ea034b7703</icon>
  <subtitle>求生是激發人的成長與潛能</subtitle>
  <link href="https://hand79.github.io/Blog/atom.xml" rel="self"/>
  
  <link href="https://hand79.github.io/Blog/"/>
  <updated>2021-09-26T14:10:38.942Z</updated>
  <id>https://hand79.github.io/Blog/</id>
  
  <author>
    <name>MaxHanChen</name>
    <email>maxdjkl@gmail.com</email>
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Java 8 to 17 各版本功能變化</title>
    <link href="https://hand79.github.io/Blog/posts/Java/20210926-java-feature-version-history.html"/>
    <id>https://hand79.github.io/Blog/posts/Java/20210926-java-feature-version-history.html</id>
    <published>2021-09-26T12:47:33.000Z</published>
    <updated>2021-09-26T14:10:38.942Z</updated>
    
    <content type="html"><![CDATA[<p>有鑑於國外Java更新已經到那麼遠了，整理一些資訊留存，以便後續追蹤新版本功能特色的資料。</p><p>more info:<a href="https://advancedweb.hu/a-categorized-list-of-all-java-and-jvm-features-since-jdk-8-to-17/" target="_blank" rel="noopener">A categorized list of all Java and JVM features since JDK 8 to 17</a><br>more info:<a href="https://openjdk.java.net/projects/jdk/" target="_blank" rel="noopener">JDK Project(openjdk官網)</a><br>more info:<a href="https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/new-features/java%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93.md" target="_blank" rel="noopener">java新特性总结.md</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;有鑑於國外Java更新已經到那麼遠了，整理一些資訊留存，以便後續追蹤新版本功能特色的資料。&lt;/p&gt;
&lt;p&gt;more info:&lt;a href=&quot;https://advancedweb.hu/a-categorized-list-of-all-java-and-jvm-fea</summary>
      
    
    
    
    <category term="Java" scheme="https://hand79.github.io/Blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://hand79.github.io/Blog/tags/Java/"/>
    
  </entry>
  
  <entry>
    <title>專案遇上Win10 MAC Address權限設定問題與網路密碼更新的問題</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210815-project-issue-0001.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210815-project-issue-0001.html</id>
    <published>2021-08-15T14:47:30.000Z</published>
    <updated>2021-08-15T15:04:48.333Z</updated>
    
    <content type="html"><![CDATA[<p>專案遇上Win10 MAC Address權限設定問題與網路密碼更新的問題</p><a id="more"></a><h1 id="MAC-Address-相關"><a href="#MAC-Address-相關" class="headerlink" title="MAC Address 相關"></a>MAC Address 相關</h1><h3 id="Win10"><a href="#Win10" class="headerlink" title="Win10"></a>Win10</h3><ul><li>MAC Address 查詢方法， <a href="https://www.kocpc.com.tw/archives/310582" target="_blank" rel="noopener">如何在 Windows 10 上查找 MAC 位址（實體位址）？ 5 個方法一次教給你</a></li><li>Win10 新增的功能(<a href="https://support.microsoft.com/zh-tw/windows/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%A8%E6%A9%9F%E7%A1%AC%E9%AB%94%E4%BD%8D%E5%9D%80-ac58de34-35fc-31ff-c650-823fc48eb1bc" target="_blank" rel="noopener">隨機硬體位址</a>)<h3 id="Android-MAC-Address-隨機位址的發展歷程"><a href="#Android-MAC-Address-隨機位址的發展歷程" class="headerlink" title="Android - MAC Address 隨機位址的發展歷程"></a>Android - MAC Address 隨機位址的發展歷程</h3></li><li>從 Android 8.0 開始，Android 設備在未連接到網絡的情況下探測新網絡時，會使用隨機分配的 MAC 地址。</li><li>在 Android 9 中，您可以啟用一個開發者選項（默認處於停用狀態），使設備在連接到 WLAN 網絡時使用隨機分配的 MAC 地址。</li><li>在 Android 10 中，默認為客戶端模式、SoftAp 和 WLAN 直連啟用隨機分配 MAC 地址功能。 隨機分配 MAC 地址可防止監聽器使用 MAC 地址來生成設備活動的歷史記錄，從而加強對用戶隱私的保護。 此外，在 Wi-Fi 感知和 Wi-Fi RTT 操作中也會使用隨機分配的 MAC 地址。</li></ul><p>因此需要固定MAC 請記得 WIN10把隨機硬體位址的功能關掉，Andriod 則參考 <a href="(https://support.hdeone.com/hc/zh-tw/articles/360000647761">在Android 10的智慧手機上安裝登錄憑證</a>該文處理即可</p><p>#網域密碼原則查詢 (win cmd 常用指令)<br>當不知道為何不能更新的密碼的時候，可以更明確的跟當地網管敘述問題何在。</p><ul><li>net accounts /domain </li><li>net user 帳號 /domain 指令即可得知每個使用者密碼原則<br><a href="http://xmrongta.com/EFNET/src/_Common/AppUtil/Help/Program/pwdchange.pdf" target="_blank" rel="noopener">網域密碼變更處理原則</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;專案遇上Win10 MAC Address權限設定問題與網路密碼更新的問題&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Oracle - Automatic Workload Repository (AWR) Report</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210405-oracle-awr-report.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210405-oracle-awr-report.html</id>
    <published>2021-04-05T12:20:30.000Z</published>
    <updated>2021-04-05T14:02:35.682Z</updated>
    
    <content type="html"><![CDATA[<p>最近被抓來看效能問題，做點查詢相關資料記錄。</p><a id="more"></a><p><a href="https://iter01.com/266908.html" target="_blank" rel="noopener">Oracle AWR報告指標全解析</a><br><a href="https://oracle-base.com/articles/10g/automatic-workload-repository-10g" target="_blank" rel="noopener">Automatic Workload Repository (AWR) in Oracle Database 10g - oracle-base </a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近被抓來看效能問題，做點查詢相關資料記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Oracle - Select指定傳回筆數</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210404-oracle-sql-select-rownum.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210404-oracle-sql-select-rownum.html</id>
    <published>2021-04-04T12:20:30.000Z</published>
    <updated>2021-04-05T13:41:21.914Z</updated>
    
    <content type="html"><![CDATA[<p>由於Oracle不支持Select Top語句，所以在Oracle中經常是用Order By跟rownum的組合來實現Select Top N的查詢，<br>也跟PostgreSQL下的方法不一樣，不是用limit限制資料筆數，因此做記錄。</p><p>OS: 整理完後我開始懷念PostgreSQL語法的簡潔…</p><a id="more"></a><p>Oracle中 Select指令沒有類似LIMIT的參數可以使用來限制傳回資料的筆數，但是可以利用 ORACLE中的Rownum的值作一點手腳來限制傳回值的範圍。</p><h4 id="ROWNUM-說明："><a href="#ROWNUM-說明：" class="headerlink" title="ROWNUM 說明："></a>ROWNUM 說明：</h4><ul><li>rownum不能以任何表的名稱作為前綴字。</li><li>Oracle 使用 rownum 作為查詢結果行的編號，第一行是1，第二行是2， 以此類推，可以用於限制查詢返回的總行數。</li><li>rownum的值在”查詢結果輸出時自動產生”，因此第一條始終是1。</li><li>Oracle中的rownum的是在查找資料的時候產生的序號，所以想對指定排序的數據去指定的rowmun行數據就必須注意了。</li><li>要注意的是在使用rownum時，只有當Order By 的字段是主鍵或索引時，查詢結果才會先排序再計算rownum,但是，對非主鍵欄位進行排序時卻不是。<br>出現這種的原因是：Oracle 先按物理存儲位置（rowid）順序取出滿足rownum 條件的記錄，即物理位置上的前5條數據，然後在對這些數據按照Order By 的字段進行排序，而不是我們所期望的先排序、再取特定記錄數。(因此排序的欄位建議是有索引的欄位)</li><li>若無索引或主鍵，只能用子查詢來實現先排序。(注意查詢效能的問題)</li></ul><p>1、ROWNUM 是偽列，必須要有返回結果後，每條返回記錄就會對應產生一個ROWNUM數值；<br>2、返回結果記錄的ROWNUM 是從1 開始排序的，因此第一條始終是1;這樣，當查詢到第一條記錄時，該記錄的ROWNUM 為1，但條件要求ROWNUM&gt;1，因此不符合，繼續查詢下一條；因為前面沒有符合要求的記錄，因此下一條記錄過來後，其ROWNUM 還是為1，如此循環，就不會產生結果。</p><h4 id="分頁顯示實作"><a href="#分頁顯示實作" class="headerlink" title="分頁顯示實作:"></a>分頁顯示實作:</h4><p>通用的作法:<br>select * from (子查詢) WHERE rownum Between 初始列  AND 尾列;</p><p>Tips:</p><ul><li>很多開發者在確認某個表中是否有相應數據時，喜歡加上ROWNUM=1，其想法就是只要存在一條數據就說明有相應數據，查詢就可以直接返回了，這樣就能提高性能了。<br>但是在Oracle 10G之前，使用rownum=1 是不能達到預期的性能效果的，而是需要通過&lt;2 或&lt;=1 作為過濾條件才能達到預期效果。</li></ul><p><a href="https://blog.csdn.net/zxh2075/article/details/77110736" target="_blank" rel="noopener">Oracle rownum 用法詳解</a><br><a href="https://blog.csdn.net/bbliutao/article/details/8531091" target="_blank" rel="noopener">Oracle rownum 注意事項</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;由於Oracle不支持Select Top語句，所以在Oracle中經常是用Order By跟rownum的組合來實現Select Top N的查詢，&lt;br&gt;也跟PostgreSQL下的方法不一樣，不是用limit限制資料筆數，因此做記錄。&lt;/p&gt;
&lt;p&gt;OS: 整理完後我開始懷念PostgreSQL語法的簡潔…&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Oracle - 開發常用查詢語法</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210403-oracle-daily-sql.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210403-oracle-daily-sql.html</id>
    <published>2021-04-03T12:20:30.000Z</published>
    <updated>2021-04-05T14:22:55.662Z</updated>
    
    <content type="html"><![CDATA[<p>做個開發常使用的查詢記錄。</p><a id="more"></a><p>– 查詢版本<br>SELECT * FROM v$version;<br>SELECT * FROM product_component_version;</p><p>– 目前資料庫的語系<br>SELECT * FROM nls_database_parameters WHERE parameter = ‘NLS_CHARACTERSET’;</p><p>– 查詢目前資料庫名稱<br>SELECT NAME FROM v$database;</p><p>– 查詢session連線數<br>select count(*) from v$session；</p><p>–當前的連接數<br>select count(*) from v$process</p><p>– 查看不同使用者的連接數<br>select username,count(username) from v$session where username is not null group by username;</p><p>– 查詢oracle的併發連接數<br>select count(*) from v$session where status=’ACTIVE’;</p><p>– 資料庫允許的最大連接數<br>select value from v$parameter where name = ‘processes’ </p><p>– 修改最大連接數:<br>alter system set processes = 300 scope = spfile;</p><p>– 重啟資料庫:<br>shutdown immediate;<br>startup;</p><p>–查看當前有哪些使用者正在使用資料<br>SELECT osuser, a.username,cpu_time/executions/1000000||’s’, sql_fulltext,machine<br>from v$session a, v$sqlarea b<br>where a.sql_address =b.address order by cpu_time/executions desc;</p><p>– 按機器名分組查<br>select username,machine,count(username) from v$session where username is not null group by username,machine;</p><p>– 查看使用者或角色系統許可權(直接賦值給使用者或角色的系統許可權)：<br>select * from dba_sys_privs;<br>select * from user_sys_privs;</p><p>– 查看角色(只能查看登陸使用者擁有的角色)所包含的許可權<br>select * from role_sys_privs;</p><p>– 查看所有角色：<br>select * from dba_roles;</p><p>– 查看所有使用者<br>select * from all_users;</p><p>– 查看使用者或角色所擁有的角色：<br>select * from dba_role_privs;<br>select * from user_role_privs;</p><p>– 查看使用者物件使用權限：<br>select * from dba_tab_privs;<br>select * from all_tab_privs;<br>select * from user_tab_privs;</p><p>– 查看哪些使用者有sysdba或sysoper系統許可權(查詢時需要相應許可權)<br>select * from V$PWFILE_USERS; </p><p>– 查詢所有 Table<br>SELECT * FROM USER_OBJECTS;<br>SELECT * FROM USER_OBJECTS ORDER BY OBJECT_NAME;</p><p>– 查詢所有 Table &amp; 欄位<br>SELECT * FROM user_tab_columns ORDER BY TABLE_NAME;<br>SELECT * FROM user_tab_columns WHERE table_name = UPPER(‘表格名稱’) ORDER BY TABLE_NAME;</p><p>– 取得 TABLE 的欄位<br>desc UPPER(‘表格名稱’);</p><p>– 取得 Table 註解<br>SELECT table_name, comments<br>FROM sys.user_tab_comments<br>WHERE table_type =’TABLE’<br>AND comments IS NOT NULL;</p><p>SELECT table_name, comments FROM sys.user_tab_comments WHERE table_name = UPPER(‘表格名稱’);</p><p>– 取得 Column 註解<br>SELECT table_name, column_name, comments FROM sys.user_col_comments<br>WHERE comments IS NOT NULL;</p><p>SELECT table_name, column_name, comments FROM sys.user_col_comments WHERE table_name = UPPER(‘表格名稱’);</p><p>–登入的帳號在目前資料庫中可以存取的DBA的資料表<br>SELECT * FROM DBA_TABLES</p><p>–登入的帳號在目前資料庫中可以存取的所有的資料表<br>SELECT * FROM ALL_TABLES</p><p>–登入的帳號在目前資料庫中可以存取的自己的資料表<br>SELECT * FROM USER_TABLES</p><p><a href="https://evanswa29.pixnet.net/blog/post/67924368-oracle%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%A9%A2%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E9%80%A3%E6%8E%A5%E6%95%B8%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%80%85" target="_blank" rel="noopener">Oracle常用查詢資料庫的連接數以及使用者</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;做個開發常使用的查詢記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Oracle - Sequence (流水號與工作流(JBPM取流水號)的問題)</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210317-java-oracle-sequence.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210317-java-oracle-sequence.html</id>
    <published>2021-03-17T12:20:30.000Z</published>
    <updated>2021-03-17T12:34:08.965Z</updated>
    
    <content type="html"><![CDATA[<p>最近接的案子遇到了不少坑，做個典型的記錄，看到了某功能取工作流的底層排序，排序用”流水號”做排序取號的依據要非常注意。(被坑歪了)</p><a id="more"></a><p>有時候最新的動作會取到較小的號，導致排序流水號排序時，遇流程要回退的問題。<br>解決方法:</p><ol><li>設計時間欄位做排序處理</li><li>不用自動取流水號</li></ol><p><a href="https://cloud.tencent.com/developer/article/1555342" target="_blank" rel="noopener">Oracle sequence 跳号知多少</a><br><a href="https://bbs.csdn.net/topics/390821969" target="_blank" rel="noopener">Oracle sequence 不连续、相差太大问题</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;最近接的案子遇到了不少坑，做個典型的記錄，看到了某功能取工作流的底層排序，排序用”流水號”做排序取號的依據要非常注意。(被坑歪了)&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Postgres Observability</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210316-postgres-observability.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210316-postgres-observability.html</id>
    <published>2021-03-16T13:50:30.000Z</published>
    <updated>2021-03-16T23:13:48.173Z</updated>
    
    <content type="html"><![CDATA[<p>覺得這網站Postgres整理的不錯，進行留存。</p><p>網站: <a href="https://pgstats.dev/" target="_blank" rel="noopener">《 Postgres Observability》</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;覺得這網站Postgres整理的不錯，進行留存。&lt;/p&gt;
&lt;p&gt;網站: &lt;a href=&quot;https://pgstats.dev/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;《 Postgres Observability》&lt;/a&gt;&lt;/p&gt;
</summary>
      
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Domain-Driven Design (DDD)</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210217-domain-driven-design.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210217-domain-driven-design.html</id>
    <published>2021-02-17T11:30:30.000Z</published>
    <updated>2021-02-17T13:30:46.688Z</updated>
    
    <content type="html"><![CDATA[<p>閱讀DDD相關文章重點整理。</p><a id="more"></a> <h2 id="Domain-Driven-Design"><a href="#Domain-Driven-Design" class="headerlink" title="Domain-Driven Design"></a>Domain-Driven Design</h2><p>價值: 把將商業領域的知識映照到程式碼中，解放「程式歸程式，業務歸業務」的傳統思維</p><h2 id="模型中有以下概念"><a href="#模型中有以下概念" class="headerlink" title="模型中有以下概念"></a>模型中有以下概念</h2><ul><li>上下文（Context）: 詞或句子出現的位置。</li><li>領域（Domain）: 知識，影響，或活動。客戶使用軟體要處理旳問題種類即為軟體的領域。</li><li>模型（Model）: 一類描述域的不同方面並可用於解決相關問題的系統化的抽象。</li><li>統一術語（Ubiquitous Language）: 一種團隊成員使用，為了描述域模型而構造的語言。 用於如下:<ul><li>User story 或RFC</li><li>任意的會議</li><li>書信往來</li><li>技術文件</li><li>流程或是行程</li><li>程式碼</li></ul></li></ul><h2 id="Building-blocks"><a href="#Building-blocks" class="headerlink" title="Building blocks"></a>Building blocks</h2><p>在領域驅動設計一書中[2]闡述了一些高層次的概念和實踐，比如通用語言，這意味著領域模型應該形成領域專家為描述系統需求而提供的共同語言，同樣的，這些語言也需要能夠被商業使用者或贊助商和軟體開發商使用。本書專注於將領域層描述為具有多層體系結構的物件導向系統中的常見層次之一。在 DDD 中，有表示，建立和檢索域模型的工件：</p><ul><li>Entity: 一個不由自身屬性定義而是由標識線和它的身分定義的物件。<br>例如：大多數航空公司在每次航班上都獨特地區分每個座位。每個席位都是在這種情況下的一個實體。不過，西南航空，EasyJet 和瑞安航空並沒有區分每個座位；所有的座位都是一樣的。在這種情況下，一個席位實際上是一個Value Object</li><li>Value Object: 只包含元素屬性的不可變物件。<br>例如：當人們交換名片時，他們一般不會區分每張獨特的名片；他們只關心印在卡片上的資訊。在這種情況下，名片是 Value Object</li><li>Service: 強調與其他物件的關係，只定義了可以為客戶做什麼，不應該替代 Entity 和 Value Object 的所有行為。</li><li>Module: 一種表達機制，劃分代碼和概念。</li><li>Factory: 對於那些需要建立特定域物件的方法應該委派給工廠物件，因為這樣可以更容易的替換實現。</li><li>Repository: 對於檢索特定域物件的方法應該委派給 Repository 物件，因為這樣可以很容易地互換替代儲存的實現。</li><li>Aggregate: 由 ROOT ENTITY 繫結在一起的物件的集合，也稱為聚合根。聚合根通過禁止外部物件保持對其成員的參照來保證在聚合內進行的更改的一致性。<br>例如：駕駛汽車時，不必擔心向前移動車輪，使發動機燃燒火花和燃料等。你只是在開車。在這種情況下，汽車是其他幾個物件的集合，並作為所有其他系統的聚合根</li><li>Domain Event: 一個域物件定義了一個事件。域事件是域專家所關心的事件。</li></ul><h2 id="貧血模型-Anemic-Model"><a href="#貧血模型-Anemic-Model" class="headerlink" title="貧血模型 (Anemic Model)"></a>貧血模型 (Anemic Model)</h2><p>特徵:<br>其中包含物件，許多物件會以領域空間中的名詞來命名，而且這些物件會透過真實領域模型所具有的豐富關聯性和結構來連接。<br>從行為上會看出端倪，並了解這些物件上幾乎沒有任何行為，比較像是一組 getter 和 setter。<br>使用 Anemic 領域模型時，會從一組擷取所有領域或商務邏輯的服務物件 (service，傳統上稱為「商務層」**) 來使用這些資料模型。 商務層位於資料模型最上層，其使用資料模型的方式就像是資料一樣。</p><p>重點節錄(來自微軟)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">Anemic 領域模型只是程序樣式設計。 Anemic 實體物件不是真正的物件，因為它們缺少行為 (方法)。</span><br><span class="line">它們只會保存資料屬性，因此不是物件導向設計。</span><br><span class="line"></span><br><span class="line">藉由將所有的行為放入服務物件（商務層）中，您基本上會得到spaghetti 程式碼或交易腳本，</span><br><span class="line">因此您會失去領域模型所提供的優點。</span><br><span class="line"></span><br><span class="line">即便如此，如果您的微服務或限定內容很簡單 (CRUD 服務)，只有資料屬性之實體物件形式的 Anemic 領域模型便已足夠，</span><br><span class="line">而且可能不值得實作更複雜的 DDD 模式。 在此情況下，它只是持續性模型，因為您刻意建立只有 CRUD 用途資料的實體。</span><br><span class="line"></span><br><span class="line">這就是為什麼微服務架構對於根據每個限定內容之多架構方法很理想的原因。 </span><br><span class="line">例如，在 eShopOnContainers 中，</span><br><span class="line">訂購微服務會實作 DDD 模式，但目錄微服務是簡易 CRUD 服務，因此不會實作此模式。</span><br><span class="line">它其實取決於您實作的內容。 如果您要建立的微服務夠簡單 (例如 CRUD 服務)，遵循 Anemic 領域模型就不是反模式。</span><br><span class="line"></span><br><span class="line"> 不過，如果您需要處理微服務網域的複雜性，</span><br><span class="line"> 而此領域有許多不斷改變的商務規則，則 anemic 領域模型可能是該微服務或限定內容的反模式。</span><br><span class="line"> 在此情況下，將它設計為具有實體的豐富模型可能會相當有利於這類微服務的長期成功，</span><br><span class="line"> 因為這些實體包含資料加上行為，並實作額外的 DDD 模式 (彙總、值物件等)。</span><br></pre></td></tr></table></figure><p><img src="https://img-blog.csdn.net/20171108161155976?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHJvdWJsZXNob290ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Anemic Model "></p><h2 id="豐富領域模型-Rich-Domain-Model"><a href="#豐富領域模型-Rich-Domain-Model" class="headerlink" title="豐富領域模型(Rich Domain Model)"></a>豐富領域模型(Rich Domain Model)</h2><p><img src="https://img-blog.csdn.net/20171108161246317?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHJvdWJsZXNob290ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center" alt="Rich Domain Model "></p><p>架構參考:</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/95ed0cc001e94a8ba9f32666113169c9.png" alt="傳統架構 "></p><p>架構轉成DDD</p><p><img src="https://ucc.alicdn.com/pic/developer-ecology/d92764a7963f43068273133f9a1ac6f9.png" alt="DDD 之後"></p><h2 id="閱讀參考"><a href="#閱讀參考" class="headerlink" title="閱讀參考"></a>閱讀參考</h2><p>程式架構:<br><a href="https://developer.aliyun.com/article/716908" target="_blank" rel="noopener">阿里技术专家详解 DDD 系列- Domain Primitive</a><br><a href="https://developer.aliyun.com/article/719251" target="_blank" rel="noopener">阿里技术专家详解DDD系列 第二弹 - 应用架构</a><br><a href="https://juejin.cn/post/6845166890554228744" target="_blank" rel="noopener">阿里技术专家详解DDD系列 第三讲 - Repository模式 </a><br><a href="https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650414919&idx=1&sn=0ad1df1a1b0e2488f7faa21008fdbdd0&chksm=8396d75fb4e15e49341b07022780dcb8dca66a0efb7f129d4de86a5ef5d8a890f6e0d2fd6432&scene=132#wechat_redirect" target="_blank" rel="noopener">DDD系列第四讲：领域层设计规范 </a></p><p>其他:<br><a href="https://blog.csdn.net/troubleshooter/article/details/78479984" target="_blank" rel="noopener">什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？</a><br><a href="https://blog.csdn.net/johnstrive/article/details/16805121?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control" target="_blank" rel="noopener">领域模型驱动设计（Domain Driven Design）入门概述</a><br><a href="https://blog.csdn.net/iteye_3055/article/details/82106174?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.control" target="_blank" rel="noopener">领域驱动设计(Domain Driven Design)参考架构详解</a><br><a href="https://docs.microsoft.com/zh-tw/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-domain-model" target="_blank" rel="noopener">微服務 - 架構電子書 (微軟) - 設計微服務領域模型</a><br><a href="https://ithelp.ithome.com.tw/articles/10216645" target="_blank" rel="noopener">關於 Domain-Driven Design 以及他的魅力　(這個上面寫的程式範例不太好，看其他文章範例)</a><br><a href="https://medium.com/tradeshift-engineering/my-vision-as-a-software-engineer-about-ddd-domain-driven-design-part-2-973bcf5a9848" target="_blank" rel="noopener">My vision, as a Software Engineer, about DDD (Domain Driven Design) — Part 2 (Java 為範例)</a><br><a href="https://hackmd.io/@ballfish/DDD" target="_blank" rel="noopener">Domain Driven Design</a><br><a href="https://www.cnblogs.com/daoqidelv/p/7648392.html" target="_blank" rel="noopener">【DDD】领域驱动设计实践 —— Domain层实现</a><br><a href="https://t.codebug.vip/questions-2083339.htm" target="_blank" rel="noopener">DDD 程式設計範例討論</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;閱讀DDD相關文章重點整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>資料庫Connection pool設定</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210217-database-connection-pool.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210217-database-connection-pool.html</id>
    <published>2021-02-17T09:30:30.000Z</published>
    <updated>2021-02-17T13:39:03.307Z</updated>
    
    <content type="html"><![CDATA[<p>相關文章重點整理。</p><a id="more"></a> <h2 id="誤區"><a href="#誤區" class="headerlink" title="誤區"></a>誤區</h2><p>資料庫連線池的大小越大越好? Ans: 絕對不是</p><h2 id="正確觀念"><a href="#正確觀念" class="headerlink" title="正確觀念"></a>正確觀念</h2><p>(maximumPoolSize: 連線池中允許的最大連線數) 連線數 = ((核心數 * 2) + 有效磁碟數)</p><h2 id="主要影響資料庫的效能瓶頸因素"><a href="#主要影響資料庫的效能瓶頸因素" class="headerlink" title="主要影響資料庫的效能瓶頸因素"></a>主要影響資料庫的效能瓶頸因素</h2><ul><li>CPU</li><li>磁碟 IO (SSD由於不像傳統硬碟需要定址、旋轉碟片，因此更少的阻塞 ，會更近似於CPU核心數)</li><li>網路 IO </li><li>SQL語法 </li></ul><p><a href="https://www.itread01.com/content/1547137124.html" target="_blank" rel="noopener">資料庫連線池DataSource (解釋連線池為何要使用)</a><br><a href="https://www.mdeditor.tw/pl/2FBd/zh-tw" target="_blank" rel="noopener">如何正確設定資料庫連線池的大小？</a><br><a href="https://www.youtube.com/watch?v=xNDnVOCdvQ0" target="_blank" rel="noopener">OLTP Performance - Concurrent Mid-Tier Connections (Oracle Learning Youtube)</a><br><a href="https://github.com/brettwooldridge/HikariCP" target="_blank" rel="noopener">HikariCP 設定參數 (Github)</a><br><a href="https://www.mdeditor.tw/pl/piUT/zh-tw" target="_blank" rel="noopener">HikariCP 設定參數 (翻譯)</a><br><a href="https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing" target="_blank" rel="noopener">About Pool Sizing - HikariCP (Github)</a><br><a href="https://www.itread01.com/content/1548895884.html" target="_blank" rel="noopener">Springboot datasource 常用配置說明</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;相關文章重點整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>SOA架構 與 Microservice</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210204-microservice-soa.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210204-microservice-soa.html</id>
    <published>2021-02-04T15:07:30.000Z</published>
    <updated>2021-02-04T15:09:56.475Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇到問題查詢的資料，做個整理。</p><a id="more"></a><h2 id="Service-Oriented-Architecture-SOA-服務導向架構"><a href="#Service-Oriented-Architecture-SOA-服務導向架構" class="headerlink" title="Service Oriented Architecture(SOA) 服務導向架構"></a>Service Oriented Architecture(SOA) 服務導向架構</h2><p>特性:</p><ul><li>針對某特定要求的輸出，該服務就是運作一項商業邏輯</li><li>具有完備的特性（self-contained）</li><li>消費者並不需要瞭解此服務的運作過程</li><li>可能由底層其他服務組成</li></ul><p>原則:</p><ul><li>可重複使用、粒度、模組性、可組合型、物件化原件、構件化以及具互動操作性</li><li>符合開放標準（通用的或行業的）</li><li>服務的識別和分類，提供和發布，監控和跟蹤。</li></ul><h2 id="SOA-所解決的核心問題"><a href="#SOA-所解決的核心問題" class="headerlink" title="SOA 所解決的核心問題"></a>SOA 所解決的核心問題</h2><ul><li>系統整合(技術層面)</li><li>系統的服務化(技術層面)</li><li>業務的服務化(是以業務驅動把一個 業務單元封裝成一項服務）</li></ul><p><img src="https://img-blog.csdnimg.cn/20181029125611787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4X0Zyb2xm,size_27,color_FFFFFF,t_70" alt="SOA"></p><h2 id="Microservices-微服務"><a href="#Microservices-微服務" class="headerlink" title="Microservices 微服務"></a>Microservices 微服務</h2><ul><li>通過服務實現元件化</li><li>按業務能力來劃分服務和開發團隊</li><li>去中心化</li><li>基礎設施自動化（devops、自動化部署）<br>與服務導向架構（Service-Oriented Architecture）不同，後者是整合各種業務的應用程式，但微服務只屬於一個應用程式。(強調單一業務組件化)</li></ul><h2 id="Microservices-特性"><a href="#Microservices-特性" class="headerlink" title="Microservices 特性"></a>Microservices 特性</h2><ul><li>每個服務都容易被取代。</li><li>服務是以能力來組織的，例如使用者介面、前端、推薦系統、帳單或是物流等。</li><li>由於功能被拆成多個服務，因此可以由不同的程式語言、資料庫實作。</li><li>架構是對稱而非分層（即生產者與消費者的關係）</li></ul><p><img src="http://www.45fan.com/uploads/allimg/190414/03110Jc9-1.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTI1MzAw,size_16,color_FFFFFF,t_70" alt="Microservices"></p><h2 id="Microservices-資料庫三種設計模式"><a href="#Microservices-資料庫三種設計模式" class="headerlink" title="Microservices 資料庫三種設計模式"></a>Microservices 資料庫三種設計模式</h2><ol><li>每個服務都各有一個數據庫，同屬性的服務可共享同個資料庫。</li><li>所有服務都共享同個資料庫，但是不同表格，並且不會跨域存取。</li><li>每個服務都有自己的資料庫，就算是同屬性的也是，資料庫並不會共</li></ol><p>資料庫的可棄性:<br>實踐微服務架構中有許多的做法。但是其中一種的做法是將資料庫視作短期的儲存空間而不是長期的資料。因為他們可以在上線時從事件中心回覆，因此可以快速的從記憶體中快速存取（例：Redis）作為資料庫伺服器。這種做法需要將每個請求當作事件來進行廣播，這樣就可以從事件儲存中心重播所有的事件。</p><p>在微服務中，則通過 API 調用來完成。這些模塊或者服務間調用，大部分時候是為了共享數據。<br>共享數據最賤的方式當然就是採用一種共享資料庫的模式，也就是單體應用常用的方式。應用可以有多個系統模塊，但一般都是只有一個資料庫。</p><p><img src="https://twgreatdaily.com/images/elastic/SnG/SnG8WHMBiuFnsJQVaRyz.jpg" alt="一庫一服  vs 一庫多服"></p><p>一庫多服，這種架構模式通常會被認為是 微服務架構下的反範式，它的問題在於:</p><ul><li>單點故障：一個資料庫倒下，整批服務全部停止。何來的服務獨立性？</li><li>數據在同一個地方，會給貪圖方便的開發或者 DBA 工程師編寫很多數據間高度依賴的程序或者工具。</li><li>無法針對某一個服務進行精準優化或擴展。<br>所以一般推薦的做法，是為每一個微服務準備一個單獨的資料庫，也即一庫一服(Database per Service)模式。這種模式更加適合微服務架構，它滿足每一個服務是獨立開發、獨立部署、獨立擴展的特性。需要對一個服務進行升級或者數據架構改動的時候，不會影響到其他的服務。需要對某個服務進行擴展的時候，也可以手術式的對某一個服務進行局部擴容。</li></ul><h2 id="微服務的切割"><a href="#微服務的切割" class="headerlink" title="微服務的切割"></a>微服務的切割</h2><ol><li>domain-driven design (DDD) 領域驅動設計</li></ol><ul><li>Infrastructure（基礎實施層）</li><li>Domain（領域層）</li><li>Application（應用層）</li><li>Interfaces（表示層，也叫用戶界面層或是接口層）</li></ul><p><img src="https://res.cloudinary.com/dgzowpeqr/image/upload/v1562839291/levp4f9usxwzlrlk1dou.jpg" alt="domain-driven design(DDD)"></p><ol start="2"><li>資料結構</li></ol><h2 id="微服務的利和弊"><a href="#微服務的利和弊" class="headerlink" title="微服務的利和弊"></a>微服務的利和弊</h2><p><img src="https://res.cloudinary.com/dgzowpeqr/image/upload/v1562839370/wgkwtaplr4keahh9ojsa.jpg" alt="Microservices 利與弊"></p><ul><li>利: 單一服務組件化、可獨立部署、技術多樣性</li><li>弊: 分佈式的系統複雜性(各別服務的溝通複雜化)、最終一致性、運維複雜性</li></ul><h2 id="微服務-設計模式"><a href="#微服務-設計模式" class="headerlink" title="微服務(設計模式)"></a>微服務(設計模式)</h2><p><img src="https://codertw.com/wp-content/uploads/img/15JGg8G9K0.jpg" alt="鏈式設計模式"></p><p><img src="https://codertw.com/wp-content/uploads/img/IEq6ZUD3Og.jpg" alt="聚合器設計模式"></p><p><img src="https://i.iter01.com/images/a65374eb32d49af469d0f73fa247e018af4ad67156d77ca20232556c48804cb6.png" alt="代理設計模式"></p><p><img src="https://i.iter01.com/images/a6d2c4c0b8e7cde26918b623c0fdd67f0603e723d1090c6197711638a0a8b3f7.png" alt="分支設計模式"></p><p><img src="https://codertw.com/wp-content/uploads/img/2hmI3o1N3Y.jpg" alt="資料庫共享模式"></p><p><img src="https://codertw.com/wp-content/uploads/img/M2dJFZmv5O.jpg" alt="異部消息設計模式"></p><h2 id="Service-Oriented-Architecture-與-Microservice-差別"><a href="#Service-Oriented-Architecture-與-Microservice-差別" class="headerlink" title="Service Oriented Architecture 與 Microservice 差別"></a>Service Oriented Architecture 與 Microservice 差別</h2><ul><li>微服務不再強調傳統SOA架構裡面比較重的ESB(企業服務匯流排)，進入到單個業務系統內部實現真正的元件化。</li><li>SOA注重的是系統整合方面，而微服務關注的是組件服務完全分離 。<br>more info:<a href="https://en.wikipedia.org/wiki/Microservices" target="_blank" rel="noopener">Microservices wiki 英文</a><br>more info:<a href="https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99" target="_blank" rel="noopener">微服務(Microservices) wiki</a><br>more info:<a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/735003/" target="_blank" rel="noopener">微服務(Microservices) 設計模式</a><br>more info:<a href="https://iter01.com/513031.html" target="_blank" rel="noopener">架構設計思想-微服務架構設計模式</a><br>more info:<a href="https://twgreatdaily.com/I_S-V3MBfGB4SiUw1uN0.html" target="_blank" rel="noopener">如何在微服務架構下進行數據設計？</a><br>more info:<a href="https://www.cnblogs.com/takumicx/p/10021538.html" target="_blank" rel="noopener">微服務-柔性事务</a><br>more info:<a href="https://www.itread01.com/content/1542762129.html" target="_blank" rel="noopener">微服務-DB規劃</a><br>more info:<a href="https://morosedog.gitlab.io/technology-20200304-tech-10/" target="_blank" rel="noopener">技術觀念 | 淺談分散式系統 - 微服務淺談</a><br>more info:<a href="https://blog.csdn.net/xybelieve1990/article/details/84958671" target="_blank" rel="noopener">关于分布式事务BASE模型和柔性事务TCC</a><br>more info:<a href="https://www.itread01.com/content/1542394146.html" target="_blank" rel="noopener">SOA架構和微服務架構的比較</a><br>more info:<a href="https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/588191/" target="_blank" rel="noopener">架構師必看：微服務架構綜述</a><br>more info:<a href="https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84" target="_blank" rel="noopener">SOA Wiki</a><br>more info:<a href="https://www.ipshop.xyz/16625.html" target="_blank" rel="noopener">我只是下了個訂單，鬼知道我在微服務里經歷了什麼？ (DDD 領域驅動設計-微服務切割-訂單設計)</a><br>more info:<a href="https://kknews.cc/zh-tw/news/p95rx6e.html" target="_blank" rel="noopener">老司機避坑指南：如何快速搞定微服務架構？</a><br>more info:<a href="https://www.martinfowler.com/articles/microservices.html#HowBigIsAMicroservice" target="_blank" rel="noopener">martinfowler blog原文</a><br>more info:<a href="https://dzone.com/articles/6-data-management-patterns-for-microservices-1" target="_blank" rel="noopener">6 Data Management Patterns for Microservices</a></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前遇到問題查詢的資料，做個整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>MVC模式 與 三層架構</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210202-mvc-tier.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210202-mvc-tier.html</id>
    <published>2021-02-02T12:07:30.000Z</published>
    <updated>2021-02-04T16:06:10.337Z</updated>
    
    <content type="html"><![CDATA[<p>MVC與三層架構解釋整理。</p><a id="more"></a><h2 id="MVC模式（Model–view–controller）"><a href="#MVC模式（Model–view–controller）" class="headerlink" title="MVC模式（Model–view–controller）"></a>MVC模式（Model–view–controller）</h2><p>是軟體工程中的一種軟體架構模式，把軟體系統分為三個基本部分：</p><ul><li>模型（Model): 用於封裝與應用程式的業務邏輯相關的資料以及對資料的處理方法。「 Model 」有對資料直接存取的權力，例如對資料庫的存取。<ul><li>「Model」不依賴「View」和「Controller」，也就是說， Model 不關心它會被如何顯示或是如何被操作。</li><li>但是 Model 中資料的變化一般會通過一種重新整理機制被公布。為了實現這種機制，那些用於監視此 Model 的 View 必須事先在此 Model 上註冊，從而，View 可以了解在資料 Model 上發生的改變。（比如：觀察者模式（軟體設計模式））</li></ul></li><li>視圖（View）:能夠實現資料有目的的顯示（理論上，這不是必需的）。在 View 中一般沒有程式上的邏輯。為了實現 View 上的重新整理功能，View 需要存取它監視的資料模型（Model），因此應該事先在被它監視的資料那裡註冊。 </li><li>控制器（Controller）: 起到不同層面間的組織作用，用於控制應用程式的流程。它處理事件並作出回應。「事件」包括使用者的行為和資料 Model 上的改變。</li></ul><p>MVC模式在概念上強調 Model, View, Controller 的分離，各個模組也遵循著由 Controller 來處理訊息，Model 掌管資料來源，View 負責資料顯示的職責分離原則，因此在實作上，MVC 模式的 Framework 通常會將 MVC 三個部份分離實作：</p><ul><li>Model 負責資料存取，較現代的 Framework 都會建議使用獨立的資料物件 (DTO, POCO, POJO 等) 來替代弱型別的集合物件。資料存取的程式碼會使用 Data Access 的程式碼或是 ORM-based Framework，也可以進一步使用 Repository Pattern 與 Unit of Works Pattern 來切割資料來源的相依性。</li><li>Controller 負責處理訊息，較高階的 Framework 會有一個預設的實作來作為 Controller 的基礎，例如 Spring 的 DispatcherServlet 或是 ASP.NET MVC 的 Controller 等，在職責分離原則的基礎上，每個 Controller 負責的部份不同，因此會將各個 Controller 切割成不同的檔案以利維護。</li><li>View 負責顯示資料，這個部份多為前端應用，而 Controller 會有一個機制將處理的結果 (可能是 Model, 集合或是狀態等) 交給 View，然後由 View 來決定怎麼顯示。例如 Spring Framework 使用 JSP 或相應技術，ASP.NET MVC 則使用 Razor 處理資料的顯示。</li></ul><h2 id="三層架構-3-tier-architecture"><a href="#三層架構-3-tier-architecture" class="headerlink" title="三層架構(3-tier architecture)"></a>三層架構(3-tier architecture)</h2><p>是一種軟體抽象的層次結構，從”整個應用程式架構的角度”來區分為三層。 </p><p>目的: 高內聚，低耦合的思想<br>優點: </p><ul><li>利於標準化</li><li>降低層與層之間的依賴</li><li>利於各層邏輯的復用，資源重用性好</li><li>開發人員可以只關注整個結構中的其中某一層</li><li>具有良好的開放性和可擴充性，維護和升級方便</li><li>提高系統的安全性</li></ul><p>缺點: </p><ul><li>有時會導致連動的修改。</li><li>如果在表現層中需要增加一個功能，為保證其設計符合分層式結構，可能需要在相應的商業邏輯層和資料存取層中都增加相應的程式碼。</li><li>相對於不分層，降低了系統的性能。</li><li>如果不採用分層式結構，很多業務可以直接造訪資料庫，以此獲取相應的數據，如今卻必須通過中間層來完成。</li><li>增加了開發成本。</li></ul><p>分層:</p><ul><li>表現層（Presentation layer）：通俗講就是展現給使用者的介面，即使用者在使用一個系統的時候他的所見所得。</li><li>業務邏輯層（Business Logic Layer）：針對具體問題的操作，也可以說是對資料層的操作，對資料業務邏輯處理。</li><li>資料訪問層（Data Access Layer）：該層所做事務直接運算元據庫，針對資料的增添、移除、修改、查找等。</li></ul><p><img src="https://www.itsfun.com.tw/cacheimg/d7/ce/3cf976ce330db425f6eb1a22d824.jpg" alt="3-tier architecture"></p><p><img src="https://qph.fs.quoracdn.net/main-qimg-91d0a36c056cce85cd3a941a730ef053" alt="3-tier architecture-en"></p><h2 id="兩者的差異"><a href="#兩者的差異" class="headerlink" title="兩者的差異"></a>兩者的差異</h2><ul><li>三層架構是一個分層式的軟件體系架構設計。 MVC是一個設計模式，它是根據項目的具體需求來決定是否適用於該項目。</li><li>三層架構的目的著重點是”高內聚，低耦合”，即解耦。 MVC的目的則是實現Web系統的職能分工，即職責劃分。</li><li>三層側重的是整體的一個解耦。 MVC側重的是web系統的解耦，即側重jsp和Servlet的一個解耦。</li><li>三層架構的分層模式是典型的上下關系，上層依賴於下層。 MVC作為表現模式是不存在上下關系的，而是相互協作關系。</li></ul><p>more info:<a href="https://zh.wikipedia.org/wiki/MVC" target="_blank" rel="noopener">MVC Wiki</a><br>more info:<a href="https://shunnien.github.io/2017/07/29/3-tier-and-mvc-introduction/" target="_blank" rel="noopener">三層結構與 Asp.Net MVC 的簡介 Wiki</a><br>more info:<a href="https://www.itread01.com/content/1514351052.html" target="_blank" rel="noopener">三層架構與MVC的區別</a><br>more info:<a href="https://www.itread01.com/content/1514351052.html" target="_blank" rel="noopener">三層架構與MVC的區別</a><br>more info:[softwareengineering討論區]<a href="https://softwareengineering.stackexchange.com/questions/299836/difference-between-3-tier-architecture-and-mvc-model-view-controller-in-asp-n" target="_blank" rel="noopener">https://softwareengineering.stackexchange.com/questions/299836/difference-between-3-tier-architecture-and-mvc-model-view-controller-in-asp-n</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;MVC與三層架構解釋整理。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Spring註解 @Component @Service, @Controller, @Repository</title>
    <link href="https://hand79.github.io/Blog/posts/Java/20210201-spring-annotation-component.html"/>
    <id>https://hand79.github.io/Blog/posts/Java/20210201-spring-annotation-component.html</id>
    <published>2021-02-01T14:47:33.000Z</published>
    <updated>2021-02-04T13:51:20.482Z</updated>
    
    <content type="html"><![CDATA[<p>以前留下整理的資料的記錄。</p><a id="more"></a><h2 id="spring註解"><a href="#spring註解" class="headerlink" title="spring註解"></a>spring註解</h2><p>@Component, @Service, @Controller, @Repository是spring註解，註解後可以被spring框架所掃描並註入到spring容器來進行管理</p><ul><li>@Component是通用註解，其他三個註解是這個註解的拓展，並且具有了特定的功能(generic stereotype for any Spring-managed component)。</li><li>@Repository註解在持久層中，具有將數據庫操作拋出的原生異常翻譯轉化為spring的持久層異常的功能。(stereotype for persistence layer)</li><li>@Controller層是spring-mvc的註解，具有將請求進行轉發，重定向的功能。(stereotype for presentation layer)</li><li>@Service層是業務邏輯層註解，這個註解只是標註該類處於業務邏輯層。 (stereotype for service layer)<br>用這些註解對應用進行分層之後，就能將請求處理，義務邏輯處理，數據庫操作處理分離出來，為代碼解耦，也方便了以後項目的維護和開發。</li></ul><p>註解:<br>Spring2.0時提供的: @Repository(在Spring2.5有修改部分內容)<br>Spring2.5時提供的: @Component, @Controller, @Service</p><p>more info:<a href="https://stackoverflow.com/posts/6897038/edit" target="_blank" rel="noopener">stackoverflow 參考</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html" target="_blank" rel="noopener">@Repository doc</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html" target="_blank" rel="noopener">@Component doc</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html" target="_blank" rel="noopener">@Controller doc</a><br>more info:<a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html" target="_blank" rel="noopener">@Service doc</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;以前留下整理的資料的記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Java" scheme="https://hand79.github.io/Blog/categories/Java/"/>
    
    
    <category term="Java" scheme="https://hand79.github.io/Blog/tags/Java/"/>
    
    <category term="Spring" scheme="https://hand79.github.io/Blog/tags/Spring/"/>
    
  </entry>
  
  <entry>
    <title>悲觀鎖與樂觀鎖(資料庫交易)</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210201-locking-pessimistic-optimistic.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210201-locking-pessimistic-optimistic.html</id>
    <published>2021-02-01T11:47:30.000Z</published>
    <updated>2021-02-04T10:54:54.350Z</updated>
    
    <content type="html"><![CDATA[<p>之前遇上的問題，劃個重點留個整理記錄。</p><a id="more"></a><p>資料庫交易特性ACID中的交易隔離(Isolation)通常利用「鎖(locking)」來實現，目的為避免同一筆資料在併行交易(concurrent transaction)中被不同的交易同時修改以確保資料的完整性。<br>交易鎖又分為「悲觀鎖(pessimistic locking)」與「樂觀鎖(optimistic locking)」。</p><p>常用鎖處理的例子: 電商商品庫存、銀行轉帳業務</p><p>##悲觀鎖(Pessimistic Locking)<br>時機: 悲觀並行控制主要用於資料爭用激烈的環境或發生並發衝突時，”使用鎖保護資料的成本”要低於”回復交易的成本”的環境中。</p><ul><li>悲觀並行控制實際上是「先取鎖再訪問」的保守策略，為資料處理的安全提供了保證。</li><li>在效率方面，處理加鎖的機制會讓資料庫產生額外的開銷，還有增加產生”死鎖”的機會</li><li>在只讀型交易處理中由於不會產生衝突，就沒必要使用鎖，這樣做只能增加系統負載，還有會降低了並行性。</li><li>一個交易如果鎖定了某行資料，其他交易就必須等待該交易處理完才可以處理那行資料。(當下資料有對其他執行存取有排他性)<br>典型的使用: synchronized (java)</li></ul><p>##樂觀鎖(Optimistic Locking)<br>時機: 樂觀並行控制多數用於”資料爭用不大”、”衝突較少的環境”中，”偶爾回復交易的成本”會低於”讀取資料時鎖定資料的成本”，因此可以獲得”比其他並行控制方法更高的吞吐量”。</p><ul><li>假設”多使用者並行的交易在處理時不會彼此互相影響”，”各交易能夠在不產生鎖”的情況下”處理各自影響的那部分資料”。在提交資料更新之前，每個交易會”先檢查在該交易讀取資料後，有沒有其他交易又修改了該資料”。如果其他交易有更新的話，正在提交的交易會進行rollback。</li></ul><p>缺點: 樂觀並行控制相信交易之間的資料競爭(data race)的概率是比較小的，因此儘可能直接做下去，直到提交的時候才去鎖定，所以不會產生任何鎖和死結。但如果直接簡單這麽做，還是有可能會遇到不可預期的結果，例如兩個交易都讀取了資料庫的某一行，經過修改以後寫回資料庫，這時就遇到了問題。(ABA问题) </p><ul><li>需要添加重試機制，舉個例子: 資料異動時衝突(JPA中的@version)，重新在執行失敗的動作</li></ul><h4 id="樂觀並行控制的交易包括以下階段："><a href="#樂觀並行控制的交易包括以下階段：" class="headerlink" title="樂觀並行控制的交易包括以下階段："></a>樂觀並行控制的交易包括以下階段：</h4><ul><li>讀取：交易將資料讀入快取，這時系統會給交易分派一個時間戳。</li><li>校驗：交易執行完畢後，進行提交。這時同步校驗所有交易，如果交易所讀取的資料在讀取之後又被其他交易修改，則產生衝突，交易被中斷回復。</li><li>寫入：通過校驗階段後，將更新的資料寫入資料庫。<br>典型的使用: Compare and Swap (CAS)、 AtomicReference class、 @Version(Java JPA中的@version 版本控制處理方式)</li></ul><p>##總結<br>樂觀鎖適用於讀大於寫、衝突少的的場景(省去了鎖的開銷，加大了系統的整個吞吐量。如果經常產生衝突，上層應用會不斷的進行retry可能須考慮是否用悲觀鎖)<br>悲觀鎖寫大於讀、衝突大的的場景(併發量不大且不允許髒讀適合)</p><p>more info:<a href="https://www.cnblogs.com/kismetv/p/10787228.html" target="_blank" rel="noopener">資料參考</a><br>more info:<a href="https://en.wikipedia.org/wiki/Optimistic_concurrency_control" target="_blank" rel="noopener">Optimistic Concurrency wiki</a><br>more info:<a href="https://zh.wikipedia.org/wiki/%E6%82%B2%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6" target="_blank" rel="noopener">Pessimistic Concurrency wiki</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;之前遇上的問題，劃個重點留個整理記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Kubernetes 故障排除流程圖</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210131-kubernetes.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210131-kubernetes.html</id>
    <published>2021-01-31T13:47:30.000Z</published>
    <updated>2021-01-31T14:07:06.524Z</updated>
    
    <content type="html"><![CDATA[<p>討論區看到的，留個記錄，某天遇上了可以參考。</p><a id="more"></a><p>*<em>Kubernetes 故障排除流程圖 參考 *</em><br><img src="https://learnk8s.io/a/7d3cde9ddb57e4246215de4be2f3dd71.png" alt="k8s"></p><p>more info:<a href="https://learnk8s.io/troubleshooting-deployments?fbclid=IwAR1q4Wu7GLSmmPlX7ooMK3W4lccZjwsqkygECROsyyvBe_o6YVv26Lz9PX4" target="_blank" rel="noopener">資料出處</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;討論區看到的，留個記錄，某天遇上了可以參考。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>RESTful API設計</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210131-rest-api-Development.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210131-rest-api-Development.html</id>
    <published>2021-01-31T11:30:30.000Z</published>
    <updated>2021-01-31T13:48:03.605Z</updated>
    
    <content type="html"><![CDATA[<p>RESTful API 設計之學習記錄</p><a id="more"></a> <h2 id="REST要點-REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。"><a href="#REST要點-REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。" class="headerlink" title="REST要點(REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。)"></a>REST要點(REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。)</h2><ul><li>資源是由URI來指定。</li><li>對資源的操作包括取得、建立、修改和刪除，這些操作正好對應HTTP協定提供的GET、POST、PUT和DELETE方法。</li><li>通過操作資源的表現形式來操作資源。</li><li>資源的表現形式則是XML或者HTML，取決於讀者是機器還是人、是消費Web服務的客戶軟體還是Web瀏覽器。當然也可以是任何其他的格式，例如JSON。</li></ul><h2 id="特徵"><a href="#特徵" class="headerlink" title="特徵"></a>特徵</h2><ul><li>統一介面(Uniform Interface)<ul><li>Identification of resources - 唯一的資源識別</li><li>Manipulation of resources - 特定的操作方法</li><li>Self-descriptive messages - 訊息自我描述 </li><li>Hypermedia as the engine of application state (HATEOAS)<ul><li>Level 0 : 使用一個 URI 與一個 HTTP 方法，基本上就是單純使用 HTTP 作為傳輸協定，服務使用的 URI 只是個接收請求進行回應的端點，HTTP 方法只是用來發起請求，至於請求的相關細節，例如想進行的動作、必須提供的資料等，全部包含在發送過去的文件之中，像是 XML、JSON 等其他（自訂）格式，回應使用某個文件格式傳回，當中包含了請求操作後的結果。</li><li>Level 1 : 使用多個 URI 與一個 HTTP 方法，URI 代表了資源，像是 /show_message、/create_message、/update_message、/delete_message 都是資源，HTTP 方法只是用來發起請求，至於請求的細節由請求本體來提供，例如，在請求 /show_message 這項資源時，若包含 all 請求參數，表示顯示全部的訊息，若是 “id=1” 這類請求參數，表示顯示指定的訊息。</li><li>Level 2 :使用多個 URI、多個 HTTP 方法，並善用 HTTP 回應狀態碼，URI 用來代表資源，像是 /messages、/messages/1，HTTP 方法用來表示想進行的操作，例如 GET /messages 表示取得全部訊息，GET /messages/1 表示取得指定訊息，POST /messages 表示新增訊息、DELETE /messages/1 表示刪除指定訊息等</li><li>Level 3 : 更進一步地，支援 HATEOAS（Hypermedia As The Engine Of Application State）的概念，就類似 HTML 頁面鏈結，你可以從這個頁面得知可通往哪些頁面，在 REST 的 Level 3 模型中，客戶端可以從某個資源，知道還有哪些其他相關的資源，以及如何對它進行操作</li></ul></li></ul></li><li>Stateless(無狀態)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#How to understand “RESTful API is stateless”?(stackoverflow) (部分內容擷取)</span><br><span class="line">[...] </span><br><span class="line"> each request from client to server must contain all of the information necessary to understand the request,</span><br><span class="line"> and cannot take advantage of any stored context on the server. </span><br><span class="line"> Session state is therefore kept entirely on the client. [...]</span><br></pre></td></tr></table></figure><ul><li>Cacheable(可快取)</li><li>Client-Server(客戶伺服器分離模式，任何一個客戶端與伺服器都是可替換的)</li><li>Layered System (分層的系統，客戶端不知道他請求的是不是最終伺服器)</li><li>Code on Demand (optional)<ul><li>允許客戶端提高其靈活性(視情況決定要不要遵守，Server端 可以傳送可執行的程式碼給 Client端)</li></ul></li></ul><h2 id="REST設計"><a href="#REST設計" class="headerlink" title="REST設計"></a>REST設計</h2><p>符合REST設計風格的Web API稱為RESTful API。它從以下三個方面資源進行定義：</p><ul><li>直觀簡短的資源位址，比如: <a href="http://example.com/resources。" target="_blank" rel="noopener">http://example.com/resources。</a></li><li>傳輸的資源：Web服務接受與返回的網際網路媒體類型，比如：JSON，XML，YAML等。</li><li>對資源的操作：Web服務在該資源上所支援的一系列請求方法（比如：POST，GET，PUT或DELETE）。</li></ul><h2 id="RESTful-API設計要點"><a href="#RESTful-API設計要點" class="headerlink" title="RESTful API設計要點"></a>RESTful API設計要點</h2><p>HTTP動詞</p><ul><li>GET（SELECT）：請求指定資源，只應用於取得資料。(Filtering， query string)</li><li>POST（CREATE）：在服務器新建一個資源。</li><li>PUT（UPDATE）：會取代指定資源所酬載請求（request payload）的所有表現。</li><li>PATCH（UPDATE）：指定資源的部份修改。</li><li>DELETE（DELETE）：從服務器刪除指定資源。</li><li>HEAD：請求與 GET方法相同的回應，但它沒有回應主體（response body）。(應用於HTTP標頭，判別資源是否存在)</li><li>OPTIONS：描述指定資源的溝通方法（communication option）。</li><li>CONNECT: 指定資源標明的伺服器之間，建立隧道（tunnel）。</li><li>TRACE: 指定資源標明的伺服器之間，執行迴路返回測試（loop-back test）。</li></ul><p>資源命名與設計: </p><ul><li>複數名詞命名資源，如 <a href="https://api.example.com/v1/users" target="_blank" rel="noopener">https://api.example.com/v1/users</a></li><li>取得特定ID資源(別另外設計單數)，如 <a href="https://api.example.com/v1/users/1" target="_blank" rel="noopener">https://api.example.com/v1/users/1</a></li><li>取得特定複數資料查詢利用 query string做額外條件過濾或參數，<br>(<a href="https://api.example.com/v1/users?order=&quot;desc&quot;&amp;&amp;limit=10" target="_blank" rel="noopener">https://api.example.com/v1/users?order=&quot;desc&quot;&amp;&amp;limit=10</a>)</li><li>URI 應加入 API 的版本號，如<a href="https://api.example.com/v1/users" target="_blank" rel="noopener">https://api.example.com/v1/users</a></li></ul><h2 id="參考"><a href="#參考" class="headerlink" title="參考:"></a>參考:</h2><p><a href="https://www.crummy.com/writing/speaking/2008-QCon/act3.html" target="_blank" rel="noopener">REST 成熟度模型</a><br><a href="https://itbilu.com/other/relate/ry5IPQu8V.html" target="_blank" rel="noopener">成熟度模型-REST的实现步骤</a><br><a href="https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E5%B9%82%E7%AD%89%E6%96%B9%E6%B3%95" target="_blank" rel="noopener">HyperText Transfer Protocol，HTTP (wiki)</a><br><a href="https://stackoverflow.com/questions/34130036/how-to-understand-restful-api-is-stateless" target="_blank" rel="noopener">How to understand “RESTful API is stateless”?(stackoverflow)</a><br><a href="https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2" target="_blank" rel="noopener">REST Wiki</a><br><a href="http://www.ruanyifeng.com/blog/2014/05/restful_api.html" target="_blank" rel="noopener">RESTful API 设计指南 - 阮一峰的网络日志</a><br><a href="https://openhome.cc/Gossip/Spring/HATEOAS.html" target="_blank" rel="noopener">Hypermedia As The Engine Of Application State(HATEOAS) Spring HATEOAS</a><br><a href="https://github.com/TritonHo/slides/blob/master/Taipei%202019-06%20talk/RESTful%20API%20Design-tw-2.2.pdf" target="_blank" rel="noopener">Backend社團-紫色石虎-RESTful API淺談</a><br><a href="https://github.com/TritonHo/slides/blob/master/restful-demo.pdf" target="_blank" rel="noopener">Backend社團-紫色石虎-RESTful淺談  - demo</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Methods" target="_blank" rel="noopener">HTTP (MDN)</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;RESTful API 設計之學習記錄&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>網頁前端設計</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210128-java-frontend-system-design.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210128-java-frontend-system-design.html</id>
    <published>2021-01-28T11:12:30.000Z</published>
    <updated>2021-01-28T11:15:03.544Z</updated>
    
    <content type="html"><![CDATA[<p>寫個記錄。</p><a id="more"></a><h2 id="Responsive-Web-Design-RWD-，-響應式網頁設計"><a href="#Responsive-Web-Design-RWD-，-響應式網頁設計" class="headerlink" title="Responsive Web Design (RWD)， 響應式網頁設計"></a>Responsive Web Design (RWD)， 響應式網頁設計</h2><ul><li>是一種網頁設計模式，這種設計可使網站在不同的裝置（從桌面電腦顯示器到行動電話或其他行動裝置）上瀏覽時對應不同解析度皆有適合的呈現，減少使用者進行縮放、平移和捲動等操作行為。<br><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Complete.png/190px-Complete.png" alt="RWD示意圖"></li></ul><h2 id="Single-Page-Application-SPA-，單頁式應用"><a href="#Single-Page-Application-SPA-，單頁式應用" class="headerlink" title="Single Page Application (SPA)，單頁式應用"></a>Single Page Application (SPA)，單頁式應用</h2><ul><li>利用 AJAX 非同步的特性跟後端同步資料，將不同的資料動態輸向同一個頁面，達到網頁操作不換頁。</li><li>缺點: 是少了後端的渲染回傳，如果使用者操作太快，前端就不能保證每次都能得到正確的 Server 資料（eg. 點進網頁內容，還沒加載完成就點各種功能）。</li><li>需要解決sync與async各項功能的問題</li><li>典型應用: gmail信箱</li></ul><h2 id="Server-side-render-SSR-，伺服器端渲染"><a href="#Server-side-render-SSR-，伺服器端渲染" class="headerlink" title="Server side render (SSR)，伺服器端渲染"></a>Server side render (SSR)，伺服器端渲染</h2><ul><li>為避免 SPA 讓 SEO 變差，先渲染網頁內容，再將後續操作交給 JavaScript，</li><li>使用者一樣能享受到 SPA 不用換頁的好處，不過首次加載的時間增加了。</li><li>在 SSR 的開發上也要需要會一點後端技術。(JSP、Thymeleaf等)</li></ul><h2 id="Accelerated-Mobile-Pages-AMP"><a href="#Accelerated-Mobile-Pages-AMP" class="headerlink" title="Accelerated Mobile Pages (AMP)"></a>Accelerated Mobile Pages (AMP)</h2><ul><li>Google帶領開發的開源專案</li><li>即為「加速行動網頁」，目的是提升行動裝置對網站的存取速度。</li><li>AMP即是透過「規範HTML框架」、「限制JavaScript」、「Google高速緩存」這三種要素，縮小網頁檔案、縮短傳輸時間、降低頁面載入時間。</li><li>只要透過「行動裝置」搜尋時，發現網址前面顯示一個閃電符號⚡️即屬於AMP網頁，通常優先出現在排序前幾名，甚至讓用戶點擊進去等不到一秒，就能看到網頁內容。不僅提高點擊率，也降低了因網頁載入太久的跳出率。</li></ul><h2 id="Progressive-Web-App-PWA"><a href="#Progressive-Web-App-PWA" class="headerlink" title="Progressive Web App (PWA)"></a>Progressive Web App (PWA)</h2><ul><li>2016年 Google提出的概念，PWA的存在是為結合網站和 App 二者的特性，透過網站呈現如 APP 般的瀏覽優點，提供更好的用戶體驗。</li><li>因為PWA的本質是網站，程式語言就是用Html5、Css3、JS。</li><li>沒有跨平台需要不同程式版本的問題，更新內容也是直接從伺服端更改就可以了。</li><li>可靠：即時載入，就算網路狀況欠佳，甚至沒有網路的情況下還是能夠瀏覽。</li><li>快速：畫面流暢且即時回應，提供最佳瀏覽效果。</li><li>吸引度：使用起來如同App一般，帶來人性化的使用體驗。</li><li>不需要透過Google Play或是App Store下載，而是在你瀏覽該網站時，會跳出詢問視窗，當使用者按下同意後，會直接在裝置桌面新增一個快速連結的圖示</li></ul><p>More info: <a href="https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1" target="_blank" rel="noopener">RWD wiki</a><br>More info: <a href="https://zh.wikipedia.org/wiki/Accelerated_Mobile_Pages" target="_blank" rel="noopener">AMP wiki</a><br>More info: <a href="https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F" target="_blank" rel="noopener">PWA wiki</a><br>More info: <a href="https://blog.sharktech.tw/2018/02/07/google-amp" target="_blank" rel="noopener">google AMP</a><br>More info: <a href="https://web.dev/progressive-web-apps/" target="_blank" rel="noopener">PWA 官網</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;寫個記錄。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>電信業即時計費系統Domain knowledge</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210128-java-telecommunications-system-design.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210128-java-telecommunications-system-design.html</id>
    <published>2021-01-28T10:30:30.000Z</published>
    <updated>2021-01-28T10:06:23.463Z</updated>
    
    <content type="html"><![CDATA[<p>某電信業即時計費系統簡易系統設計Domain knowledge描述，大概整理下。</p><a id="more"></a><h2 id="門號申裝流程"><a href="#門號申裝流程" class="headerlink" title="門號申裝流程"></a>門號申裝流程</h2><ol><li>電信申租門號(月租型、預付卡)</li><li>選號(手機號碼)</li><li>服務方案、優惠(後頭供裝在特定門號優惠服務)</li><li>門號啟用(使門號生效進行打電話、上網等服務)</li></ol><p>服務內容包括:</p><ul><li>資費設定、變更資費</li><li>用量查詢</li><li>計費周期(BillCycle)，出帳的週期</li><li>加值服務(數據加包價購，預付卡儲值等)</li><li>用量簡訊(到達特定亮時給予提醒)</li><li>到期簡訊(服務到期、數據包到期、預付卡到期等)</li><li>用罄簡訊(eg. 上網數據包用罄發送通知)</li><li>服務群組設定</li><li>優惠內容設定</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;某電信業即時計費系統簡易系統設計Domain knowledge描述，大概整理下。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Callback hell 處理(jQuery,Promise, async/await)</title>
    <link href="https://hand79.github.io/Blog/posts/JavaScript/20210128-java-callback-hell.html"/>
    <id>https://hand79.github.io/Blog/posts/JavaScript/20210128-java-callback-hell.html</id>
    <published>2021-01-28T09:30:33.000Z</published>
    <updated>2021-01-28T09:43:17.287Z</updated>
    
    <content type="html"><![CDATA[<p>在某家壽險業解過這類似的鬼東西，整理一下解釋。</p><a id="more"></a><p>如圖:<br>** 示意圖 **<br><img src="https://d1dwq032kyr03c.cloudfront.net/upload/images/20181014/201103713ObcIuaSP4.jpg" alt="Callback hell"></p><p>-必須兼容IE處理方式:</p><ul><li>jQuery 的方式處理</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$.ajax(&#123;參數&#125;)</span><br><span class="line">.then(callback_A)</span><br><span class="line">.then(callback_B)</span><br><span class="line">.then(callback_C)</span><br></pre></td></tr></table></figure><p>適合解法</p><ul><li>Promise (ES6 的語法)<br>![Promise] (<a href="https://cdn.rawgit.com/Vectaio/a76330b025baf9bcdf07cb46e5a9ef9e/raw/26c4213a93dee1c39611dcd0ec12625811b20a26/js-promise.svg" target="_blank" rel="noopener">https://cdn.rawgit.com/Vectaio/a76330b025baf9bcdf07cb46e5a9ef9e/raw/26c4213a93dee1c39611dcd0ec12625811b20a26/js-promise.svg</a>)</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const promise1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class="line">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class="line">    resolve(&#39;foo&#39;);</span><br><span class="line">  &#125;, 300);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">promise1.then((value) &#x3D;&gt; &#123;</span><br><span class="line">  console.log(value);</span><br><span class="line">  &#x2F;&#x2F; expected output: &quot;foo&quot;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">console.log(promise1);</span><br><span class="line">&#x2F;&#x2F; expected output: [object Promise]</span><br></pre></td></tr></table></figure><ul><li>async/await (ES7的語法)，可與Promise混合使用</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">async function a()&#123;</span><br><span class="line">  await b();</span><br><span class="line">  .....       &#x2F;&#x2F; 等 b() 完成後才會執行</span><br><span class="line">  await c();</span><br><span class="line">  .....       &#x2F;&#x2F; 等 c() 完成後才會執行</span><br><span class="line">  await new Promise(resolve&#x3D;&gt;&#123;</span><br><span class="line">    .....</span><br><span class="line">  &#125;);</span><br><span class="line">  .....       &#x2F;&#x2F; 上方的 promise 完成後才會執行</span><br><span class="line">&#125;</span><br><span class="line">a();</span><br><span class="line">a().then(()&#x3D;&gt;&#123;</span><br><span class="line">  .....       &#x2F;&#x2F; 等 a() 完成後接著執行</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>參考: <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="noopener">Promise MDN文件</a><br>參考: <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/async_function" target="_blank" rel="noopener">async MDN文件</a><br>參考: <a href="https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/await" target="_blank" rel="noopener">await MDN文件</a><br>參考: <a href="https://www.oxxostudio.tw/articles/201908/js-async-await.html" target="_blank" rel="noopener">簡單理解 JavaScript Async 和 Await</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;在某家壽險業解過這類似的鬼東西，整理一下解釋。&lt;/p&gt;</summary>
    
    
    
    <category term="JavaScript" scheme="https://hand79.github.io/Blog/categories/JavaScript/"/>
    
    
    <category term="JavaScript" scheme="https://hand79.github.io/Blog/tags/JavaScript/"/>
    
  </entry>
  
  <entry>
    <title>壽險業系統設計Domain knowledge</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210128-java-insurance-system-design.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210128-java-insurance-system-design.html</id>
    <published>2021-01-28T08:40:30.000Z</published>
    <updated>2021-01-28T10:06:20.452Z</updated>
    
    <content type="html"><![CDATA[<p>壽險業簡易系統設計Domain knowledge描述，大概整理個通則。</p><a id="more"></a><h2 id="保單投保、核保流程-依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣"><a href="#保單投保、核保流程-依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣" class="headerlink" title="保單投保、核保流程(依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣)"></a>保單投保、核保流程(依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣)</h2><ol><li>建議書</li></ol><ul><li>主要是業務員透過拜訪客戶在介紹公司的保險商品階段。</li><li>保險業務員與要被保險人談論保什麼險，之後進行初步輸入資料的階段。</li></ul><ol start="2"><li>要保書</li></ol><ul><li>輸入建檔階段，要被保人資料、簽名、保單商品資料、投保金額、證明文件等。</li><li>照會檢查</li></ul><ol start="3"><li>核保審核</li></ol><ul><li>該階段會有該業務員的主管審核該保單資料內容，比如說黑名單、該投保金額、年齡、收入、被保人健康狀態。</li><li>扣款也會在這階段。</li><li>有問題發送照會，依內容決定是否退回處理</li></ul><ol start="4"><li>投保完成</li></ol><ul><li>一般來說該階段僅提供查閱的功能，不再提供變更。</li><li>若要修改原本的保單，會需要留下資料備查不可刪除(log 或記錄在資料庫，保戶的舊保單相關內容進行註記)，另開新流程重新開始保單的投保流程或回到投保審核前階段。</li></ul><p>Extra: </p><ol><li><p>保單管理</p><ul><li>顧名思義就是保單的管理</li><li>掛在業務員身上通常是未審核前的保單(該系統需設計利益迴避，避免自己人審自己人的情況)</li><li>掛在審核人員身上的就是要審核的保單</li></ul></li><li><p>保單查詢</p><ul><li>查詢保單內容</li></ul></li><li><p>保單健檢 (不在投保主流程，算是輔助業務員與要被保人的檢視保障的功能)</p><ul><li>檢視該保單的保障和規劃，該設計內容可能有圖表預測、和一些依據保單提供的保障規劃。</li><li>提供保險公司保單的檢視功能，提供個人保單檢視及家庭保單檢視功能、可將全家人保單之保障、保費、還本金額、意外、醫療、癌症透過表格或圖形清楚顯示出保障缺口，方便說明，並可納入投資型商品之壽險保障檢視功能，由保障缺口促成保單調整或再銷售的機會，保險資訊源含國內所有保險公司人身險商品。</li></ul></li><li><p>保險需求分析系統  (不在投保主流程，算是輔助業務員與要被保人的檢視保障的功能)</p><ul><li>提供保險業務員協助客戶進行人生各階段理財目標規劃及計算—房貸規劃、子女教育規劃、退休養老規劃、遺產稅計算。</li><li>透過應備及已備費用計算生涯累積差額，找出不足的風險保障。</li><li>可結合保單健檢結果使需求更明確，以全家人的角度做家庭保險需求分析；並進一步提供退休養老規劃及遺產稅計算，根據客戶基本資料之判斷。</li></ul></li><li><p>網路投保系統(不透過業務員的投保流程，其實就是輸入建檔那段換成客戶自己輸入)</p></li></ol><ul><li>商品上架管理</li><li>會員資訊管理(含註冊/登入作業)</li><li>投保案件管理(含投保記錄查詢、投保商品查詢)</li><li>保險商品保費試算、保單核保(含保險公司核保及公會核保)</li><li>信用卡繳費(需確認持卡人為要保人本人)</li><li>投保額度計算</li><li>簽署作業、通報作業</li><li>自然人憑證驗證作業(要保人及簽署人用以驗證身份)等功能。<br>基本主流程:<ol><li>加入會員 -&gt; 同意相關會員條款 -&gt; 輸入個人資料  -&gt; 會員相關驗證(手機、email、支付等驗證，是否當下必填，依各家壽險業業務流程決定)</li><li>輸入投保資料 -&gt; 保費試算</li><li>確認投保資料</li><li>填寫或確認付款資訊</li><li>核保審核<ul><li>照會檢查</li></ul></li><li>完成投保</li></ol></li></ul><h2 id="理賠流程"><a href="#理賠流程" class="headerlink" title="理賠流程"></a>理賠流程</h2><ol><li>理賠申請書，輸入建檔(依過去保單內容自動帶入)<ul><li>該階段資料證明附件大概包括如下:<ul><li>憲警單位處理證明文件或肇事責任鑑定書</li><li>診斷、醫瘵費收據</li><li>瘵養費收據或其他補助收據。</li><li>和解書或判決書。</li><li>戶口名簿影本。</li></ul></li><li>照會檢查</li></ul></li><li>理賠審核<ul><li>審核該理賠案件之內容</li><li>調查附上的文件的內容</li><li>有問題發送照會，依內容決定是否退回處理</li></ul></li><li>理賠結果<ul><li>拒賠</li><li>文件不齊全，通知補齊，會回到審核階段或輸入階段</li><li>依約給付，匯款、支票等給付方式</li></ul></li></ol><h2 id="收費流程"><a href="#收費流程" class="headerlink" title="收費流程"></a>收費流程</h2><ol><li>收費保單輸入建檔<ul><li>保單資料資料輸入</li><li>銀行資料等支付資料輸入</li><li>照會檢查</li></ul></li><li>建當輸入審核<ul><li>有問題發送照會，依內容決定是否退回處理</li></ul></li><li>結案</li></ol><h2 id="照會-這個名詞是說在流程中遇到問題，需通知業務員是什麼問題"><a href="#照會-這個名詞是說在流程中遇到問題，需通知業務員是什麼問題" class="headerlink" title="照會(這個名詞是說在流程中遇到問題，需通知業務員是什麼問題)"></a>照會(這個名詞是說在流程中遇到問題，需通知業務員是什麼問題)</h2><ul><li>照會發送</li><li>照會處理(解照會)</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;壽險業簡易系統設計Domain knowledge描述，大概整理個通則。&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
  <entry>
    <title>Web開發常用工具</title>
    <link href="https://hand79.github.io/Blog/posts/Development/20210127-java-web-tool.html"/>
    <id>https://hand79.github.io/Blog/posts/Development/20210127-java-web-tool.html</id>
    <published>2021-01-27T11:47:30.000Z</published>
    <updated>2021-01-27T12:01:07.779Z</updated>
    
    <content type="html"><![CDATA[<p>工作整理常用、過去使用過的文件網站與相關工具整理</p><a id="more"></a><h2 id="Java-相關"><a href="#Java-相關" class="headerlink" title="Java 相關"></a>Java 相關</h2><p><a href="https://spring.io/projects/spring-boot" target="_blank" rel="noopener">Spring 相關文件官網</a><br><a href="https://hibernate.org/" target="_blank" rel="noopener">Hibernate 官網</a><br><a href="https://www.oracle.com/tw/java/technologies/javase/javase-jdk8-downloads.html" target="_blank" rel="noopener">Oracle JDK</a><br><a href="https://poi.apache.org/apidocs/index.html" target="_blank" rel="noopener">Apache POI</a><br><a href="https://mybatis.org/mybatis-3/zh/index.html" target="_blank" rel="noopener">mybatis 官網</a><br><a href="https://www.thymeleaf.org/documentation.html" target="_blank" rel="noopener">Thymeleaf Doc</a><br><a href="https://www.thymeleaf.org/ecosystem.html" target="_blank" rel="noopener">Thymeleaf Plugin</a><br><a href="https://docs.oracle.com/javaee/5/tutorial/doc/bnake.html" target="_blank" rel="noopener">JSTL Oracle doc</a><br><a href="https://docs.oracle.com/javaee/5/jstl/1.1/docs/tlddocs/" target="_blank" rel="noopener">JSTL Oracle doc (tld doc)</a><br><a href="https://howtodoinjava.com/" target="_blank" rel="noopener">Java 教學(英文)</a></p><h2 id="HTML-JavaScript-CSS相關"><a href="#HTML-JavaScript-CSS相關" class="headerlink" title="HTML, JavaScript, CSS相關"></a>HTML, JavaScript, CSS相關</h2><p><a href="https://www.w3schools.com/js/default.asp" target="_blank" rel="noopener">W3C (JavaScript)</a><br><a href="https://www.w3schools.com/css/default.asp" target="_blank" rel="noopener">W3C (CSS)</a><br><a href="https://www.w3schools.com/html/default.asp" target="_blank" rel="noopener">W3C (HTML)</a><br><a href="https://www.w3school.com.cn/html5/index.asp" target="_blank" rel="noopener">W3C.cn (HTML5)</a><br><a href="https://developer.mozilla.org/en-US/docs/Web" target="_blank" rel="noopener">MDN Web Docs 英文 (Web APIs)</a><br><a href="https://developer.mozilla.org/zh-TW/docs/Web" target="_blank" rel="noopener">MDN Web Docs 中文 (Web APIs)</a><br><a href="https://api.jquery.com/" target="_blank" rel="noopener">jQuery doc 文件</a><br><a href="https://oscarotero.com/jquery/" target="_blank" rel="noopener">jQuery API 快找</a><br><a href="https://sapui5.hana.ondemand.com/#/api" target="_blank" rel="noopener">SAPUI5 文件</a><br><a href="https://www.jeasyui.com/documentation/index.php" target="_blank" rel="noopener">Easy UI 文件</a><br><a href="https://getbootstrap.com/" target="_blank" rel="noopener">Bootstrap 官網</a><br><a href="https://www.w3schools.com/bootstrap/bootstrap_ver.asp" target="_blank" rel="noopener">w3c Bootstrap 教學</a><br><a href="https://startbootstrap.com/" target="_blank" rel="noopener">Bootstrap 樣板網</a><br><a href="https://datatables.net/" target="_blank" rel="noopener">datatables 表單外掛</a><br><a href="https://fontawesome.com/icons?d=gallery" target="_blank" rel="noopener">Fontawesome UI icon</a><br><a href="https://caniuse.com/" target="_blank" rel="noopener">caniuse (查詢js api在各家的瀏覽器相容性)</a><br><a href="https://www.oxxostudio.tw/articles/201501/css-flexbox.html" target="_blank" rel="noopener">Flex box 教學(RWD &amp;&amp; CSS3)</a><br><a href="https://www.w3schools.com/css/css3_mediaqueries.asp" target="_blank" rel="noopener">@Media 不同裝置的CSS設計 </a></p><h2 id="開發工具"><a href="#開發工具" class="headerlink" title="開發工具"></a>開發工具</h2><p><a href="https://dbeaver.io/" target="_blank" rel="noopener">DBeaver DB工具</a><br><a href="https://www.eclipse.org/downloads/" target="_blank" rel="noopener">Eclispe 官網</a><br><a href="https://spring.io/tools" target="_blank" rel="noopener">STS (Eclispe 與 Spring 整合開發工具)</a><br><a href="https://www.itread01.com/content/1546159175.html" target="_blank" rel="noopener">Mybatis generator的使用教學</a><br><a href="https://docs.gradle.org/current/userguide/userguide.html" target="_blank" rel="noopener">Gradle 官網</a><br><a href="https://www.w3cschool.cn/gradle/" target="_blank" rel="noopener">Gradle 教學網</a><br><a href="https://maven.apache.org/download.cgi" target="_blank" rel="noopener">Maven 官網</a><br><a href="https://www.w3cschool.cn/maven/tkhr1ht6.html" target="_blank" rel="noopener">Maven 教學網</a><br><a href="https://staruml.io/" target="_blank" rel="noopener">StarUML</a><br><a href="https://www.webtoolkitonline.com/" target="_blank" rel="noopener">web toolkit online(綜合工具)</a></p><h2 id="測試工具"><a href="#測試工具" class="headerlink" title="測試工具"></a>測試工具</h2><p><a href="https://regex101.com/" target="_blank" rel="noopener">Regular Expression 線上驗證工具</a><br><a href="https://www.telerik.com/download/fiddler" target="_blank" rel="noopener">Fiddler</a><br><a href="https://jmeter.apache.org/download_jmeter.cgi" target="_blank" rel="noopener">JMeter</a><br><a href="https://www.postman.com/downloads/" target="_blank" rel="noopener">Postman</a><br><a href="http://dog0416.blogspot.com/2017/06/stress-test-jmeter-beanshell.html" target="_blank" rel="noopener">BeanShell JMeter教學</a><br><a href="https://topic.alibabacloud.com/tc/a/jmeter-bean-shell-use-full_1_28_20186532.html" target="_blank" rel="noopener">BeanShell JMeter使用</a><br><a href="http://sikulix.com/quickstart/" target="_blank" rel="noopener">SikuliX (圖形介面編寫腳本達到自動操作，基於Jython，須裝java &amp;&amp; Python)</a><br><a href="https://igouist.github.io/post/2020/03/sikulix/" target="_blank" rel="noopener">SikuliX (簡易解說)</a></p><h2 id="Linux"><a href="#Linux" class="headerlink" title="Linux"></a>Linux</h2><p><a href="http://linux.vbird.org/" target="_blank" rel="noopener">鳥哥</a><br><a href="http://linux.vbird.org/linux_basic/0320bash.php#variable_var" target="_blank" rel="noopener">鳥哥 BASH</a><br><a href="http://linux.vbird.org/linux_basic/0340bashshell-scripts.php" target="_blank" rel="noopener">鳥哥 Shell scripts</a><br><a href="https://www.centos.org/download/" target="_blank" rel="noopener">CentOS 官網</a><br><a href="https://ubuntu.com/download#download" target="_blank" rel="noopener">Ubuntu 官網</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;工作整理常用、過去使用過的文件網站與相關工具整理&lt;/p&gt;</summary>
    
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/categories/Development/"/>
    
    
    <category term="Development" scheme="https://hand79.github.io/Blog/tags/Development/"/>
    
  </entry>
  
</feed>
