[{"title":"Hexo與SEO","url":"/Blog/posts/Hexo/20201231-hexo-seo.html","content":"<p>寫到這邊才發現我忘了SEO這回事了，這邊寫個筆記。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"安裝-Hexo-外掛\"><a href=\"#安裝-Hexo-外掛\" class=\"headerlink\" title=\"安裝 Hexo 外掛\"></a>安裝 Hexo 外掛</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"config-yml檔案加入：\"><a href=\"#config-yml檔案加入：\" class=\"headerlink\" title=\"_config.yml檔案加入：\"></a>_config.yml檔案加入：</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">sitemap:</span><br><span class=\"line\">    path: sitemap.xml</span><br></pre></td></tr></table></figure>\n\n<p>hexo g -d，重新編譯發佈，以下網址驗證一下是否建出</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">https://hand79.github.io/Blog//sitemap.xml</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"提交至-Google-Search-Console\"><a href=\"#提交至-Google-Search-Console\" class=\"headerlink\" title=\"提交至 Google Search Console\"></a>提交至 Google Search Console</h3><ol>\n<li>打開 Google Search Console</li>\n<li>進入「索引 &gt; Sitemap」</li>\n<li>「新增 Sitemap」：sitemap.xml</li>\n</ol>\n<p>註: 若網站google-site-verification還沒處理，google會有幾個方案給你驗證網站的所有權，我選擇meta方案。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;meta name=<span class=\"string\">\"google-site-verification\"</span> content=<span class=\"string\">\"XXXXX\"</span> /&gt;</span><br></pre></td></tr></table></figure>","categories":["Hexo"],"tags":["Hexo"]},{"title":"Add Disqus","url":"/Blog/posts/Hexo/20201223-hexo-add-disqus-blog.html","content":"<p>Disqus留言板的添加</p>\n<a id=\"more\"></a>\n\n<h2 id=\"處理流程\"><a href=\"#處理流程\" class=\"headerlink\" title=\"處理流程\"></a>處理流程</h2><p>. 先申請Disqus帳號<br>. 到後台管理區設定網址<br>. 複製提供的js程式碼，到需要用的位置(若本身Hexo就提供該功能可以省略，本文使用landscape)<br>. _config.yml 設定參數，主題若有其他參數需參考該主題</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">disqus_enabled: true</span><br><span class=\"line\">disqus_shortname: xxxx (Disqus後台設定的名稱)</span><br><span class=\"line\">disqus_count: true (計數)</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://disqus.com/\" target=\"_blank\" rel=\"noopener\">Disqus</a></p>\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Hexo設定permalink","url":"/Blog/posts/Hexo/20201223-hexo-permalink-blog.html","content":"<p>版本: Hexo 4.20</p>\n<a id=\"more\"></a>\n\n<h2 id=\"config-yml\"><a href=\"#config-yml\" class=\"headerlink\" title=\"_config.yml\"></a>_config.yml</h2><p>. 用github為範例，{yourname}為名稱<br>. 主要是根節點的設定 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># URL</span><br><span class=\"line\">## If your site is put in a subdirectory, set url as &#39;http:&#x2F;&#x2F;yoursite.com&#x2F;child&#39; and root as &#39;&#x2F;child&#x2F;&#39;</span><br><span class=\"line\">url: https:&#x2F;&#x2F;&#123;yourname&#125;.github.io&#x2F;Blog&#x2F;</span><br><span class=\"line\">root: &#x2F;Blog&#x2F;</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://github.com/hexojs/hexo/issues/1812\" target=\"_blank\" rel=\"noopener\">舊版的問題</a><br>More info: <a href=\"https://hexo.io/docs/configuration.html\" target=\"_blank\" rel=\"noopener\">相關設定</a></p>\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Hexo鏈結的中文標題問題","url":"/Blog/posts/Hexo/20201223-hexo-permalink-blog.html","content":"<p>版本: Hexo 4.20</p>\n<a id=\"more\"></a>\n\n<h2 id=\"處理方式-config-yml修改\"><a href=\"#處理方式-config-yml修改\" class=\"headerlink\" title=\"處理方式(_config.yml修改)\"></a>處理方式(_config.yml修改)</h2><p>. 用urlname處理，並在各文章添加其值。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">permalink: posts&#x2F;:category&#x2F;:year:month:day-:urlname.html</span><br><span class=\"line\">permalink_defaults:</span><br><span class=\"line\">  lang: en</span><br></pre></td></tr></table></figure>\n\n<p>. 套件處理</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-abbrlink --save</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># permalink: :year&#x2F;:month&#x2F;:day&#x2F;:title&#x2F;</span><br><span class=\"line\"># permalink_defaults:</span><br><span class=\"line\">permalink: posts&#x2F;:abbrlink.html</span><br><span class=\"line\">abbrlink:</span><br><span class=\"line\">  alg: crc32  # crc16(default) and crc32</span><br><span class=\"line\">  rep: hex    # dec(default) and hex</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://github.com/rozbo/hexo-abbrlink\" target=\"_blank\" rel=\"noopener\">hexo-abbrlink</a></p>\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Hexo與RSS","url":"/Blog/posts/Hexo/20201231-hexo-plugin-rss.html","content":"<p>Hexo的主題上面一直有這個東西沒弄，到最後手癢還是找了方法弄了一下。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"安裝-Hexo-外掛\"><a href=\"#安裝-Hexo-外掛\" class=\"headerlink\" title=\"安裝 Hexo 外掛\"></a>安裝 Hexo 外掛</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install --save hexo-generator-feed</span><br></pre></td></tr></table></figure>\n\n<p>_config.yml檔案加入：</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">plugins: hexo-generator-feed</span><br><span class=\"line\">rss: /atom.xml</span><br></pre></td></tr></table></figure>\n<p>hexo g之後執行發佈</p>\n<p>More info: <a href=\"https://zh.wikipedia.org/wiki/RSS\" target=\"_blank\" rel=\"noopener\">RSS是什麼?，參考wiki</a></p>\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Hexo與LocalSearch","url":"/Blog/posts/Hexo/20201231-hexo-localsearch.html","content":"<p>添加LocalSearch搜尋功能</p>\n<a id=\"more\"></a>\n<h2 id=\"安裝-hexo-generator-searchdb\"><a href=\"#安裝-hexo-generator-searchdb\" class=\"headerlink\" title=\"安裝 hexo-generator-searchdb\"></a>安裝 hexo-generator-searchdb</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"config-yml-設定\"><a href=\"#config-yml-設定\" class=\"headerlink\" title=\"_config.yml 設定\"></a>_config.yml 設定</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">search:</span><br><span class=\"line\">  path: search.json</span><br><span class=\"line\">  field: post</span><br><span class=\"line\">  format: html</span><br><span class=\"line\">  limit: 10000</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"啟用Local搜索功能：\"><a href=\"#啟用Local搜索功能：\" class=\"headerlink\" title=\"啟用Local搜索功能：\"></a>啟用Local搜索功能：</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Local search</span><br><span class=\"line\">local_search:</span><br><span class=\"line\">  enable: true</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Tag 與 Category設定","url":"/Blog/posts/Hexo/20200223-hexo-tag-category.html","content":"<p>文章的Tag 與 Category設定</p>\n<a id=\"more\"></a>\n\n<h3 id=\"config-yml-內容設定\"><a href=\"#config-yml-內容設定\" class=\"headerlink\" title=\"_config.yml 內容設定\"></a>_config.yml 內容設定</h3><p>blog 資料夾下 _config.yml設定。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">default_category: uncategorized</span><br><span class=\"line\">category_map:</span><br><span class=\"line\">  Hexo: Hexo</span><br><span class=\"line\"> </span><br><span class=\"line\">tag_map: </span><br><span class=\"line\">  Hexo: Hexo</span><br></pre></td></tr></table></figure>\n\n<p>.md 檔中加入設定再發布，就可以看效果。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">categories: Hexo</span><br><span class=\"line\">tags: [Hexo]</span><br></pre></td></tr></table></figure>\n\n\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"AS400程式版控流程規劃","url":"/Blog/posts/Development/20230115-as400-version-control-system-design.html","content":"<p>最些與AS400程式版控流程規劃的紀錄，但可以針對一些類似的規則使用。<br>針對一些無法在本機上進行編譯、但又需要一些原因(例如:稽核)必須導入版控的流程設計，作為參考。<br><img src=\"https://drive.google.com/uc?id=1-3zER2WIQbKHzOv9Hy1XM2ub6FKr-C6F\" alt=\"初步需求\"></p>\n<a id=\"more\"></a>\n\n<p>後續依需求陸續加入到流程規劃中，例如Jenkins、JIRA等服務。</p>\n<p>參考: <a href=\"https://www.arcadsoftware.com/products/arcad-for-devops/\" target=\"_blank\" rel=\"noopener\">ARCAD for DevOps for IBM i</a><br>參考: <a href=\"https://qiita.com/tomotagwork/items/0b25bbb9a72e37f4d98c\" target=\"_blank\" rel=\"noopener\">Jenkins - z/OS</a><br>參考: <a href=\"https://www.imagazine.co.jp/ibm-i%E3%81%AE%E5%9F%BA%E5%B9%B9%E3%82%B7%E3%82%B9%E3%83%86%E3%83%A0%E9%96%8B%E7%99%BA%E3%81%AB%E3%82%82%E3%81%93%E3%82%8C%E3%81%8B%E3%82%89%E3%81%AFdevops%E3%82%A2%E3%83%97%E3%83%AD%E3%83%BC%E3%83%81/\" target=\"_blank\" rel=\"noopener\">IBM iで利用可能な DevOpsツール</a><br>參考: <a href=\"https://www.imagazine.co.jp/ibm-i%E3%81%AE%E3%83%93%E3%83%AB%E3%83%89%E7%AE%A1%E7%90%86%E3%80%80%EF%BD%9Eibm-i%E3%81%A7jenkins%E3%82%92%E4%BD%BF%E3%81%86%E3%80%81%E3%82%AA%E3%83%BC%E3%83%97%E3%83%B3%E3%82%BD%E3%83%BC%E3%82%B9/\" target=\"_blank\" rel=\"noopener\">IBM iのビルド管理　～IBM iでJenkinsを使う、オープンソースベースの標準的なビルド管理</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"Domain-Driven Design (DDD)","url":"/Blog/posts/Development/20210217-domain-driven-design.html","content":"<p>閱讀DDD相關文章重點整理。</p>\n<a id=\"more\"></a> \n\n<h2 id=\"Domain-Driven-Design\"><a href=\"#Domain-Driven-Design\" class=\"headerlink\" title=\"Domain-Driven Design\"></a>Domain-Driven Design</h2><p>價值: 把將商業領域的知識映照到程式碼中，解放「程式歸程式，業務歸業務」的傳統思維</p>\n<h2 id=\"模型中有以下概念\"><a href=\"#模型中有以下概念\" class=\"headerlink\" title=\"模型中有以下概念\"></a>模型中有以下概念</h2><ul>\n<li>上下文（Context）: 詞或句子出現的位置。</li>\n<li>領域（Domain）: 知識，影響，或活動。客戶使用軟體要處理旳問題種類即為軟體的領域。</li>\n<li>模型（Model）: 一類描述域的不同方面並可用於解決相關問題的系統化的抽象。</li>\n<li>統一術語（Ubiquitous Language）: 一種團隊成員使用，為了描述域模型而構造的語言。 用於如下:<ul>\n<li>User story 或RFC</li>\n<li>任意的會議</li>\n<li>書信往來</li>\n<li>技術文件</li>\n<li>流程或是行程</li>\n<li>程式碼</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Building-blocks\"><a href=\"#Building-blocks\" class=\"headerlink\" title=\"Building blocks\"></a>Building blocks</h2><p>在領域驅動設計一書中[2]闡述了一些高層次的概念和實踐，比如通用語言，這意味著領域模型應該形成領域專家為描述系統需求而提供的共同語言，同樣的，這些語言也需要能夠被商業使用者或贊助商和軟體開發商使用。本書專注於將領域層描述為具有多層體系結構的物件導向系統中的常見層次之一。在 DDD 中，有表示，建立和檢索域模型的工件：</p>\n<ul>\n<li>Entity: 一個不由自身屬性定義而是由標識線和它的身分定義的物件。<br>例如：大多數航空公司在每次航班上都獨特地區分每個座位。每個席位都是在這種情況下的一個實體。不過，西南航空，EasyJet 和瑞安航空並沒有區分每個座位；所有的座位都是一樣的。在這種情況下，一個席位實際上是一個Value Object</li>\n<li>Value Object: 只包含元素屬性的不可變物件。<br>例如：當人們交換名片時，他們一般不會區分每張獨特的名片；他們只關心印在卡片上的資訊。在這種情況下，名片是 Value Object</li>\n<li>Service: 強調與其他物件的關係，只定義了可以為客戶做什麼，不應該替代 Entity 和 Value Object 的所有行為。</li>\n<li>Module: 一種表達機制，劃分代碼和概念。</li>\n<li>Factory: 對於那些需要建立特定域物件的方法應該委派給工廠物件，因為這樣可以更容易的替換實現。</li>\n<li>Repository: 對於檢索特定域物件的方法應該委派給 Repository 物件，因為這樣可以很容易地互換替代儲存的實現。</li>\n<li>Aggregate: 由 ROOT ENTITY 繫結在一起的物件的集合，也稱為聚合根。聚合根通過禁止外部物件保持對其成員的參照來保證在聚合內進行的更改的一致性。<br>例如：駕駛汽車時，不必擔心向前移動車輪，使發動機燃燒火花和燃料等。你只是在開車。在這種情況下，汽車是其他幾個物件的集合，並作為所有其他系統的聚合根</li>\n<li>Domain Event: 一個域物件定義了一個事件。域事件是域專家所關心的事件。</li>\n</ul>\n<h2 id=\"貧血模型-Anemic-Model\"><a href=\"#貧血模型-Anemic-Model\" class=\"headerlink\" title=\"貧血模型 (Anemic Model)\"></a>貧血模型 (Anemic Model)</h2><p>特徵:<br>其中包含物件，許多物件會以領域空間中的名詞來命名，而且這些物件會透過真實領域模型所具有的豐富關聯性和結構來連接。<br>從行為上會看出端倪，並了解這些物件上幾乎沒有任何行為，比較像是一組 getter 和 setter。<br>使用 Anemic 領域模型時，會從一組擷取所有領域或商務邏輯的服務物件 (service，傳統上稱為「商務層」**) 來使用這些資料模型。 商務層位於資料模型最上層，其使用資料模型的方式就像是資料一樣。</p>\n<p>重點節錄(來自微軟)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Anemic 領域模型只是程序樣式設計。 Anemic 實體物件不是真正的物件，因為它們缺少行為 (方法)。</span><br><span class=\"line\">它們只會保存資料屬性，因此不是物件導向設計。</span><br><span class=\"line\"></span><br><span class=\"line\">藉由將所有的行為放入服務物件（商務層）中，您基本上會得到spaghetti 程式碼或交易腳本，</span><br><span class=\"line\">因此您會失去領域模型所提供的優點。</span><br><span class=\"line\"></span><br><span class=\"line\">即便如此，如果您的微服務或限定內容很簡單 (CRUD 服務)，只有資料屬性之實體物件形式的 Anemic 領域模型便已足夠，</span><br><span class=\"line\">而且可能不值得實作更複雜的 DDD 模式。 在此情況下，它只是持續性模型，因為您刻意建立只有 CRUD 用途資料的實體。</span><br><span class=\"line\"></span><br><span class=\"line\">這就是為什麼微服務架構對於根據每個限定內容之多架構方法很理想的原因。 </span><br><span class=\"line\">例如，在 eShopOnContainers 中，</span><br><span class=\"line\">訂購微服務會實作 DDD 模式，但目錄微服務是簡易 CRUD 服務，因此不會實作此模式。</span><br><span class=\"line\">它其實取決於您實作的內容。 如果您要建立的微服務夠簡單 (例如 CRUD 服務)，遵循 Anemic 領域模型就不是反模式。</span><br><span class=\"line\"></span><br><span class=\"line\"> 不過，如果您需要處理微服務網域的複雜性，</span><br><span class=\"line\"> 而此領域有許多不斷改變的商務規則，則 anemic 領域模型可能是該微服務或限定內容的反模式。</span><br><span class=\"line\"> 在此情況下，將它設計為具有實體的豐富模型可能會相當有利於這類微服務的長期成功，</span><br><span class=\"line\"> 因為這些實體包含資料加上行為，並實作額外的 DDD 模式 (彙總、值物件等)。</span><br></pre></td></tr></table></figure>\n\n<p><img src=\"https://img-blog.csdn.net/20171108161155976?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHJvdWJsZXNob290ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"Anemic Model \"></p>\n<h2 id=\"豐富領域模型-Rich-Domain-Model\"><a href=\"#豐富領域模型-Rich-Domain-Model\" class=\"headerlink\" title=\"豐富領域模型(Rich Domain Model)\"></a>豐富領域模型(Rich Domain Model)</h2><p><img src=\"https://img-blog.csdn.net/20171108161246317?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdHJvdWJsZXNob290ZXI=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center\" alt=\"Rich Domain Model \"></p>\n<p>架構參考:</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/95ed0cc001e94a8ba9f32666113169c9.png\" alt=\"傳統架構 \"></p>\n<p>架構轉成DDD</p>\n<p><img src=\"https://ucc.alicdn.com/pic/developer-ecology/d92764a7963f43068273133f9a1ac6f9.png\" alt=\"DDD 之後\"></p>\n<h2 id=\"閱讀參考\"><a href=\"#閱讀參考\" class=\"headerlink\" title=\"閱讀參考\"></a>閱讀參考</h2><p>程式架構:<br><a href=\"https://developer.aliyun.com/article/716908\" target=\"_blank\" rel=\"noopener\">阿里技术专家详解 DDD 系列- Domain Primitive</a><br><a href=\"https://developer.aliyun.com/article/719251\" target=\"_blank\" rel=\"noopener\">阿里技术专家详解DDD系列 第二弹 - 应用架构</a><br><a href=\"https://juejin.cn/post/6845166890554228744\" target=\"_blank\" rel=\"noopener\">阿里技术专家详解DDD系列 第三讲 - Repository模式 </a><br><a href=\"https://mp.weixin.qq.com/s?__biz=MzAxNDEwNjk5OQ==&mid=2650414919&idx=1&sn=0ad1df1a1b0e2488f7faa21008fdbdd0&chksm=8396d75fb4e15e49341b07022780dcb8dca66a0efb7f129d4de86a5ef5d8a890f6e0d2fd6432&scene=132#wechat_redirect\" target=\"_blank\" rel=\"noopener\">DDD系列第四讲：领域层设计规范 </a></p>\n<p>其他:<br><a href=\"https://blog.csdn.net/troubleshooter/article/details/78479984\" target=\"_blank\" rel=\"noopener\">什么是领域模型(domain model)？贫血模型(anaemic domain model)和充血模型(rich domain model)有什么区别？</a><br><a href=\"https://blog.csdn.net/johnstrive/article/details/16805121?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-6.control\" target=\"_blank\" rel=\"noopener\">领域模型驱动设计（Domain Driven Design）入门概述</a><br><a href=\"https://blog.csdn.net/iteye_3055/article/details/82106174?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.control&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-7.control\" target=\"_blank\" rel=\"noopener\">领域驱动设计(Domain Driven Design)参考架构详解</a><br><a href=\"https://docs.microsoft.com/zh-tw/dotnet/architecture/microservices/microservice-ddd-cqrs-patterns/microservice-domain-model\" target=\"_blank\" rel=\"noopener\">微服務 - 架構電子書 (微軟) - 設計微服務領域模型</a><br><a href=\"https://ithelp.ithome.com.tw/articles/10216645\" target=\"_blank\" rel=\"noopener\">關於 Domain-Driven Design 以及他的魅力　(這個上面寫的程式範例不太好，看其他文章範例)</a><br><a href=\"https://medium.com/tradeshift-engineering/my-vision-as-a-software-engineer-about-ddd-domain-driven-design-part-2-973bcf5a9848\" target=\"_blank\" rel=\"noopener\">My vision, as a Software Engineer, about DDD (Domain Driven Design) — Part 2 (Java 為範例)</a><br><a href=\"https://hackmd.io/@ballfish/DDD\" target=\"_blank\" rel=\"noopener\">Domain Driven Design</a><br><a href=\"https://www.cnblogs.com/daoqidelv/p/7648392.html\" target=\"_blank\" rel=\"noopener\">【DDD】领域驱动设计实践 —— Domain层实现</a><br><a href=\"https://t.codebug.vip/questions-2083339.htm\" target=\"_blank\" rel=\"noopener\">DDD 程式設計範例討論</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"CI/CD 相關內容概念","url":"/Blog/posts/Development/20210107-CI-CD.html","content":"<p>概念解釋。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Continuous-integration-CI，持續性整合\"><a href=\"#Continuous-integration-CI，持續性整合\" class=\"headerlink\" title=\"Continuous integration(CI，持續性整合)\"></a>Continuous integration(CI，持續性整合)</h3><ul>\n<li>將開發人員對應用程序的更改被合併，系統將會通過自動生成應用並運行不同級別的自動化測試（通常是單元測試和整合測試）來驗證，確保這些更改沒有對程式功能造成破壞。測試內容涵蓋了從類和函數到構成整個應用的不同模塊。如果自動化測試發現新代碼和現有代碼之間存在衝突，可以更加輕鬆地快速修復這些錯誤。     </li>\n<li>目的: 完成各程式碼的整合。應用程序的新更改會定期構建，測試並合併到共享存儲庫中，解決在一次開發中有太多應用分支，從而導致相互衝突的問題。</li>\n</ul>\n<h3 id=\"Continuous-Delivery-CD，持續性交付\"><a href=\"#Continuous-Delivery-CD，持續性交付\" class=\"headerlink\" title=\"Continuous Delivery(CD，持續性交付)\"></a>Continuous Delivery(CD，持續性交付)</h3><ul>\n<li>完成CI中生成及單元測試和整合測試的自動化流程後，持續交付可自動將已驗證的程式碼發佈到存儲庫。為了實現高效的持續交付流程，必須確保CI已內置於開發管道。</li>\n<li>目的: 是擁有一個可隨時部署到生產環境的程式庫。</li>\n</ul>\n<h3 id=\"Continuous-Deployment-CD，持續性部署\"><a href=\"#Continuous-Deployment-CD，持續性部署\" class=\"headerlink\" title=\"Continuous Deployment(CD，持續性部署)\"></a>Continuous Deployment(CD，持續性部署)</h3><ul>\n<li>最後的階段是持續部署，自動部署到指定環境。</li>\n<li>目的: 自動將預定的程式版本發佈到程式碼存儲庫的延伸，自動將程式發佈到生產環境。</li>\n</ul>\n<h2 id=\"CI-CD總結\"><a href=\"#CI-CD總結\" class=\"headerlink\" title=\"CI/CD總結\"></a>CI/CD總結</h2><ul>\n<li>CI/CD 就是程式開發完畢後，把開發完成的程式碼進行測試與Code Review，通過後經過合併於主線(Main branch)後直接發佈上線(Prod, UAT等環境)，這樣的過程就是所謂的 CI/CD。</li>\n<li>CI/CD常用工具:    <ul>\n<li>GitLab CI</li>\n<li>Travis CI</li>\n<li>Bamboo (Atlassian家出的 CI)</li>\n<li>Circle CI</li>\n<li>Jenkins</li>\n<li>Ansible </li>\n</ul>\n</li>\n</ul>\n<p>*<em>流程參考 Redhat *</em><br><img src=\"https://www.redhat.com/cms/managed-files/ci-cd-flow-desktop_1.png\" alt=\"Redhat_CI_CD\"></p>\n<h3 id=\"Unit-Testing-單元測試\"><a href=\"#Unit-Testing-單元測試\" class=\"headerlink\" title=\"Unit Testing (單元測試)\"></a>Unit Testing (單元測試)</h3><ul>\n<li>針對程式中的模組來進行正確性檢驗的測試工作，一個單元的定義可以是單個程式、函式、過程等內容，作為一個單元。(對於物件導向程式設計，最小單元就是方法，包括基礎類別（超類）、抽象類、或者衍生類別（子類）中的方法。)</li>\n</ul>\n<h3 id=\"System-Integration-Testing-SIT，整合測試\"><a href=\"#System-Integration-Testing-SIT，整合測試\" class=\"headerlink\" title=\"System Integration Testing (SIT，整合測試)\"></a>System Integration Testing (SIT，整合測試)</h3><ul>\n<li>在單獨的軟體模組被合併作為一個組測試。在單元測試之後和在系統測試之前。整合測試在已經被單元測試檢驗後進行作為它的輸入，組織在更大的集合，和遞送，作為它的輸出，整合系統為系統測試做準備。</li>\n<li>目的: 整合測試的目的是校驗功能、效能和可靠性要求，配置在主設計專案中。</li>\n</ul>\n<h3 id=\"System-Testing-系統測試\"><a href=\"#System-Testing-系統測試\" class=\"headerlink\" title=\"System Testing (系統測試)\"></a>System Testing (系統測試)</h3><ul>\n<li>系統測試的涵蓋面很廣，主要包括功能測試、介面測試、可靠性測試、易用性測試、效能測試。 功能測試主要針對包括功能可用性、功能實現程度（功能流程&amp;業務流程、資料處理&amp;業務資料處理）方面測試。</li>\n<li>壓力測試與效能測試差異<ul>\n<li>壓力測試要求進行超過規定效能指標的測試。例如一個網站請求是100qps，壓力測試就要是採用120qps個同時請求的條件測試。<ul>\n<li>判斷準則： 系統能夠恢復、壓力過程中不要有明顯效能下降</li>\n</ul>\n</li>\n<li>效能測試是就是該系統的效能標準(eg. 80tps)</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Stress-Testing-壓力測試\"><a href=\"#Stress-Testing-壓力測試\" class=\"headerlink\" title=\"Stress Testing (壓力測試)\"></a>Stress Testing (壓力測試)</h3><ul>\n<li>測驗系統在當下的軟硬體環境下能夠承受的請求有多少，用來計算出系統的極限。</li>\n</ul>\n<h3 id=\"User-Acceptance-Testing-UAT，使用者驗收測試\"><a href=\"#User-Acceptance-Testing-UAT，使用者驗收測試\" class=\"headerlink\" title=\"User Acceptance Testing(UAT，使用者驗收測試)\"></a>User Acceptance Testing(UAT，使用者驗收測試)</h3><ul>\n<li>通常是由一般的使用者（通常這些使用者不瞭解軟體的具體邏輯，但對業務邏輯非常熟悉）進行的測試，因此是面向終端使用者的測試，結束後通常就可以佈署到正式環境了(Production)。</li>\n</ul>\n<p>###　其他</p>\n<ul>\n<li>TPS（每秒事務數）代表每秒執行的事務數量，由資料庫管理系統和用戶用於描述每秒鐘的資料庫操作數。例如，用戶每分鐘執行6個事務，TPS為6 / 60s = 0.10 TPS。</li>\n<li>QPS：Queries Per Second意思是「每秒查詢率」，是一台伺服器每秒能夠相應的”查詢次數”，是對一個特定的查詢伺服器在規定時間內所處理流量多少的衡量標準。<br>More info: <a href=\"https://kknews.cc/zh-tw/code/nax2lv3.html\" target=\"_blank\" rel=\"noopener\">相關參考1</a><br>More info: <a href=\"https://kknews.cc/news/zejoy8l.html\" target=\"_blank\" rel=\"noopener\">相關參考2</a></li>\n</ul>\n<p>More info: <a href=\"https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E6%95%B4%E5%90%88\" target=\"_blank\" rel=\"noopener\">Continuous integration(wiki)</a><br>More info: <a href=\"https://zh.wikipedia.org/wiki/%E6%8C%81%E7%BA%8C%E4%BA%A4%E4%BB%98\" target=\"_blank\" rel=\"noopener\">Continuous Delivery(wiki)</a><br>More info: <a href=\"https://www.redhat.com/zh/topics/devops/what-is-ci-cd\" target=\"_blank\" rel=\"noopener\">CI/CD(RedHat)</a><br>More info: <a href=\"https://zh.wikipedia.org/wiki/%E8%BD%AF%E4%BB%B6%E6%B5%8B%E8%AF%95#%E5%8E%8B%E5%8A%9B%E6%B5%8B%E8%AF%95%E4%B8%8E%E6%80%A7%E8%83%BD%E6%B5%8B%E8%AF%95\" target=\"_blank\" rel=\"noopener\">Software Testing(wiki)</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"建立Blog","url":"/Blog/posts/Hexo/20200222-hexo-bulid-blog.html","content":"<p>用Hexo + Node.js + Github 搭建簡易Blog</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><p>. 安裝 Node.js<br>. 安裝 Hexo Git</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>\n\n<p>. 安裝 Hexo - 使用 npm(須先安裝 Node.js)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ npm install hexo-cli -g</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Create\"><a href=\"#Create\" class=\"headerlink\" title=\"Create\"></a>Create</h3><figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo init blog    <span class=\"comment\"># 初始化 blog</span></span><br><span class=\"line\">$ <span class=\"built_in\">cd</span> blog           <span class=\"comment\"># 移動到剛創建的 blog 資料夾裡</span></span><br><span class=\"line\">$ npm install\t\t<span class=\"comment\"># 安裝相關套件</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Github-新建一個倉庫\"><a href=\"#Github-新建一個倉庫\" class=\"headerlink\" title=\"Github 新建一個倉庫\"></a>Github 新建一個倉庫</h3><p>. 倉庫名稱為 yourname</p>\n<h3 id=\"blog-資料夾-內容設定\"><a href=\"#blog-資料夾-內容設定\" class=\"headerlink\" title=\"blog 資料夾 內容設定\"></a>blog 資料夾 內容設定</h3><p>再來到 blog 資料夾下找一個 _config.yml 開啟(root路徑設定為 “/repository/“，沒設定好css、js會抓不到)</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">url: https://yourname.github.io</span><br><span class=\"line\">root: /Blog/</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">deploy:</span><br><span class=\"line\">  <span class=\"built_in\">type</span>: git</span><br><span class=\"line\">  repository: http://github.com/yourname/yourname.github.io.git</span><br><span class=\"line\">  branch: master</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"產生靜態文件和deploy-上-GitHub\"><a href=\"#產生靜態文件和deploy-上-GitHub\" class=\"headerlink\" title=\"產生靜態文件和deploy 上 GitHub\"></a>產生靜態文件和deploy 上 GitHub</h3><p>. clean 清除快取檔案 (db.json) 和已產生的靜態檔案 (public)。<br>. d是佈署<br>. g產生靜態文件</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">$ hexo d -g</span><br></pre></td></tr></table></figure>\n<p>More info: <a href=\"https://hexo.io/zh-tw/docs/commands.html\" target=\"_blank\" rel=\"noopener\">Commands</a></p>\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"文章時間設定","url":"/Blog/posts/Hexo/20200223-article-date-time-config.html","content":"<p>文檔搬遷時，由於時間顯示都是文章檔案建立的時間，因此需做一點設定。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"config-yml-內容設定\"><a href=\"#config-yml-內容設定\" class=\"headerlink\" title=\"_config.yml 內容設定\"></a>_config.yml 內容設定</h3><p>blog 資料夾下 _config.yml，台灣時間作範例。</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">timezone: Asia/Taipei</span><br><span class=\"line\"></span><br><span class=\"line\">date_format: YYYY-MM-DD HH:mm:ss </span><br><span class=\"line\">time_format: HH:mm:ss</span><br></pre></td></tr></table></figure>\n\n<p>.md 檔中加入date，就會是指定文章的時間了</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\">date: 2020-02-23 19:00:00</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://en.wikipedia.org/wiki/List_of_tz_database_time_zones\" target=\"_blank\" rel=\"noopener\">時區參考</a></p>\n","categories":["Hexo"],"tags":["Hexo"]},{"title":"Kubernetes 故障排除流程圖","url":"/Blog/posts/Development/20210131-kubernetes.html","content":"<p>討論區看到的，留個記錄，某天遇上了可以參考。</p>\n<a id=\"more\"></a>\n\n<p>*<em>Kubernetes 故障排除流程圖 參考 *</em><br><img src=\"https://learnk8s.io/a/7d3cde9ddb57e4246215de4be2f3dd71.png\" alt=\"k8s\"></p>\n<p>more info:<a href=\"https://learnk8s.io/troubleshooting-deployments?fbclid=IwAR1q4Wu7GLSmmPlX7ooMK3W4lccZjwsqkygECROsyyvBe_o6YVv26Lz9PX4\" target=\"_blank\" rel=\"noopener\">資料出處</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"Java Ftp(透過跳板)","url":"/Blog/posts/uncategorized/20230511-java-ftp-proxy.html","content":"<p>FTP透過跳板的概念與參考整理。</p>\n<a id=\"more\"></a>\n\n\n<h3 id=\"一般FTP-連線\"><a href=\"#一般FTP-連線\" class=\"headerlink\" title=\"一般FTP 連線\"></a>一般FTP 連線</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Request ---&gt;  FTP Server</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"一般FTP-連線-透過跳板\"><a href=\"#一般FTP-連線-透過跳板\" class=\"headerlink\" title=\"一般FTP 連線(透過跳板)\"></a>一般FTP 連線(透過跳板)</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Request ---&gt; Jump Server ---&gt; FTP Server</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"實作參考-dependency-jsch\"><a href=\"#實作參考-dependency-jsch\" class=\"headerlink\" title=\"實作參考(dependency: jsch)\"></a>實作參考(dependency: jsch)</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"> private static Session getJschSession(String username, String password, String host, int port) &#123;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">            JSch jsch &#x3D; new JSch();</span><br><span class=\"line\">            Session jschSession &#x3D; jsch.getSession(username, host);</span><br><span class=\"line\">            jschSession.setPassword(password);</span><br><span class=\"line\">            jschSession.setPort(port);</span><br><span class=\"line\">            Properties sessionConfig &#x3D; new Properties();</span><br><span class=\"line\">            sessionConfig.put(&quot;StrictHostKeyChecking&quot;, &quot;no&quot;);</span><br><span class=\"line\">            jschSession.setConfig(sessionConfig);</span><br><span class=\"line\">            return jschSession;</span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            log.error(&quot;Exception: &#123;&#125;&quot;, e);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        return null;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">   </span><br><span class=\"line\">    public static void deployByJump(PathfinderProperties prop, List&lt;CompileOrder&gt; deployList) &#123;</span><br><span class=\"line\">        Date now &#x3D; new Date();</span><br><span class=\"line\">        String deployPath &#x3D; prop.getDeployPath();</span><br><span class=\"line\">        String deployBackupFolder &#x3D; dateFormatToString(now, &quot;yyyyMMddHHmmss&quot;); &#x2F;&#x2F; test</span><br><span class=\"line\">        Session jumpSession &#x3D; null;</span><br><span class=\"line\">        Session sftpSession &#x3D; null;</span><br><span class=\"line\">        ChannelSftp ftp &#x3D; null;</span><br><span class=\"line\">        try &#123;</span><br><span class=\"line\">        \t   &#x2F;&#x2F; 先連線跳板</span><br><span class=\"line\">            jumpSession &#x3D; getJschSession(prop.getJumpUserId(), prop.getJumpPassword(), prop.getJumpServer(), 22);</span><br><span class=\"line\">            jumpSession.connect();</span><br><span class=\"line\">            int portForwarding &#x3D; 2222;</span><br><span class=\"line\">            jumpSession.setPortForwardingL(2222, prop.getFtpServer(), 22); &#x2F;&#x2F; 在該台綁定一個port</span><br><span class=\"line\">            </span><br><span class=\"line\">            &#x2F;&#x2F; 透過這個port轉送</span><br><span class=\"line\">            sftpSession &#x3D; getJschSession(prop.getFtpUserId(), prop.getFtpPassword(), &quot;localhost&quot;, portForwarding);</span><br><span class=\"line\">            sftpSession.connect();</span><br><span class=\"line\">            </span><br><span class=\"line\">            ftp &#x3D; (ChannelSftp) sftpSession.openChannel(&quot;sftp&quot;);</span><br><span class=\"line\">            ftp.connect();</span><br><span class=\"line\">&#x2F;&#x2F;            ftp.cd(deployPath); &#x2F;&#x2F; deployPath</span><br><span class=\"line\">            ftp.mkdir(deployBackupFolder);</span><br><span class=\"line\">            log.info(&quot;ftp.pwd():&#123;&#125;&quot;, ftp.pwd());</span><br><span class=\"line\"></span><br><span class=\"line\">        &#125; catch (Exception e) &#123;</span><br><span class=\"line\">            log.error(&quot;Exception: &#123;&#125;&quot;, e);</span><br><span class=\"line\">        &#125;finally &#123;</span><br><span class=\"line\">            if(sftpSession !&#x3D; null) &#123;</span><br><span class=\"line\">                jumpSession.disconnect();</span><br><span class=\"line\">                log.info(&quot;sftp session close.&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(ftp !&#x3D; null) &#123;</span><br><span class=\"line\">                ftp.quit();</span><br><span class=\"line\">                log.info(&quot;ftp quit.&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            if(jumpSession !&#x3D; null) &#123;</span><br><span class=\"line\">                jumpSession.disconnect();</span><br><span class=\"line\">                log.info(&quot;jump session close.&quot;);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\">    private static String dateFormatToString(Date date, String pattern) &#123;</span><br><span class=\"line\">        return new SimpleDateFormat(pattern).format(date);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n","tags":["Java"]},{"title":"Session, Cookie, JWT相關概念","url":"/Blog/posts/Web/20210104-jwt-session-cookie.html","content":"<p>概念整理。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Session\"><a href=\"#Session\" class=\"headerlink\" title=\"Session\"></a>Session</h3><ul>\n<li>原理: Client端連上Server時，Server會創建Session出來，Server向Client端瀏覽器傳送一個名為JSESSIONID的Cookie會以Cookie的形式傳回Client端，Session依據該Cookie來識別是否為同一使用者。<ul>\n<li>該Cookie為伺服器自動生成的，它的maxAge屬性一般為–1，表示僅當前瀏覽器內有效，關閉瀏覽器就會失效。</li>\n<li>Cookie被禁止時會以URL重寫的方式來處理，表現形式為http://…../xxx?jsessionid=xxxxx。</li>\n</ul>\n<ul>\n<li>常有的錯誤想法:<ul>\n<li>只要關閉瀏覽器，Session就消失了。沒有主動Call Server做登出的動作其實不會消除Session，Server會一直保留，因為Server這邊不會知道已經關閉瀏覽器了。會有這種錯覺，是大部分Session機制都使用Cookie來儲存Session id(瀏覽器上會看到jsessionid儲存這部分的資訊)， 而關閉瀏覽器後這個Session id就消失了，再次連線Server也就無法找到原來的Session。</li>\n<li>如果Server產生的Cookie被儲存或者使用某種手段改寫瀏覽器發出的HTTP請求頭，把原來的Session id傳送給Server，則再次開啟瀏覽器仍然能夠找到原來的Session。</li>\n<li>關閉瀏覽器不會導致Session被刪除，Server會為seesion設定了一個失效時間，當距離客戶端上一次使用Session的時間超過這個失效時間時，Server就可以認為Client端已經停止了活動，才會把Session刪除以節省儲存空間。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Cookie\"><a href=\"#Cookie\" class=\"headerlink\" title=\"Cookie\"></a>Cookie</h3><ul>\n<li>不可跨域，會綁單一域名。</li>\n<li>Cookie的maxAge決定著Cookie的有效期，單位為秒（Second)。</li>\n<li>如果maxAge為負數，則表示該Cookie僅在本瀏覽器視窗以及本視窗開啟的子視窗內有效，關閉視窗後該Cookie即失效。maxAge為負數的Cookie，為臨時性Cookie，不會被持久化，不會被寫到Cookie檔案中。Cookie資訊儲存在瀏覽器記憶體中，因此關閉瀏覽器該Cookie就消失了。Cookie預設的maxAge值為–1。</li>\n<li>如果maxAge為0，則表示刪除該Cookie。Cookie機制沒有提供刪除Cookie的方法，因此通過設定該Cookie即時失效實現刪除Cookie的效果。失效的Cookie會被瀏覽器從Cookie檔案或者記憶體中刪除。</li>\n<li>不希望Cookie在HTTP等非安全協議中傳輸，可以設定Cookie的secure屬性為true。瀏覽器只會在HTTPS和SSL等安全協議中傳輸此類Cookie。<ul>\n<li>secure屬性並不能對Cookie內容執行加密，因而不能保證絕對的安全性。若需要高安全性，需要在程式中對Cookie內容加密、解密，以防洩密。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Session和Cookie的主要區別\"><a href=\"#Session和Cookie的主要區別\" class=\"headerlink\" title=\"Session和Cookie的主要區別\"></a>Session和Cookie的主要區別</h3><ul>\n<li>安全性: Session比 Cookie安全<ul>\n<li>Session是儲存Server端。</li>\n<li>Cookie是儲存Client端，因此敏感資料不可放在這。</li>\n</ul>\n</li>\n<li>存取類型:<ul>\n<li>Cookie只支持存文字類型，想存其他類型的需做轉換(例: 用base64)。</li>\n<li>Session可以儲存任意數據類型。</li>\n</ul>\n</li>\n<li>儲存大小:<ul>\n<li>Cookie: 至多4k。</li>\n<li>Session: 遠高於Cookie，但過多的資料會佔用過多Server的資源。</li>\n</ul>\n</li>\n<li>效期:<ul>\n<li>Cookie: 關閉瀏覽器即失效、30天內有效與永久有效。通過設定Cookie的age屬性來實現。</li>\n<li>Session: 至多上限24小時，實務上預設是30分鐘。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"JWT-JSON-Web-Token\"><a href=\"#JWT-JSON-Web-Token\" class=\"headerlink\" title=\"JWT(JSON Web Token)\"></a>JWT(JSON Web Token)</h3><ul>\n<li>使用時機 :<ul>\n<li>跨域下的請求。</li>\n<li>一次性、時效短的請求。</li>\n<li>身份驗證單點登入(SSO)。</li>\n<li>Call Web API(eg. RESTful API)。</li>\n</ul>\n</li>\n<li>JWT 主要分為三段，個別為 Header、Payload 與 Signature，以.做區隔，每一段都是透過 Base64去編碼，中間的 payload中有敏感資料會加密。<br>Header.Payload.Signature<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c</span><br></pre></td></tr></table></figure></li>\n<li>資料結構:<ul>\n<li>Header</li>\n</ul>\n<ul>\n<li>一個JSON對象， alg屬性表示簽名的算法（algorithm），默認為HMAC SHA256（寫成HS256）； typ屬性表示該令牌（token）的類型（type），JWT令牌統一寫為JWT。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;alg&quot;: &quot;HS256&quot;, # 加密的方法: HMAC、SHA256、RSA等</span><br><span class=\"line\">  &quot;typ&quot;: &quot;JWT&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Payload<ul>\n<li>一個JSON對象，用於存放實際需要傳遞的資料。JWT規定了7個官方參數供選擇(建議但不強制使用)。</li>\n<li>實際上這裡是明文，不適合儲存敏感資料(例如:使用者帳號密碼)。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">iss (issuer)：發行人</span><br><span class=\"line\">exp (expiration time)：過期時間</span><br><span class=\"line\">sub (subject)：主题</span><br><span class=\"line\">aud (audience)：接收jwt的一方</span><br><span class=\"line\">nbf (Not Before)：定義在什麼時間之前，該jwt都是不可用的，生效時間</span><br><span class=\"line\">iat (Issued At)：簽發時間</span><br><span class=\"line\">jti (JWT ID)：編號， jwt的唯一身份標識，主要用來作為一次性token,從而迴避replay attack</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>Signature<ul>\n<li>針對Header與Payload產生，目的是防止資料竄改。</li>\n<li>指定一個secret，只有Server知道secret才知道，不可洩漏給用戶，然後使用 Header裡面指定的簽名演算法。</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">HMACSHA256(base64UrlEncode(header) + &quot;.&quot; + base64UrlEncode(payload),  secret)</span><br></pre></td></tr></table></figure>\n\n<p>Header、Payload 與 Signature之後用.串起來就是JWT，一般JWT放在HTTP的Authorization標頭中跟請求一起帶出去。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">Authorization: Bearer &lt;token&gt;</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li><p>安全的使用JWT:</p>\n<ul>\n<li>header: 確保指定唯一的decode algorithm。</li>\n<li>payload: 不放入密鑰或敏感數據、設置置過期時間(exp)不要太長、驗證部分聲明(iss、aud等關鍵參數)。</li>\n<li>signature: 密鑰的安全性(長度、密碼複雜度)、指定decode函數的簽名驗證等。</li>\n<li>開啟 Http only 防止Token被擷取，是常見的來 XSS防護方法之一。</li>\n<li>使用 Https 確保在授權的時候不會被竊取。</li>\n<li>用來加密的 Secret要保存在 Server不應外流 。</li>\n<li>replay attacks的問題可以多宣告 jti, exp處理。</li>\n<li>黑名單機制(針對使用不當或不明原因進行手動防禦機制)、刷新機制。</li>\n<li>Server端保有JWT權限的控制權(例如: 把JWT儲存Cache server中，移除及消除該JWT權限)。</li>\n<li>權限的授權與token分離(該token只是帳密認證過，擁有什麼權限依然掌握在Server這邊的設定)。</li>\n</ul>\n</li>\n<li><p>JWT vs Session 一些個人結論，認為都有可取之處:</p>\n<ul>\n<li>安全機制: JWT安全機制的細節較Session處理而言較為繁雜。</li>\n<li>擴展: JWT較為方便，不過Session這邊也有不少解決方案(硬體: F5, 軟體: nginx, AWS: ELB等方案，關鍵字: sticky session)。</li>\n</ul>\n</li>\n</ul>\n<h3 id=\"Single-sign-on-SSO\"><a href=\"#Single-sign-on-SSO\" class=\"headerlink\" title=\"Single sign-on (SSO)\"></a>Single sign-on (SSO)</h3><ul>\n<li>降低存取第三方網站的風險。</li>\n<li>減少相同身份重新輸入密碼所花費的時間。</li>\n<li>不同的使用者名稱和密碼組合衍生的問題(例如:忘記某一組帳號密碼)。</li>\n<li>跨域認證: 一般橫跨不同伺服器的架構上身份驗證Server是獨立出來，Single sign-on(SSO)的方式來處理。<ul>\n<li>Java類似的方案有:</li>\n</ul>\n<ul>\n<li>Java Spring + Redis(利用Cache server的特性， 使用Redis存入Session或JWT的方式，讓Redis管理其時效，不同AP可以從中取得相關訊息)。</li>\n</ul>\n</li>\n</ul>\n<p>More info: <a href=\"https://en.wikipedia.org/wiki/JSON_Web_Token\" target=\"_blank\" rel=\"noopener\">JSON Web Token(JWT)</a><br>More info: <a href=\"https://zh.wikipedia.org/wiki/Base64\" target=\"_blank\" rel=\"noopener\">Base64 編碼</a><br>More info: <a href=\"https://en.wikipedia.org/wiki/Single_sign-on\" target=\"_blank\" rel=\"noopener\">Single sign-on(SSO)</a><br>More info: <a href=\"https://zh.wikipedia.org/wiki/%E9%87%8D%E6%94%BE%E6%94%BB%E5%87%BB\" target=\"_blank\" rel=\"noopener\">Replay attack</a></p>\n","categories":["Web"],"tags":["Web"]},{"title":"Jenkins-實戰-bash script遠端不同帳號的問題.md","url":"/Blog/posts/Development/20230513-Jenkins-bash-script.html","content":"<p>一般情況規劃好，通常一個帳號ssh到不同伺服器就好了。但是就偏偏遇上沒權限動jenkins又要在腳本中需要不同帳號，還要在遠端切成root，留個記錄。</p>\n<p>備註: 請留意Jenkins，密碼參數會在console洩漏(Credentials 或 Mask Passwords處理)，注意權限管理上的問題。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Install-sshpass\"><a href=\"#Install-sshpass\" class=\"headerlink\" title=\"Install sshpass\"></a>Install sshpass</h3><p>sshpass –p 密碼 遠端要執行的指令</p>\n<h3 id=\"stdin-密碼輸入\"><a href=\"#stdin-密碼輸入\" class=\"headerlink\" title=\"stdin 密碼輸入\"></a>stdin 密碼輸入</h3><p>echo 密碼 | sudo -S  ls  –al</p>\n<h3 id=\"上述兩項搭配\"><a href=\"#上述兩項搭配\" class=\"headerlink\" title=\"上述兩項搭配\"></a>上述兩項搭配</h3><ul>\n<li>執行遠端登入並在遠端下sudo指令(利用stdin 密碼輸入sudo 需切換的帳號密碼)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sshpass –p 密碼   ssh user@host  &quot;echo 密碼 | sudo -S  ls  –al&quot;</span><br></pre></td></tr></table></figure>","categories":["Development"],"tags":["Development"]},{"title":"MVC模式 與 三層架構","url":"/Blog/posts/Development/20210202-mvc-tier.html","content":"<p>MVC與三層架構解釋整理。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"MVC模式（Model–view–controller）\"><a href=\"#MVC模式（Model–view–controller）\" class=\"headerlink\" title=\"MVC模式（Model–view–controller）\"></a>MVC模式（Model–view–controller）</h2><p>是軟體工程中的一種軟體架構模式，把軟體系統分為三個基本部分：</p>\n<ul>\n<li>模型（Model): 用於封裝與應用程式的業務邏輯相關的資料以及對資料的處理方法。「 Model 」有對資料直接存取的權力，例如對資料庫的存取。<ul>\n<li>「Model」不依賴「View」和「Controller」，也就是說， Model 不關心它會被如何顯示或是如何被操作。</li>\n<li>但是 Model 中資料的變化一般會通過一種重新整理機制被公布。為了實現這種機制，那些用於監視此 Model 的 View 必須事先在此 Model 上註冊，從而，View 可以了解在資料 Model 上發生的改變。（比如：觀察者模式（軟體設計模式））</li>\n</ul>\n</li>\n<li>視圖（View）:能夠實現資料有目的的顯示（理論上，這不是必需的）。在 View 中一般沒有程式上的邏輯。為了實現 View 上的重新整理功能，View 需要存取它監視的資料模型（Model），因此應該事先在被它監視的資料那裡註冊。 </li>\n<li>控制器（Controller）: 起到不同層面間的組織作用，用於控制應用程式的流程。它處理事件並作出回應。「事件」包括使用者的行為和資料 Model 上的改變。</li>\n</ul>\n<p>MVC模式在概念上強調 Model, View, Controller 的分離，各個模組也遵循著由 Controller 來處理訊息，Model 掌管資料來源，View 負責資料顯示的職責分離原則，因此在實作上，MVC 模式的 Framework 通常會將 MVC 三個部份分離實作：</p>\n<ul>\n<li>Model 負責資料存取，較現代的 Framework 都會建議使用獨立的資料物件 (DTO, POCO, POJO 等) 來替代弱型別的集合物件。資料存取的程式碼會使用 Data Access 的程式碼或是 ORM-based Framework，也可以進一步使用 Repository Pattern 與 Unit of Works Pattern 來切割資料來源的相依性。</li>\n<li>Controller 負責處理訊息，較高階的 Framework 會有一個預設的實作來作為 Controller 的基礎，例如 Spring 的 DispatcherServlet 或是 ASP.NET MVC 的 Controller 等，在職責分離原則的基礎上，每個 Controller 負責的部份不同，因此會將各個 Controller 切割成不同的檔案以利維護。</li>\n<li>View 負責顯示資料，這個部份多為前端應用，而 Controller 會有一個機制將處理的結果 (可能是 Model, 集合或是狀態等) 交給 View，然後由 View 來決定怎麼顯示。例如 Spring Framework 使用 JSP 或相應技術，ASP.NET MVC 則使用 Razor 處理資料的顯示。</li>\n</ul>\n<h2 id=\"三層架構-3-tier-architecture\"><a href=\"#三層架構-3-tier-architecture\" class=\"headerlink\" title=\"三層架構(3-tier architecture)\"></a>三層架構(3-tier architecture)</h2><p>是一種軟體抽象的層次結構，從”整個應用程式架構的角度”來區分為三層。 </p>\n<p>目的: 高內聚，低耦合的思想<br>優點: </p>\n<ul>\n<li>利於標準化</li>\n<li>降低層與層之間的依賴</li>\n<li>利於各層邏輯的復用，資源重用性好</li>\n<li>開發人員可以只關注整個結構中的其中某一層</li>\n<li>具有良好的開放性和可擴充性，維護和升級方便</li>\n<li>提高系統的安全性</li>\n</ul>\n<p>缺點: </p>\n<ul>\n<li>有時會導致連動的修改。</li>\n<li>如果在表現層中需要增加一個功能，為保證其設計符合分層式結構，可能需要在相應的商業邏輯層和資料存取層中都增加相應的程式碼。</li>\n<li>相對於不分層，降低了系統的性能。</li>\n<li>如果不採用分層式結構，很多業務可以直接造訪資料庫，以此獲取相應的數據，如今卻必須通過中間層來完成。</li>\n<li>增加了開發成本。</li>\n</ul>\n<p>分層:</p>\n<ul>\n<li>表現層（Presentation layer）：通俗講就是展現給使用者的介面，即使用者在使用一個系統的時候他的所見所得。</li>\n<li>業務邏輯層（Business Logic Layer）：針對具體問題的操作，也可以說是對資料層的操作，對資料業務邏輯處理。</li>\n<li>資料訪問層（Data Access Layer）：該層所做事務直接運算元據庫，針對資料的增添、移除、修改、查找等。</li>\n</ul>\n<p><img src=\"https://www.itsfun.com.tw/cacheimg/d7/ce/3cf976ce330db425f6eb1a22d824.jpg\" alt=\"3-tier architecture\"></p>\n<p><img src=\"https://qph.fs.quoracdn.net/main-qimg-91d0a36c056cce85cd3a941a730ef053\" alt=\"3-tier architecture-en\"></p>\n<h2 id=\"兩者的差異\"><a href=\"#兩者的差異\" class=\"headerlink\" title=\"兩者的差異\"></a>兩者的差異</h2><ul>\n<li>三層架構是一個分層式的軟件體系架構設計。 MVC是一個設計模式，它是根據項目的具體需求來決定是否適用於該項目。</li>\n<li>三層架構的目的著重點是”高內聚，低耦合”，即解耦。 MVC的目的則是實現Web系統的職能分工，即職責劃分。</li>\n<li>三層側重的是整體的一個解耦。 MVC側重的是web系統的解耦，即側重jsp和Servlet的一個解耦。</li>\n<li>三層架構的分層模式是典型的上下關系，上層依賴於下層。 MVC作為表現模式是不存在上下關系的，而是相互協作關系。</li>\n</ul>\n<p>more info:<a href=\"https://zh.wikipedia.org/wiki/MVC\" target=\"_blank\" rel=\"noopener\">MVC Wiki</a><br>more info:<a href=\"https://shunnien.github.io/2017/07/29/3-tier-and-mvc-introduction/\" target=\"_blank\" rel=\"noopener\">三層結構與 Asp.Net MVC 的簡介 Wiki</a><br>more info:<a href=\"https://www.itread01.com/content/1514351052.html\" target=\"_blank\" rel=\"noopener\">三層架構與MVC的區別</a><br>more info:<a href=\"https://www.itread01.com/content/1514351052.html\" target=\"_blank\" rel=\"noopener\">三層架構與MVC的區別</a><br>more info:[softwareengineering討論區]<a href=\"https://softwareengineering.stackexchange.com/questions/299836/difference-between-3-tier-architecture-and-mvc-model-view-controller-in-asp-n\" target=\"_blank\" rel=\"noopener\">https://softwareengineering.stackexchange.com/questions/299836/difference-between-3-tier-architecture-and-mvc-model-view-controller-in-asp-n</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"SOA架構 與 Microservice","url":"/Blog/posts/Development/20210204-microservice-soa.html","content":"<p>之前遇到問題查詢的資料，做個整理。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Service-Oriented-Architecture-SOA-服務導向架構\"><a href=\"#Service-Oriented-Architecture-SOA-服務導向架構\" class=\"headerlink\" title=\"Service Oriented Architecture(SOA) 服務導向架構\"></a>Service Oriented Architecture(SOA) 服務導向架構</h2><p>特性:</p>\n<ul>\n<li>針對某特定要求的輸出，該服務就是運作一項商業邏輯</li>\n<li>具有完備的特性（self-contained）</li>\n<li>消費者並不需要瞭解此服務的運作過程</li>\n<li>可能由底層其他服務組成</li>\n</ul>\n<p>原則:</p>\n<ul>\n<li>可重複使用、粒度、模組性、可組合型、物件化原件、構件化以及具互動操作性</li>\n<li>符合開放標準（通用的或行業的）</li>\n<li>服務的識別和分類，提供和發布，監控和跟蹤。</li>\n</ul>\n<h2 id=\"SOA-所解決的核心問題\"><a href=\"#SOA-所解決的核心問題\" class=\"headerlink\" title=\"SOA 所解決的核心問題\"></a>SOA 所解決的核心問題</h2><ul>\n<li>系統整合(技術層面)</li>\n<li>系統的服務化(技術層面)</li>\n<li>業務的服務化(是以業務驅動把一個 業務單元封裝成一項服務）</li>\n</ul>\n<p><img src=\"https://img-blog.csdnimg.cn/20181029125611787.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2x4X0Zyb2xm,size_27,color_FFFFFF,t_70\" alt=\"SOA\"></p>\n<h2 id=\"Microservices-微服務\"><a href=\"#Microservices-微服務\" class=\"headerlink\" title=\"Microservices 微服務\"></a>Microservices 微服務</h2><ul>\n<li>通過服務實現元件化</li>\n<li>按業務能力來劃分服務和開發團隊</li>\n<li>去中心化</li>\n<li>基礎設施自動化（devops、自動化部署）<br>與服務導向架構（Service-Oriented Architecture）不同，後者是整合各種業務的應用程式，但微服務只屬於一個應用程式。(強調單一業務組件化)</li>\n</ul>\n<h2 id=\"Microservices-特性\"><a href=\"#Microservices-特性\" class=\"headerlink\" title=\"Microservices 特性\"></a>Microservices 特性</h2><ul>\n<li>每個服務都容易被取代。</li>\n<li>服務是以能力來組織的，例如使用者介面、前端、推薦系統、帳單或是物流等。</li>\n<li>由於功能被拆成多個服務，因此可以由不同的程式語言、資料庫實作。</li>\n<li>架構是對稱而非分層（即生產者與消費者的關係）</li>\n</ul>\n<p><img src=\"http://www.45fan.com/uploads/allimg/190414/03110Jc9-1.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM2NTI1MzAw,size_16,color_FFFFFF,t_70\" alt=\"Microservices\"></p>\n<h2 id=\"Microservices-資料庫三種設計模式\"><a href=\"#Microservices-資料庫三種設計模式\" class=\"headerlink\" title=\"Microservices 資料庫三種設計模式\"></a>Microservices 資料庫三種設計模式</h2><ol>\n<li>每個服務都各有一個數據庫，同屬性的服務可共享同個資料庫。</li>\n<li>所有服務都共享同個資料庫，但是不同表格，並且不會跨域存取。</li>\n<li>每個服務都有自己的資料庫，就算是同屬性的也是，資料庫並不會共</li>\n</ol>\n<p>資料庫的可棄性:<br>實踐微服務架構中有許多的做法。但是其中一種的做法是將資料庫視作短期的儲存空間而不是長期的資料。因為他們可以在上線時從事件中心回覆，因此可以快速的從記憶體中快速存取（例：Redis）作為資料庫伺服器。這種做法需要將每個請求當作事件來進行廣播，這樣就可以從事件儲存中心重播所有的事件。</p>\n<p>在微服務中，則通過 API 調用來完成。這些模塊或者服務間調用，大部分時候是為了共享數據。<br>共享數據最賤的方式當然就是採用一種共享資料庫的模式，也就是單體應用常用的方式。應用可以有多個系統模塊，但一般都是只有一個資料庫。</p>\n<p><img src=\"https://twgreatdaily.com/images/elastic/SnG/SnG8WHMBiuFnsJQVaRyz.jpg\" alt=\"一庫一服  vs 一庫多服\"></p>\n<p>一庫多服，這種架構模式通常會被認為是 微服務架構下的反範式，它的問題在於:</p>\n<ul>\n<li>單點故障：一個資料庫倒下，整批服務全部停止。何來的服務獨立性？</li>\n<li>數據在同一個地方，會給貪圖方便的開發或者 DBA 工程師編寫很多數據間高度依賴的程序或者工具。</li>\n<li>無法針對某一個服務進行精準優化或擴展。<br>所以一般推薦的做法，是為每一個微服務準備一個單獨的資料庫，也即一庫一服(Database per Service)模式。這種模式更加適合微服務架構，它滿足每一個服務是獨立開發、獨立部署、獨立擴展的特性。需要對一個服務進行升級或者數據架構改動的時候，不會影響到其他的服務。需要對某個服務進行擴展的時候，也可以手術式的對某一個服務進行局部擴容。</li>\n</ul>\n<h2 id=\"微服務的切割\"><a href=\"#微服務的切割\" class=\"headerlink\" title=\"微服務的切割\"></a>微服務的切割</h2><ol>\n<li>domain-driven design (DDD) 領域驅動設計</li>\n</ol>\n<ul>\n<li>Infrastructure（基礎實施層）</li>\n<li>Domain（領域層）</li>\n<li>Application（應用層）</li>\n<li>Interfaces（表示層，也叫用戶界面層或是接口層）</li>\n</ul>\n<p><img src=\"https://res.cloudinary.com/dgzowpeqr/image/upload/v1562839291/levp4f9usxwzlrlk1dou.jpg\" alt=\"domain-driven design(DDD)\"></p>\n<ol start=\"2\">\n<li>資料結構</li>\n</ol>\n<h2 id=\"微服務的利和弊\"><a href=\"#微服務的利和弊\" class=\"headerlink\" title=\"微服務的利和弊\"></a>微服務的利和弊</h2><p><img src=\"https://res.cloudinary.com/dgzowpeqr/image/upload/v1562839370/wgkwtaplr4keahh9ojsa.jpg\" alt=\"Microservices 利與弊\"></p>\n<ul>\n<li>利: 單一服務組件化、可獨立部署、技術多樣性</li>\n<li>弊: 分佈式的系統複雜性(各別服務的溝通複雜化)、最終一致性、運維複雜性</li>\n</ul>\n<h2 id=\"微服務-設計模式\"><a href=\"#微服務-設計模式\" class=\"headerlink\" title=\"微服務(設計模式)\"></a>微服務(設計模式)</h2><p><img src=\"https://codertw.com/wp-content/uploads/img/15JGg8G9K0.jpg\" alt=\"鏈式設計模式\"></p>\n<p><img src=\"https://codertw.com/wp-content/uploads/img/IEq6ZUD3Og.jpg\" alt=\"聚合器設計模式\"></p>\n<p><img src=\"https://i.iter01.com/images/a65374eb32d49af469d0f73fa247e018af4ad67156d77ca20232556c48804cb6.png\" alt=\"代理設計模式\"></p>\n<p><img src=\"https://i.iter01.com/images/a6d2c4c0b8e7cde26918b623c0fdd67f0603e723d1090c6197711638a0a8b3f7.png\" alt=\"分支設計模式\"></p>\n<p><img src=\"https://codertw.com/wp-content/uploads/img/2hmI3o1N3Y.jpg\" alt=\"資料庫共享模式\"></p>\n<p><img src=\"https://codertw.com/wp-content/uploads/img/M2dJFZmv5O.jpg\" alt=\"異部消息設計模式\"></p>\n<h2 id=\"Service-Oriented-Architecture-與-Microservice-差別\"><a href=\"#Service-Oriented-Architecture-與-Microservice-差別\" class=\"headerlink\" title=\"Service Oriented Architecture 與 Microservice 差別\"></a>Service Oriented Architecture 與 Microservice 差別</h2><ul>\n<li>微服務不再強調傳統SOA架構裡面比較重的ESB(企業服務匯流排)，進入到單個業務系統內部實現真正的元件化。</li>\n<li>SOA注重的是系統整合方面，而微服務關注的是組件服務完全分離 。<br>more info:<a href=\"https://en.wikipedia.org/wiki/Microservices\" target=\"_blank\" rel=\"noopener\">Microservices wiki 英文</a><br>more info:<a href=\"https://zh.wikipedia.org/wiki/%E5%BE%AE%E6%9C%8D%E5%8B%99\" target=\"_blank\" rel=\"noopener\">微服務(Microservices) wiki</a><br>more info:<a href=\"https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/735003/\" target=\"_blank\" rel=\"noopener\">微服務(Microservices) 設計模式</a><br>more info:<a href=\"https://iter01.com/513031.html\" target=\"_blank\" rel=\"noopener\">架構設計思想-微服務架構設計模式</a><br>more info:<a href=\"https://twgreatdaily.com/I_S-V3MBfGB4SiUw1uN0.html\" target=\"_blank\" rel=\"noopener\">如何在微服務架構下進行數據設計？</a><br>more info:<a href=\"https://www.cnblogs.com/takumicx/p/10021538.html\" target=\"_blank\" rel=\"noopener\">微服務-柔性事务</a><br>more info:<a href=\"https://www.itread01.com/content/1542762129.html\" target=\"_blank\" rel=\"noopener\">微服務-DB規劃</a><br>more info:<a href=\"https://morosedog.gitlab.io/technology-20200304-tech-10/\" target=\"_blank\" rel=\"noopener\">技術觀念 | 淺談分散式系統 - 微服務淺談</a><br>more info:<a href=\"https://blog.csdn.net/xybelieve1990/article/details/84958671\" target=\"_blank\" rel=\"noopener\">关于分布式事务BASE模型和柔性事务TCC</a><br>more info:<a href=\"https://www.itread01.com/content/1542394146.html\" target=\"_blank\" rel=\"noopener\">SOA架構和微服務架構的比較</a><br>more info:<a href=\"https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/588191/\" target=\"_blank\" rel=\"noopener\">架構師必看：微服務架構綜述</a><br>more info:<a href=\"https://zh.wikipedia.org/wiki/%E9%9D%A2%E5%90%91%E6%9C%8D%E5%8A%A1%E7%9A%84%E4%BD%93%E7%B3%BB%E7%BB%93%E6%9E%84\" target=\"_blank\" rel=\"noopener\">SOA Wiki</a><br>more info:<a href=\"https://www.ipshop.xyz/16625.html\" target=\"_blank\" rel=\"noopener\">我只是下了個訂單，鬼知道我在微服務里經歷了什麼？ (DDD 領域驅動設計-微服務切割-訂單設計)</a><br>more info:<a href=\"https://kknews.cc/zh-tw/news/p95rx6e.html\" target=\"_blank\" rel=\"noopener\">老司機避坑指南：如何快速搞定微服務架構？</a><br>more info:<a href=\"https://www.martinfowler.com/articles/microservices.html#HowBigIsAMicroservice\" target=\"_blank\" rel=\"noopener\">martinfowler blog原文</a><br>more info:<a href=\"https://dzone.com/articles/6-data-management-patterns-for-microservices-1\" target=\"_blank\" rel=\"noopener\">6 Data Management Patterns for Microservices</a></li>\n</ul>\n","categories":["Development"],"tags":["Development"]},{"title":"Oracle - Automatic Workload Repository (AWR) Report","url":"/Blog/posts/Development/20210405-oracle-awr-report.html","content":"<p>最近被抓來看效能問題，做點查詢相關資料記錄。</p>\n<a id=\"more\"></a>\n\n<p><a href=\"https://iter01.com/266908.html\" target=\"_blank\" rel=\"noopener\">Oracle AWR報告指標全解析</a><br><a href=\"https://oracle-base.com/articles/10g/automatic-workload-repository-10g\" target=\"_blank\" rel=\"noopener\">Automatic Workload Repository (AWR) in Oracle Database 10g - oracle-base </a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"OpenShift基本使用觀念","url":"/Blog/posts/Development/20220507-openshift.html","content":"<p>由於專案關係，建了不少服務到OpenShift上面。<br>來開始記錄服務帶起來的基本流程。</p>\n<a id=\"more\"></a>\n\n<h6 id=\"建立流程\"><a href=\"#建立流程\" class=\"headerlink\" title=\"建立流程\"></a>建立流程</h6><ol>\n<li>先建立一個Project</li>\n</ol>\n<ul>\n<li>這個名稱會影響內部的各專案的網路連結。例如名稱dev-test， 專案內部連結連上這個服務url為xxx.dev-test。(xxx 為專案內的服務名)</li>\n</ul>\n<ol start=\"2\">\n<li><p>ConfigMaps<br>服務容器的環境變數</p>\n</li>\n<li><p>Services<br>設置服務名稱、port</p>\n</li>\n<li><p>Routes<br>對外URL、對該Route timeout設定</p>\n</li>\n<li><p>NetworkPolicies<br>防火牆、權限設置，這個可影響各專案是否可以內部互通。 若專案間沒設置就只能用外部Routes互通</p>\n</li>\n<li><p>DeploymentConfigs (這個會把Pod帶起來所以最後弄)</p>\n</li>\n</ol>\n<ul>\n<li>設置CPU使用、記憶體使用、 提供的port、服務檢測、服務備援、設定image來源、mount、triggers、termination-log 等設定</li>\n</ul>\n<p>Extra:</p>\n<ul>\n<li>CronJobs (做法類似linux指令)</li>\n<li>ImageStreams (image 放置的地方)</li>\n</ul>\n<p>Deploy Script (視情況調整)</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#!&#x2F;bin&#x2F;bash</span><br><span class=\"line\">IsSuccess()&#123;</span><br><span class=\"line\">\tif [$? !&#x3D; 0]</span><br><span class=\"line\">    then </span><br><span class=\"line\">            echo &quot;$&#123;tput setaf 1&#125; ~~Caution:&quot; $1&quot; fail ! $&#123;tput sgr 0&#125;&quot;</span><br><span class=\"line\">\t        exit 1</span><br><span class=\"line\">\telse</span><br><span class=\"line\">            echo &quot;$&#123;tput setaf 2&#125; ~~Execution:&quot; $1&quot; OK ! $&#123;tput sgr 0&#125;&quot;</span><br><span class=\"line\">\tfi</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">read -p &quot;Please input [DeploymentConfig Name] : &quot; dcName</span><br><span class=\"line\">read -p &quot;Please input [Version] : &quot; version</span><br><span class=\"line\">read -p &quot;Please input [tar location path] : &quot; tar_location</span><br><span class=\"line\">read -p &quot;Please input [OpenShift project] : &quot; openshift_project</span><br><span class=\"line\">read -p &quot;Please input [OpenShift url] : &quot; openshift_url</span><br><span class=\"line\">read -p &quot;Please input [OpenShift account] : &quot; account</span><br><span class=\"line\">read -p &quot;Please input [OpenShift password] : &quot; password</span><br><span class=\"line\"></span><br><span class=\"line\">test -z $&#123;dcName&#125; &amp;&amp; echo &quot;You Must input a DeploymentConfig Name.&quot; &amp;&amp; exit 0</span><br><span class=\"line\">test -z $&#123;version&#125; &amp;&amp; echo &quot;You Must input a version.&quot; &amp;&amp; exit 0</span><br><span class=\"line\"></span><br><span class=\"line\">image_name&#x3D;$dcName</span><br><span class=\"line\">image_tag&#x3D;$version</span><br><span class=\"line\">tar_location&#x3D;&quot;$&#123;tar_location&#125;&#x2F;$&#123;image_name&#125;-$&#123;image_tag&#125;.tar&quot;</span><br><span class=\"line\"></span><br><span class=\"line\">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;start&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br><span class=\"line\">oc login -u $account -p $password</span><br><span class=\"line\">IsSuccess &quot;oc login&quot;</span><br><span class=\"line\">oc project $openshift_project</span><br><span class=\"line\">IsSuccess &quot;switch project&quot;</span><br><span class=\"line\">podman login $openshift_url -p $&#123;oc whoami -t&#125; -u $&#123;oc whoami -t&#125;</span><br><span class=\"line\">IsSuccess &quot;podman login&quot;</span><br><span class=\"line\">podman load -i &quot;$&#123;tar_location&#125;&quot;</span><br><span class=\"line\">IsSuccess &quot;podman load [$&#123;tar_location&#125;]&quot;</span><br><span class=\"line\">podman push &quot;$&#123;openshift_url&#125;&#x2F;$&#123;openshift_project&#125;&#x2F;$&#123;image_name&#125;:$&#123;image_tag&#125;&quot;</span><br><span class=\"line\">IsSuccess &quot;podman push&quot;</span><br><span class=\"line\">oc tag $image_name:$image_tag $image_name:stable</span><br><span class=\"line\">IsSuccess &quot;oc tag [$&#123;image_name&#125;:$&#123;image_tag&#125;] to stable&quot; </span><br><span class=\"line\">oc rollout status dc&#x2F;$dcName</span><br><span class=\"line\">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;End&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&quot;</span><br></pre></td></tr></table></figure>\n\n<p>more info:<br><a href=\"http://c.biancheng.net/cpp/view/2739.html\" target=\"_blank\" rel=\"noopener\">Shell教程</a><br><a href=\"https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.4/html/cli_tools/cli-developer-commands#login\" target=\"_blank\" rel=\"noopener\">Open shift CLI</a><br><a href=\"https://access.redhat.com/documentation/zh-cn/openshift_container_platform/4.2/html/applications/deployments\" target=\"_blank\" rel=\"noopener\">Deployment vs DeploymentConfig</a><br><a href=\"https://blog.51cto.com/u_15127570/2712882\" target=\"_blank\" rel=\"noopener\">OpenShift中的Deployment和DeploymentConfig </a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"Oracle - Select指定傳回筆數","url":"/Blog/posts/Development/20210404-oracle-sql-select-rownum.html","content":"<p>由於Oracle不支持Select Top語句，所以在Oracle中經常是用Order By跟rownum的組合來實現Select Top N的查詢，<br>也跟PostgreSQL下的方法不一樣，不是用limit限制資料筆數，因此做記錄。</p>\n<p>OS: 整理完後我開始懷念PostgreSQL語法的簡潔…</p>\n<a id=\"more\"></a>\n\n<p>Oracle中 Select指令沒有類似LIMIT的參數可以使用來限制傳回資料的筆數，但是可以利用 ORACLE中的Rownum的值作一點手腳來限制傳回值的範圍。</p>\n<h4 id=\"ROWNUM-說明：\"><a href=\"#ROWNUM-說明：\" class=\"headerlink\" title=\"ROWNUM 說明：\"></a>ROWNUM 說明：</h4><ul>\n<li>rownum不能以任何表的名稱作為前綴字。</li>\n<li>Oracle 使用 rownum 作為查詢結果行的編號，第一行是1，第二行是2， 以此類推，可以用於限制查詢返回的總行數。</li>\n<li>rownum的值在”查詢結果輸出時自動產生”，因此第一條始終是1。</li>\n<li>Oracle中的rownum的是在查找資料的時候產生的序號，所以想對指定排序的數據去指定的rowmun行數據就必須注意了。</li>\n<li>要注意的是在使用rownum時，只有當Order By 的字段是主鍵或索引時，查詢結果才會先排序再計算rownum,但是，對非主鍵欄位進行排序時卻不是。<br>出現這種的原因是：Oracle 先按物理存儲位置（rowid）順序取出滿足rownum 條件的記錄，即物理位置上的前5條數據，然後在對這些數據按照Order By 的字段進行排序，而不是我們所期望的先排序、再取特定記錄數。(因此排序的欄位建議是有索引的欄位)</li>\n<li>若無索引或主鍵，只能用子查詢來實現先排序。(注意查詢效能的問題)</li>\n</ul>\n<p>1、ROWNUM 是偽列，必須要有返回結果後，每條返回記錄就會對應產生一個ROWNUM數值；<br>2、返回結果記錄的ROWNUM 是從1 開始排序的，因此第一條始終是1;這樣，當查詢到第一條記錄時，該記錄的ROWNUM 為1，但條件要求ROWNUM&gt;1，因此不符合，繼續查詢下一條；因為前面沒有符合要求的記錄，因此下一條記錄過來後，其ROWNUM 還是為1，如此循環，就不會產生結果。</p>\n<h4 id=\"分頁顯示實作\"><a href=\"#分頁顯示實作\" class=\"headerlink\" title=\"分頁顯示實作:\"></a>分頁顯示實作:</h4><p>通用的作法:<br>select * from (子查詢) WHERE rownum Between 初始列  AND 尾列;</p>\n<p>Tips:</p>\n<ul>\n<li>很多開發者在確認某個表中是否有相應數據時，喜歡加上ROWNUM=1，其想法就是只要存在一條數據就說明有相應數據，查詢就可以直接返回了，這樣就能提高性能了。<br>但是在Oracle 10G之前，使用rownum=1 是不能達到預期的性能效果的，而是需要通過&lt;2 或&lt;=1 作為過濾條件才能達到預期效果。</li>\n</ul>\n<p><a href=\"https://blog.csdn.net/zxh2075/article/details/77110736\" target=\"_blank\" rel=\"noopener\">Oracle rownum 用法詳解</a><br><a href=\"https://blog.csdn.net/bbliutao/article/details/8531091\" target=\"_blank\" rel=\"noopener\">Oracle rownum 注意事項</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"Oracle - Sequence (流水號與工作流(JBPM取流水號)的問題)","url":"/Blog/posts/Development/20210317-java-oracle-sequence.html","content":"<p>最近接的案子遇到了不少坑，做個典型的記錄，看到了某功能取工作流的底層排序，排序用”流水號”做排序取號的依據要非常注意。(被坑歪了)</p>\n<a id=\"more\"></a>\n\n<p>有時候最新的動作會取到較小的號，導致排序流水號排序時，遇流程要回退的問題。<br>解決方法:</p>\n<ol>\n<li>設計時間欄位做排序處理</li>\n<li>不用自動取流水號</li>\n</ol>\n<p><a href=\"https://cloud.tencent.com/developer/article/1555342\" target=\"_blank\" rel=\"noopener\">Oracle sequence 跳号知多少</a><br><a href=\"https://bbs.csdn.net/topics/390821969\" target=\"_blank\" rel=\"noopener\">Oracle sequence 不连续、相差太大问题</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"Rest 無狀態的解釋","url":"/Blog/posts/Web/20210104-rest-stateless.html","content":"<p>每次都忘怎麼解釋，寫一下。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Wiki-Rest擷取\"><a href=\"#Wiki-Rest擷取\" class=\"headerlink\" title=\"Wiki Rest擷取\"></a>Wiki Rest擷取</h3><ul>\n<li>無狀態（Stateless）<ul>\n<li>伺服器不能儲存客戶端的資訊,每一次從客戶端傳送的請求中, 要包含所有的必須的狀態資訊, 對談資訊由客戶端儲存, 伺服器端根據這些狀態資訊來處理請求. 伺服器可以將對談狀態資訊傳遞給其他服務, 比如資料庫服務, 這樣可以保持一段時間的狀態資訊, 從而實現認證功能. 當客戶端可以切換到一個新狀態的時候傳送請求資訊. 當一個或者多個請求被傳送之後, 客戶端就處於一個狀態變遷過程中. 每一個應用的狀態描述可以被客戶端用來初始化下一次的狀態變遷.</li>\n</ul>\n</li>\n</ul>\n<p>每次回過頭直接看這段Wiki翻的和原文我真心看不懂!!直到看了這個無狀態Server的解釋。</p>\n<h3 id=\"無狀態Server\"><a href=\"#無狀態Server\" class=\"headerlink\" title=\"無狀態Server\"></a>無狀態Server</h3><ul>\n<li>無狀態伺服器是指一種把每個請求作為與之前任何請求都無關的獨立的事務的伺服器。</li>\n</ul>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><ul>\n<li>無狀態 (Stateless) 是指從 Client 到 Server 的所有請求，皆需包含『 用於理解該次請求 』的 所有 相關信息，不得利用任何儲存在 Server 的上下文。</li>\n<li>Server不得假定同一連接 上的兩個請求來自同一個 User Agent。</li>\n<li>REST 中的『 狀態 』，是指 資源 與 表示 的狀態，而非無狀態 (Stateless) 架構約束中的 會話(Session)狀態。</li>\n</ul>\n<p>More info: <a href=\"https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2\" target=\"_blank\" rel=\"noopener\">Representational State Transfer (Rest)</a><br>More info: <a href=\"https://zh.wikipedia.org/wiki/%E6%97%A0%E7%8A%B6%E6%80%81%E5%8D%8F%E8%AE%AE\" target=\"_blank\" rel=\"noopener\">Stateless protocol (無狀態協議)</a></p>\n","categories":["Web"],"tags":["Web"]},{"title":"Postgres Observability","url":"/Blog/posts/Development/20210316-postgres-observability.html","content":"<p>覺得這網站Postgres整理的不錯，進行留存。</p>\n<p>網站: <a href=\"https://pgstats.dev/\" target=\"_blank\" rel=\"noopener\">《 Postgres Observability》</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"Oracle - 開發常用查詢語法","url":"/Blog/posts/Development/20210403-oracle-daily-sql.html","content":"<p>做個開發常使用的查詢記錄。</p>\n<a id=\"more\"></a>\n\n<p>– 查詢版本<br>SELECT * FROM v$version;<br>SELECT * FROM product_component_version;</p>\n<p>– 目前資料庫的語系<br>SELECT * FROM nls_database_parameters WHERE parameter = ‘NLS_CHARACTERSET’;</p>\n<p>– 查詢目前資料庫名稱<br>SELECT NAME FROM v$database;</p>\n<p>– 查詢session連線數<br>select count(*) from v$session；</p>\n<p>–當前的連接數<br>select count(*) from v$process</p>\n<p>– 查看不同使用者的連接數<br>select username,count(username) from v$session where username is not null group by username;</p>\n<p>– 查詢oracle的併發連接數<br>select count(*) from v$session where status=’ACTIVE’;</p>\n<p>– 資料庫允許的最大連接數<br>select value from v$parameter where name = ‘processes’ </p>\n<p>– 修改最大連接數:<br>alter system set processes = 300 scope = spfile;</p>\n<p>– 重啟資料庫:<br>shutdown immediate;<br>startup;</p>\n<p>–查看當前有哪些使用者正在使用資料<br>SELECT osuser, a.username,cpu_time/executions/1000000||’s’, sql_fulltext,machine<br>from v$session a, v$sqlarea b<br>where a.sql_address =b.address order by cpu_time/executions desc;</p>\n<p>– 按機器名分組查<br>select username,machine,count(username) from v$session where username is not null group by username,machine;</p>\n<p>– 查看使用者或角色系統許可權(直接賦值給使用者或角色的系統許可權)：<br>select * from dba_sys_privs;<br>select * from user_sys_privs;</p>\n<p>– 查看角色(只能查看登陸使用者擁有的角色)所包含的許可權<br>select * from role_sys_privs;</p>\n<p>– 查看所有角色：<br>select * from dba_roles;</p>\n<p>– 查看所有使用者<br>select * from all_users;</p>\n<p>– 查看使用者或角色所擁有的角色：<br>select * from dba_role_privs;<br>select * from user_role_privs;</p>\n<p>– 查看使用者物件使用權限：<br>select * from dba_tab_privs;<br>select * from all_tab_privs;<br>select * from user_tab_privs;</p>\n<p>– 查看哪些使用者有sysdba或sysoper系統許可權(查詢時需要相應許可權)<br>select * from V$PWFILE_USERS; </p>\n<p>– 查詢所有 Table<br>SELECT * FROM USER_OBJECTS;<br>SELECT * FROM USER_OBJECTS ORDER BY OBJECT_NAME;</p>\n<p>– 查詢所有 Table &amp; 欄位<br>SELECT * FROM user_tab_columns ORDER BY TABLE_NAME;<br>SELECT * FROM user_tab_columns WHERE table_name = UPPER(‘表格名稱’) ORDER BY TABLE_NAME;</p>\n<p>– 取得 TABLE 的欄位<br>desc UPPER(‘表格名稱’);</p>\n<p>– 取得 Table 註解<br>SELECT table_name, comments<br>FROM sys.user_tab_comments<br>WHERE table_type =’TABLE’<br>AND comments IS NOT NULL;</p>\n<p>SELECT table_name, comments FROM sys.user_tab_comments WHERE table_name = UPPER(‘表格名稱’);</p>\n<p>– 取得 Column 註解<br>SELECT table_name, column_name, comments FROM sys.user_col_comments<br>WHERE comments IS NOT NULL;</p>\n<p>SELECT table_name, column_name, comments FROM sys.user_col_comments WHERE table_name = UPPER(‘表格名稱’);</p>\n<p>–登入的帳號在目前資料庫中可以存取的DBA的資料表<br>SELECT * FROM DBA_TABLES</p>\n<p>–登入的帳號在目前資料庫中可以存取的所有的資料表<br>SELECT * FROM ALL_TABLES</p>\n<p>–登入的帳號在目前資料庫中可以存取的自己的資料表<br>SELECT * FROM USER_TABLES</p>\n<p><a href=\"https://evanswa29.pixnet.net/blog/post/67924368-oracle%E5%B8%B8%E7%94%A8%E6%9F%A5%E8%A9%A2%E8%B3%87%E6%96%99%E5%BA%AB%E7%9A%84%E9%80%A3%E6%8E%A5%E6%95%B8%E4%BB%A5%E5%8F%8A%E4%BD%BF%E7%94%A8%E8%80%85\" target=\"_blank\" rel=\"noopener\">Oracle常用查詢資料庫的連接數以及使用者</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"UML工具推薦","url":"/Blog/posts/Development/20220903-uml-tool.html","content":"<p>實務上覺得實用的工具</p>\n<a id=\"more\"></a>\n\n<h3 id=\"PlantUML-推薦PG從這開始嘗試使用，跟寫code一樣方便\"><a href=\"#PlantUML-推薦PG從這開始嘗試使用，跟寫code一樣方便\" class=\"headerlink\" title=\"PlantUML (推薦PG從這開始嘗試使用，跟寫code一樣方便)\"></a>PlantUML (推薦PG從這開始嘗試使用，跟寫code一樣方便)</h3><ul>\n<li>提供 Online Server 撰寫</li>\n<li><a href=\"https://plantuml.com/zh/\" target=\"_blank\" rel=\"noopener\">PlantUML</a></li>\n</ul>\n<h3 id=\"StarUML\"><a href=\"#StarUML\" class=\"headerlink\" title=\"StarUML\"></a>StarUML</h3><ul>\n<li><a href=\"https://staruml.io/download\" target=\"_blank\" rel=\"noopener\">StarUML</a></li>\n</ul>\n<h3 id=\"Draw-io\"><a href=\"#Draw-io\" class=\"headerlink\" title=\"Draw.io\"></a>Draw.io</h3><ul>\n<li>提供 Online Server 撰寫</li>\n<li>可存成可編輯的PNG</li>\n<li><a href=\"https://app.diagrams.net/\" target=\"_blank\" rel=\"noopener\">Draw.io</a></li>\n</ul>\n","categories":["Development"],"tags":["Development"]},{"title":"RESTful API設計","url":"/Blog/posts/Development/20210131-rest-api-Development.html","content":"<p>RESTful API 設計之學習記錄</p>\n<a id=\"more\"></a> \n\n<h2 id=\"REST要點-REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。\"><a href=\"#REST要點-REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。\" class=\"headerlink\" title=\"REST要點(REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。)\"></a>REST要點(REST是”設計風格”而不是標準。REST通常基於HTTP、URI、XML以及HTML這些現有的廣泛流行的協定和標準。)</h2><ul>\n<li>資源是由URI來指定。</li>\n<li>對資源的操作包括取得、建立、修改和刪除，這些操作正好對應HTTP協定提供的GET、POST、PUT和DELETE方法。</li>\n<li>通過操作資源的表現形式來操作資源。</li>\n<li>資源的表現形式則是XML或者HTML，取決於讀者是機器還是人、是消費Web服務的客戶軟體還是Web瀏覽器。當然也可以是任何其他的格式，例如JSON。</li>\n</ul>\n<h2 id=\"特徵\"><a href=\"#特徵\" class=\"headerlink\" title=\"特徵\"></a>特徵</h2><ul>\n<li>統一介面(Uniform Interface)<ul>\n<li>Identification of resources - 唯一的資源識別</li>\n<li>Manipulation of resources - 特定的操作方法</li>\n<li>Self-descriptive messages - 訊息自我描述 </li>\n<li>Hypermedia as the engine of application state (HATEOAS)<ul>\n<li>Level 0 : 使用一個 URI 與一個 HTTP 方法，基本上就是單純使用 HTTP 作為傳輸協定，服務使用的 URI 只是個接收請求進行回應的端點，HTTP 方法只是用來發起請求，至於請求的相關細節，例如想進行的動作、必須提供的資料等，全部包含在發送過去的文件之中，像是 XML、JSON 等其他（自訂）格式，回應使用某個文件格式傳回，當中包含了請求操作後的結果。</li>\n<li>Level 1 : 使用多個 URI 與一個 HTTP 方法，URI 代表了資源，像是 /show_message、/create_message、/update_message、/delete_message 都是資源，HTTP 方法只是用來發起請求，至於請求的細節由請求本體來提供，例如，在請求 /show_message 這項資源時，若包含 all 請求參數，表示顯示全部的訊息，若是 “id=1” 這類請求參數，表示顯示指定的訊息。</li>\n<li>Level 2 :使用多個 URI、多個 HTTP 方法，並善用 HTTP 回應狀態碼，URI 用來代表資源，像是 /messages、/messages/1，HTTP 方法用來表示想進行的操作，例如 GET /messages 表示取得全部訊息，GET /messages/1 表示取得指定訊息，POST /messages 表示新增訊息、DELETE /messages/1 表示刪除指定訊息等</li>\n<li>Level 3 : 更進一步地，支援 HATEOAS（Hypermedia As The Engine Of Application State）的概念，就類似 HTML 頁面鏈結，你可以從這個頁面得知可通往哪些頁面，在 REST 的 Level 3 模型中，客戶端可以從某個資源，知道還有哪些其他相關的資源，以及如何對它進行操作</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>Stateless(無狀態)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#How to understand “RESTful API is stateless”?(stackoverflow) (部分內容擷取)</span><br><span class=\"line\">[...] </span><br><span class=\"line\"> each request from client to server must contain all of the information necessary to understand the request,</span><br><span class=\"line\"> and cannot take advantage of any stored context on the server. </span><br><span class=\"line\"> Session state is therefore kept entirely on the client. [...]</span><br></pre></td></tr></table></figure>\n<ul>\n<li>Cacheable(可快取)</li>\n<li>Client-Server(客戶伺服器分離模式，任何一個客戶端與伺服器都是可替換的)</li>\n<li>Layered System (分層的系統，客戶端不知道他請求的是不是最終伺服器)</li>\n<li>Code on Demand (optional)<ul>\n<li>允許客戶端提高其靈活性(視情況決定要不要遵守，Server端 可以傳送可執行的程式碼給 Client端)</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"REST設計\"><a href=\"#REST設計\" class=\"headerlink\" title=\"REST設計\"></a>REST設計</h2><p>符合REST設計風格的Web API稱為RESTful API。它從以下三個方面資源進行定義：</p>\n<ul>\n<li>直觀簡短的資源位址，比如: <a href=\"http://example.com/resources。\" target=\"_blank\" rel=\"noopener\">http://example.com/resources。</a></li>\n<li>傳輸的資源：Web服務接受與返回的網際網路媒體類型，比如：JSON，XML，YAML等。</li>\n<li>對資源的操作：Web服務在該資源上所支援的一系列請求方法（比如：POST，GET，PUT或DELETE）。</li>\n</ul>\n<h2 id=\"RESTful-API設計要點\"><a href=\"#RESTful-API設計要點\" class=\"headerlink\" title=\"RESTful API設計要點\"></a>RESTful API設計要點</h2><p>HTTP動詞</p>\n<ul>\n<li>GET（SELECT）：請求指定資源，只應用於取得資料。(Filtering， query string)</li>\n<li>POST（CREATE）：在服務器新建一個資源。</li>\n<li>PUT（UPDATE）：會取代指定資源所酬載請求（request payload）的所有表現。</li>\n<li>PATCH（UPDATE）：指定資源的部份修改。</li>\n<li>DELETE（DELETE）：從服務器刪除指定資源。</li>\n<li>HEAD：請求與 GET方法相同的回應，但它沒有回應主體（response body）。(應用於HTTP標頭，判別資源是否存在)</li>\n<li>OPTIONS：描述指定資源的溝通方法（communication option）。</li>\n<li>CONNECT: 指定資源標明的伺服器之間，建立隧道（tunnel）。</li>\n<li>TRACE: 指定資源標明的伺服器之間，執行迴路返回測試（loop-back test）。</li>\n</ul>\n<p>資源命名與設計: </p>\n<ul>\n<li>複數名詞命名資源，如 <a href=\"https://api.example.com/v1/users\" target=\"_blank\" rel=\"noopener\">https://api.example.com/v1/users</a></li>\n<li>取得特定ID資源(別另外設計單數)，如 <a href=\"https://api.example.com/v1/users/1\" target=\"_blank\" rel=\"noopener\">https://api.example.com/v1/users/1</a></li>\n<li>取得特定複數資料查詢利用 query string做額外條件過濾或參數，<br>(<a href=\"https://api.example.com/v1/users?order=&quot;desc&quot;&amp;&amp;limit=10\" target=\"_blank\" rel=\"noopener\">https://api.example.com/v1/users?order=&quot;desc&quot;&amp;&amp;limit=10</a>)</li>\n<li>URI 應加入 API 的版本號，如<a href=\"https://api.example.com/v1/users\" target=\"_blank\" rel=\"noopener\">https://api.example.com/v1/users</a></li>\n</ul>\n<h2 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考:\"></a>參考:</h2><p><a href=\"https://www.crummy.com/writing/speaking/2008-QCon/act3.html\" target=\"_blank\" rel=\"noopener\">REST 成熟度模型</a><br><a href=\"https://itbilu.com/other/relate/ry5IPQu8V.html\" target=\"_blank\" rel=\"noopener\">成熟度模型-REST的实现步骤</a><br><a href=\"https://zh.wikipedia.org/wiki/%E8%B6%85%E6%96%87%E6%9C%AC%E4%BC%A0%E8%BE%93%E5%8D%8F%E8%AE%AE#%E5%B9%82%E7%AD%89%E6%96%B9%E6%B3%95\" target=\"_blank\" rel=\"noopener\">HyperText Transfer Protocol，HTTP (wiki)</a><br><a href=\"https://stackoverflow.com/questions/34130036/how-to-understand-restful-api-is-stateless\" target=\"_blank\" rel=\"noopener\">How to understand “RESTful API is stateless”?(stackoverflow)</a><br><a href=\"https://zh.wikipedia.org/wiki/%E8%A1%A8%E7%8E%B0%E5%B1%82%E7%8A%B6%E6%80%81%E8%BD%AC%E6%8D%A2\" target=\"_blank\" rel=\"noopener\">REST Wiki</a><br><a href=\"http://www.ruanyifeng.com/blog/2014/05/restful_api.html\" target=\"_blank\" rel=\"noopener\">RESTful API 设计指南 - 阮一峰的网络日志</a><br><a href=\"https://openhome.cc/Gossip/Spring/HATEOAS.html\" target=\"_blank\" rel=\"noopener\">Hypermedia As The Engine Of Application State(HATEOAS) Spring HATEOAS</a><br><a href=\"https://github.com/TritonHo/slides/blob/master/Taipei%202019-06%20talk/RESTful%20API%20Design-tw-2.2.pdf\" target=\"_blank\" rel=\"noopener\">Backend社團-紫色石虎-RESTful API淺談</a><br><a href=\"https://github.com/TritonHo/slides/blob/master/restful-demo.pdf\" target=\"_blank\" rel=\"noopener\">Backend社團-紫色石虎-RESTful淺談  - demo</a><br><a href=\"https://developer.mozilla.org/zh-TW/docs/Web/HTTP/Methods\" target=\"_blank\" rel=\"noopener\">HTTP (MDN)</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"Spring 與 Docker 筆記","url":"/Blog/posts/Docker/20220306-docker-note-spring.html","content":"<p>基本操作概念與參考整理。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"SpringBoot構建Docker鏡像的-3-種方式\"><a href=\"#SpringBoot構建Docker鏡像的-3-種方式\" class=\"headerlink\" title=\"SpringBoot構建Docker鏡像的 3 種方式\"></a>SpringBoot構建Docker鏡像的 3 種方式</h3><ul>\n<li>使用 spring-boot-maven-plugin 內置的 build-image.<ul>\n<li>mvn spring-boot:build-image</li>\n</ul>\n</li>\n<li>使用 Google 的 jib-maven-plugin。<ul>\n<li>mvn compile jib:build (Build your container image) - 會推送</li>\n<li>mvn compile jib:dockerBuild (Build to Docker daemon) - local</li>\n<li>mvn compile jib:buildTar  - local</li>\n</ul>\n</li>\n<li>使用 dockerfle-maven-plugin。</li>\n</ul>\n<h3 id=\"一般docker打包流程\"><a href=\"#一般docker打包流程\" class=\"headerlink\" title=\"一般docker打包流程\"></a>一般docker打包流程</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">+---------+     +---------+           +-----------------------------------------------+</span><br><span class=\"line\">| Project |----&gt;|   JAR   |-------+   |   Docker Daemon                               |</span><br><span class=\"line\">+---------+     +---------+       |   | +---------------+  build  +-----------------+ |     +------------------+</span><br><span class=\"line\">                                  +----&gt;| Build context |--------&gt;| Container Image |------&gt;| Container Image  |</span><br><span class=\"line\">                +------------+    |   | +---------------+         | (docker cache)  | |     | (registry)       |</span><br><span class=\"line\">                | Dockerfile |----+   |                           +-----------------+ |     +------------------+</span><br><span class=\"line\">                +------------+        +-----------------------------------------------+</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"JIB-打包-唯一無須本機須安裝docker環境，就可打包成tarball\"><a href=\"#JIB-打包-唯一無須本機須安裝docker環境，就可打包成tarball\" class=\"headerlink\" title=\"JIB 打包(唯一無須本機須安裝docker環境，就可打包成tarball)\"></a>JIB 打包(唯一無須本機須安裝docker環境，就可打包成tarball)</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">+---------+       Jib      +------------------+</span><br><span class=\"line\">| Project |---------------&gt;| Container Image  |</span><br><span class=\"line\">+---------+                | (registry)       |</span><br><span class=\"line\">                           +------------------+</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考\"></a>參考</h3><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">&lt;plugins&gt;</span><br><span class=\"line\">    &lt;plugin&gt;</span><br><span class=\"line\">      &lt;groupId&gt;com.google.cloud.tools&lt;&#x2F;groupId&gt;</span><br><span class=\"line\">      &lt;artifactId&gt;jib-maven-plugin&lt;&#x2F;artifactId&gt;</span><br><span class=\"line\">      &lt;version&gt;$&#123;jib.version&#125;&lt;&#x2F;version&gt;</span><br><span class=\"line\">      &lt;configuration&gt;</span><br><span class=\"line\">        &lt;skip&gt;$&#123;jib.skip&#125;&lt;&#x2F;skip&gt;</span><br><span class=\"line\">        &lt;!-- 配置基礎image--&gt;</span><br><span class=\"line\">        &lt;from&gt;</span><br><span class=\"line\">          &lt;image&gt;openjdk:8-jre-alpine&lt;&#x2F;image&gt;</span><br><span class=\"line\">        &lt;&#x2F;from&gt;</span><br><span class=\"line\">        &lt;!-- 配置推送地址，倉庫名，image名稱--&gt;</span><br><span class=\"line\">        &lt;to&gt;</span><br><span class=\"line\">          &lt;image&gt;$&#123;推送地址&#125;&#x2F;$&#123;倉庫名&#125;&#x2F;$&#123;image名稱&#125;&lt;&#x2F;image&gt;</span><br><span class=\"line\">          &lt;tags&gt;</span><br><span class=\"line\">            &lt;!-- &lt;tag&gt;$&#123;jib.repository.name&#125;&lt;&#x2F;tag&gt;--&gt;</span><br><span class=\"line\">            &lt;!-- &lt;tag&gt;$&#123;version&#125;&lt;&#x2F;tag&gt;--&gt;</span><br><span class=\"line\">          &lt;&#x2F;tags&gt;</span><br><span class=\"line\">          &lt;auth&gt;</span><br><span class=\"line\">            &lt;username&gt;$&#123;帳號&#125;&lt;&#x2F;username&gt;</span><br><span class=\"line\">            &lt;password&gt;$&#123;密碼&#125;&lt;&#x2F;password&gt;</span><br><span class=\"line\">          &lt;&#x2F;auth&gt;</span><br><span class=\"line\">        &lt;&#x2F;to&gt;</span><br><span class=\"line\">        &lt;!-- jib默認不推送到非https的私服--&gt;</span><br><span class=\"line\">        &lt;!--          &lt;allowInsecureRegistries&gt;true&lt;&#x2F;allowInsecureRegistries&gt;--&gt;</span><br><span class=\"line\">        &lt;container&gt;</span><br><span class=\"line\">          &lt;mainClass&gt;$&#123;jib.main.class&#125;&lt;&#x2F;mainClass&gt;</span><br><span class=\"line\">          &lt;labels&gt;</span><br><span class=\"line\">            &lt;name&gt;$&#123;artifactId&#125;&lt;&#x2F;name&gt;</span><br><span class=\"line\">          &lt;&#x2F;labels&gt;</span><br><span class=\"line\">\t\t  &lt;ports&gt;</span><br><span class=\"line\">\t\t\t&lt;port&gt;8080&lt;&#x2F;port&gt;</span><br><span class=\"line\">\t\t\t&lt;port&gt;8081&lt;&#x2F;port&gt;</span><br><span class=\"line\">\t\t  &lt;&#x2F;ports&gt;</span><br><span class=\"line\">        &lt;&#x2F;container&gt;</span><br><span class=\"line\">      &lt;&#x2F;configuration&gt;</span><br><span class=\"line\">      &lt;!--綁定到maven lifecicle--&gt;</span><br><span class=\"line\">      &lt;!--        &lt;executions&gt;--&gt;</span><br><span class=\"line\">      &lt;!--          &lt;execution&gt;--&gt;</span><br><span class=\"line\">      &lt;!--            &lt;phase&gt;package&lt;&#x2F;phase&gt;--&gt;</span><br><span class=\"line\">      &lt;!--            &lt;goals&gt;--&gt;</span><br><span class=\"line\">      &lt;!--              &lt;goal&gt;build&lt;&#x2F;goal&gt;--&gt;</span><br><span class=\"line\">      &lt;!--            &lt;&#x2F;goals&gt;--&gt;</span><br><span class=\"line\">      &lt;!--          &lt;&#x2F;execution&gt;--&gt;</span><br><span class=\"line\">      &lt;!--        &lt;&#x2F;executions&gt;--&gt;</span><br><span class=\"line\">    &lt;&#x2F;plugin&gt;</span><br><span class=\"line\">  &lt;&#x2F;plugins&gt;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"Maven-plugin-比較\"><a href=\"#Maven-plugin-比較\" class=\"headerlink\" title=\"Maven plugin 比較\"></a>Maven plugin 比較</h3><p><img src=\"https://pic1.xuehuaimg.com/proxy/csdn/https://imgconvert.csdnimg.cn/aHR0cDovL3AxLnBzdGF0cC5jb20vbGFyZ2UvcGdjLWltYWdlL2MwMDAxZTY5MmUxNTQ5NGFhOGQ2MmFmOWE2NmVlMDli?x-oss-process=image/format,png\" alt=\"Maven plugin 比較\"></p>\n<p>註:</p>\n<ul>\n<li>SpringBoot 原生的方式，什麼都不需要自己做，直接就能用。</li>\n<li>最有特點的是 Jib，不需要你本地安裝 Docker，可以直接推送到指定的倉庫。 </li>\n<li>前2個與比較吃網路環境狀態</li>\n</ul>\n<p>參考: <a href=\"https://github.com/GoogleContainerTools/jib/tree/master/jib-maven-plugin\" target=\"_blank\" rel=\"noopener\">Jib 官網</a></p>\n","categories":["Docker"],"tags":["Java","Docker"]},{"title":"專案遇上Win10 MAC Address權限設定問題與網路密碼更新的問題","url":"/Blog/posts/Development/20210815-project-issue-0001.html","content":"<p>專案遇上Win10 MAC Address權限設定問題與網路密碼更新的問題</p>\n<a id=\"more\"></a>\n\n<h1 id=\"MAC-Address-相關\"><a href=\"#MAC-Address-相關\" class=\"headerlink\" title=\"MAC Address 相關\"></a>MAC Address 相關</h1><h3 id=\"Win10\"><a href=\"#Win10\" class=\"headerlink\" title=\"Win10\"></a>Win10</h3><ul>\n<li>MAC Address 查詢方法， <a href=\"https://www.kocpc.com.tw/archives/310582\" target=\"_blank\" rel=\"noopener\">如何在 Windows 10 上查找 MAC 位址（實體位址）？ 5 個方法一次教給你</a></li>\n<li>Win10 新增的功能(<a href=\"https://support.microsoft.com/zh-tw/windows/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8%E9%9A%A8%E6%A9%9F%E7%A1%AC%E9%AB%94%E4%BD%8D%E5%9D%80-ac58de34-35fc-31ff-c650-823fc48eb1bc\" target=\"_blank\" rel=\"noopener\">隨機硬體位址</a>)<h3 id=\"Android-MAC-Address-隨機位址的發展歷程\"><a href=\"#Android-MAC-Address-隨機位址的發展歷程\" class=\"headerlink\" title=\"Android - MAC Address 隨機位址的發展歷程\"></a>Android - MAC Address 隨機位址的發展歷程</h3></li>\n<li>從 Android 8.0 開始，Android 設備在未連接到網絡的情況下探測新網絡時，會使用隨機分配的 MAC 地址。</li>\n<li>在 Android 9 中，您可以啟用一個開發者選項（默認處於停用狀態），使設備在連接到 WLAN 網絡時使用隨機分配的 MAC 地址。</li>\n<li>在 Android 10 中，默認為客戶端模式、SoftAp 和 WLAN 直連啟用隨機分配 MAC 地址功能。 隨機分配 MAC 地址可防止監聽器使用 MAC 地址來生成設備活動的歷史記錄，從而加強對用戶隱私的保護。 此外，在 Wi-Fi 感知和 Wi-Fi RTT 操作中也會使用隨機分配的 MAC 地址。</li>\n</ul>\n<p>因此需要固定MAC 請記得 WIN10把隨機硬體位址的功能關掉，Andriod 則參考 <a href=\"(https://support.hdeone.com/hc/zh-tw/articles/360000647761\">在Android 10的智慧手機上安裝登錄憑證</a>該文處理即可</p>\n<p>#網域密碼原則查詢 (win cmd 常用指令)<br>當不知道為何不能更新的密碼的時候，可以更明確的跟當地網管敘述問題何在。</p>\n<ul>\n<li>net accounts /domain </li>\n<li>net user 帳號 /domain 指令即可得知每個使用者密碼原則<br><a href=\"http://xmrongta.com/EFNET/src/_Common/AppUtil/Help/Program/pwdchange.pdf\" target=\"_blank\" rel=\"noopener\">網域密碼變更處理原則</a></li>\n</ul>\n","categories":["Development"],"tags":["Development"]},{"title":"Web開發常用工具","url":"/Blog/posts/Development/20210127-java-web-tool.html","content":"<p>工作整理常用、過去使用過的文件網站與相關工具整理</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Java-相關\"><a href=\"#Java-相關\" class=\"headerlink\" title=\"Java 相關\"></a>Java 相關</h2><p><a href=\"https://spring.io/projects/spring-boot\" target=\"_blank\" rel=\"noopener\">Spring 相關文件官網</a><br><a href=\"https://hibernate.org/\" target=\"_blank\" rel=\"noopener\">Hibernate 官網</a><br><a href=\"https://www.oracle.com/tw/java/technologies/javase/javase-jdk8-downloads.html\" target=\"_blank\" rel=\"noopener\">Oracle JDK</a><br><a href=\"https://poi.apache.org/apidocs/index.html\" target=\"_blank\" rel=\"noopener\">Apache POI</a><br><a href=\"https://mybatis.org/mybatis-3/zh/index.html\" target=\"_blank\" rel=\"noopener\">mybatis 官網</a><br><a href=\"https://www.thymeleaf.org/documentation.html\" target=\"_blank\" rel=\"noopener\">Thymeleaf Doc</a><br><a href=\"https://www.thymeleaf.org/ecosystem.html\" target=\"_blank\" rel=\"noopener\">Thymeleaf Plugin</a><br><a href=\"https://docs.oracle.com/javaee/5/tutorial/doc/bnake.html\" target=\"_blank\" rel=\"noopener\">JSTL Oracle doc</a><br><a href=\"https://docs.oracle.com/javaee/5/jstl/1.1/docs/tlddocs/\" target=\"_blank\" rel=\"noopener\">JSTL Oracle doc (tld doc)</a><br><a href=\"https://howtodoinjava.com/\" target=\"_blank\" rel=\"noopener\">Java 教學(英文)</a></p>\n<h2 id=\"HTML-JavaScript-CSS相關\"><a href=\"#HTML-JavaScript-CSS相關\" class=\"headerlink\" title=\"HTML, JavaScript, CSS相關\"></a>HTML, JavaScript, CSS相關</h2><p><a href=\"https://www.w3schools.com/js/default.asp\" target=\"_blank\" rel=\"noopener\">W3C (JavaScript)</a><br><a href=\"https://www.w3schools.com/css/default.asp\" target=\"_blank\" rel=\"noopener\">W3C (CSS)</a><br><a href=\"https://www.w3schools.com/html/default.asp\" target=\"_blank\" rel=\"noopener\">W3C (HTML)</a><br><a href=\"https://www.w3school.com.cn/html5/index.asp\" target=\"_blank\" rel=\"noopener\">W3C.cn (HTML5)</a><br><a href=\"https://developer.mozilla.org/en-US/docs/Web\" target=\"_blank\" rel=\"noopener\">MDN Web Docs 英文 (Web APIs)</a><br><a href=\"https://developer.mozilla.org/zh-TW/docs/Web\" target=\"_blank\" rel=\"noopener\">MDN Web Docs 中文 (Web APIs)</a><br><a href=\"https://api.jquery.com/\" target=\"_blank\" rel=\"noopener\">jQuery doc 文件</a><br><a href=\"https://oscarotero.com/jquery/\" target=\"_blank\" rel=\"noopener\">jQuery API 快找</a><br><a href=\"https://sapui5.hana.ondemand.com/#/api\" target=\"_blank\" rel=\"noopener\">SAPUI5 文件</a><br><a href=\"https://www.jeasyui.com/documentation/index.php\" target=\"_blank\" rel=\"noopener\">Easy UI 文件</a><br><a href=\"https://getbootstrap.com/\" target=\"_blank\" rel=\"noopener\">Bootstrap 官網</a><br><a href=\"https://www.w3schools.com/bootstrap/bootstrap_ver.asp\" target=\"_blank\" rel=\"noopener\">w3c Bootstrap 教學</a><br><a href=\"https://startbootstrap.com/\" target=\"_blank\" rel=\"noopener\">Bootstrap 樣板網</a><br><a href=\"https://datatables.net/\" target=\"_blank\" rel=\"noopener\">datatables 表單外掛</a><br><a href=\"https://fontawesome.com/icons?d=gallery\" target=\"_blank\" rel=\"noopener\">Fontawesome UI icon</a><br><a href=\"https://caniuse.com/\" target=\"_blank\" rel=\"noopener\">caniuse (查詢js api在各家的瀏覽器相容性)</a><br><a href=\"https://www.oxxostudio.tw/articles/201501/css-flexbox.html\" target=\"_blank\" rel=\"noopener\">Flex box 教學(RWD &amp;&amp; CSS3)</a><br><a href=\"https://www.w3schools.com/css/css3_mediaqueries.asp\" target=\"_blank\" rel=\"noopener\">@Media 不同裝置的CSS設計 </a></p>\n<h2 id=\"開發工具\"><a href=\"#開發工具\" class=\"headerlink\" title=\"開發工具\"></a>開發工具</h2><p><a href=\"https://dbeaver.io/\" target=\"_blank\" rel=\"noopener\">DBeaver DB工具</a><br><a href=\"https://www.eclipse.org/downloads/\" target=\"_blank\" rel=\"noopener\">Eclispe 官網</a><br><a href=\"https://spring.io/tools\" target=\"_blank\" rel=\"noopener\">STS (Eclispe 與 Spring 整合開發工具)</a><br><a href=\"https://www.itread01.com/content/1546159175.html\" target=\"_blank\" rel=\"noopener\">Mybatis generator的使用教學</a><br><a href=\"https://docs.gradle.org/current/userguide/userguide.html\" target=\"_blank\" rel=\"noopener\">Gradle 官網</a><br><a href=\"https://www.w3cschool.cn/gradle/\" target=\"_blank\" rel=\"noopener\">Gradle 教學網</a><br><a href=\"https://maven.apache.org/download.cgi\" target=\"_blank\" rel=\"noopener\">Maven 官網</a><br><a href=\"https://www.w3cschool.cn/maven/tkhr1ht6.html\" target=\"_blank\" rel=\"noopener\">Maven 教學網</a><br><a href=\"https://staruml.io/\" target=\"_blank\" rel=\"noopener\">StarUML</a><br><a href=\"https://www.webtoolkitonline.com/\" target=\"_blank\" rel=\"noopener\">web toolkit online(綜合工具)</a></p>\n<h2 id=\"測試工具\"><a href=\"#測試工具\" class=\"headerlink\" title=\"測試工具\"></a>測試工具</h2><p><a href=\"https://regex101.com/\" target=\"_blank\" rel=\"noopener\">Regular Expression 線上驗證工具</a><br><a href=\"https://www.telerik.com/download/fiddler\" target=\"_blank\" rel=\"noopener\">Fiddler</a><br><a href=\"https://jmeter.apache.org/download_jmeter.cgi\" target=\"_blank\" rel=\"noopener\">JMeter</a><br><a href=\"https://www.postman.com/downloads/\" target=\"_blank\" rel=\"noopener\">Postman</a><br><a href=\"http://dog0416.blogspot.com/2017/06/stress-test-jmeter-beanshell.html\" target=\"_blank\" rel=\"noopener\">BeanShell JMeter教學</a><br><a href=\"https://topic.alibabacloud.com/tc/a/jmeter-bean-shell-use-full_1_28_20186532.html\" target=\"_blank\" rel=\"noopener\">BeanShell JMeter使用</a><br><a href=\"http://sikulix.com/quickstart/\" target=\"_blank\" rel=\"noopener\">SikuliX (圖形介面編寫腳本達到自動操作，基於Jython，須裝java &amp;&amp; Python)</a><br><a href=\"https://igouist.github.io/post/2020/03/sikulix/\" target=\"_blank\" rel=\"noopener\">SikuliX (簡易解說)</a></p>\n<h2 id=\"Linux\"><a href=\"#Linux\" class=\"headerlink\" title=\"Linux\"></a>Linux</h2><p><a href=\"http://linux.vbird.org/\" target=\"_blank\" rel=\"noopener\">鳥哥</a><br><a href=\"http://linux.vbird.org/linux_basic/0320bash.php#variable_var\" target=\"_blank\" rel=\"noopener\">鳥哥 BASH</a><br><a href=\"http://linux.vbird.org/linux_basic/0340bashshell-scripts.php\" target=\"_blank\" rel=\"noopener\">鳥哥 Shell scripts</a><br><a href=\"https://www.centos.org/download/\" target=\"_blank\" rel=\"noopener\">CentOS 官網</a><br><a href=\"https://ubuntu.com/download#download\" target=\"_blank\" rel=\"noopener\">Ubuntu 官網</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"壽險業系統設計Domain knowledge","url":"/Blog/posts/Development/20210128-java-insurance-system-design.html","content":"<p>壽險業簡易系統設計Domain knowledge描述，大概整理個通則。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"保單投保、核保流程-依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣\"><a href=\"#保單投保、核保流程-依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣\" class=\"headerlink\" title=\"保單投保、核保流程(依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣)\"></a>保單投保、核保流程(依據每家壽險自家流程而定，因為每家流程的過程中可能不太一樣)</h2><ol>\n<li>建議書</li>\n</ol>\n<ul>\n<li>主要是業務員透過拜訪客戶在介紹公司的保險商品階段。</li>\n<li>保險業務員與要被保險人談論保什麼險，之後進行初步輸入資料的階段。</li>\n</ul>\n<ol start=\"2\">\n<li>要保書</li>\n</ol>\n<ul>\n<li>輸入建檔階段，要被保人資料、簽名、保單商品資料、投保金額、證明文件等。</li>\n<li>照會檢查</li>\n</ul>\n<ol start=\"3\">\n<li>核保審核</li>\n</ol>\n<ul>\n<li>該階段會有該業務員的主管審核該保單資料內容，比如說黑名單、該投保金額、年齡、收入、被保人健康狀態。</li>\n<li>扣款也會在這階段。</li>\n<li>有問題發送照會，依內容決定是否退回處理</li>\n</ul>\n<ol start=\"4\">\n<li>投保完成</li>\n</ol>\n<ul>\n<li>一般來說該階段僅提供查閱的功能，不再提供變更。</li>\n<li>若要修改原本的保單，會需要留下資料備查不可刪除(log 或記錄在資料庫，保戶的舊保單相關內容進行註記)，另開新流程重新開始保單的投保流程或回到投保審核前階段。</li>\n</ul>\n<p>Extra: </p>\n<ol>\n<li><p>保單管理</p>\n<ul>\n<li>顧名思義就是保單的管理</li>\n<li>掛在業務員身上通常是未審核前的保單(該系統需設計利益迴避，避免自己人審自己人的情況)</li>\n<li>掛在審核人員身上的就是要審核的保單</li>\n</ul>\n</li>\n<li><p>保單查詢</p>\n<ul>\n<li>查詢保單內容</li>\n</ul>\n</li>\n<li><p>保單健檢 (不在投保主流程，算是輔助業務員與要被保人的檢視保障的功能)</p>\n<ul>\n<li>檢視該保單的保障和規劃，該設計內容可能有圖表預測、和一些依據保單提供的保障規劃。</li>\n<li>提供保險公司保單的檢視功能，提供個人保單檢視及家庭保單檢視功能、可將全家人保單之保障、保費、還本金額、意外、醫療、癌症透過表格或圖形清楚顯示出保障缺口，方便說明，並可納入投資型商品之壽險保障檢視功能，由保障缺口促成保單調整或再銷售的機會，保險資訊源含國內所有保險公司人身險商品。</li>\n</ul>\n</li>\n<li><p>保險需求分析系統  (不在投保主流程，算是輔助業務員與要被保人的檢視保障的功能)</p>\n<ul>\n<li>提供保險業務員協助客戶進行人生各階段理財目標規劃及計算—房貸規劃、子女教育規劃、退休養老規劃、遺產稅計算。</li>\n<li>透過應備及已備費用計算生涯累積差額，找出不足的風險保障。</li>\n<li>可結合保單健檢結果使需求更明確，以全家人的角度做家庭保險需求分析；並進一步提供退休養老規劃及遺產稅計算，根據客戶基本資料之判斷。</li>\n</ul>\n</li>\n<li><p>網路投保系統(不透過業務員的投保流程，其實就是輸入建檔那段換成客戶自己輸入)</p>\n</li>\n</ol>\n<ul>\n<li>商品上架管理</li>\n<li>會員資訊管理(含註冊/登入作業)</li>\n<li>投保案件管理(含投保記錄查詢、投保商品查詢)</li>\n<li>保險商品保費試算、保單核保(含保險公司核保及公會核保)</li>\n<li>信用卡繳費(需確認持卡人為要保人本人)</li>\n<li>投保額度計算</li>\n<li>簽署作業、通報作業</li>\n<li>自然人憑證驗證作業(要保人及簽署人用以驗證身份)等功能。<br>基本主流程:<ol>\n<li>加入會員 -&gt; 同意相關會員條款 -&gt; 輸入個人資料  -&gt; 會員相關驗證(手機、email、支付等驗證，是否當下必填，依各家壽險業業務流程決定)</li>\n<li>輸入投保資料 -&gt; 保費試算</li>\n<li>確認投保資料</li>\n<li>填寫或確認付款資訊</li>\n<li>核保審核<ul>\n<li>照會檢查</li>\n</ul>\n</li>\n<li>完成投保</li>\n</ol>\n</li>\n</ul>\n<h2 id=\"理賠流程\"><a href=\"#理賠流程\" class=\"headerlink\" title=\"理賠流程\"></a>理賠流程</h2><ol>\n<li>理賠申請書，輸入建檔(依過去保單內容自動帶入)<ul>\n<li>該階段資料證明附件大概包括如下:<ul>\n<li>憲警單位處理證明文件或肇事責任鑑定書</li>\n<li>診斷、醫瘵費收據</li>\n<li>瘵養費收據或其他補助收據。</li>\n<li>和解書或判決書。</li>\n<li>戶口名簿影本。</li>\n</ul>\n</li>\n<li>照會檢查</li>\n</ul>\n</li>\n<li>理賠審核<ul>\n<li>審核該理賠案件之內容</li>\n<li>調查附上的文件的內容</li>\n<li>有問題發送照會，依內容決定是否退回處理</li>\n</ul>\n</li>\n<li>理賠結果<ul>\n<li>拒賠</li>\n<li>文件不齊全，通知補齊，會回到審核階段或輸入階段</li>\n<li>依約給付，匯款、支票等給付方式</li>\n</ul>\n</li>\n</ol>\n<h2 id=\"收費流程\"><a href=\"#收費流程\" class=\"headerlink\" title=\"收費流程\"></a>收費流程</h2><ol>\n<li>收費保單輸入建檔<ul>\n<li>保單資料資料輸入</li>\n<li>銀行資料等支付資料輸入</li>\n<li>照會檢查</li>\n</ul>\n</li>\n<li>建當輸入審核<ul>\n<li>有問題發送照會，依內容決定是否退回處理</li>\n</ul>\n</li>\n<li>結案</li>\n</ol>\n<h2 id=\"照會-這個名詞是說在流程中遇到問題，需通知業務員是什麼問題\"><a href=\"#照會-這個名詞是說在流程中遇到問題，需通知業務員是什麼問題\" class=\"headerlink\" title=\"照會(這個名詞是說在流程中遇到問題，需通知業務員是什麼問題)\"></a>照會(這個名詞是說在流程中遇到問題，需通知業務員是什麼問題)</h2><ul>\n<li>照會發送</li>\n<li>照會處理(解照會)</li>\n</ul>\n","categories":["Development"],"tags":["Development"]},{"title":"Docker 筆記","url":"/Blog/posts/Docker/20220306-docker-note.html","content":"<p>基本操作概念與指令整理。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"Docker-安裝方式-在Windows-下\"><a href=\"#Docker-安裝方式-在Windows-下\" class=\"headerlink\" title=\"Docker 安裝方式(在Windows 下)\"></a>Docker 安裝方式(在Windows 下)</h3><ul>\n<li>Docker Toolbox (這個目前用下來最靈活，但目前官方已不再著手開發)</li>\n<li>Docker Desktop (需要Hyper-V，Windows 10專業版以上才有的Hyper-V虛擬技術可用)</li>\n</ul>\n<p>WSL 2 backend(Windows 需要裝 Linux kernel，可從微軟商店下載):</p>\n<ul>\n<li>Windows 11 64-bit: Home or Pro version 21H2 or higher, or Enterprise or Education version 21H2 or higher.</li>\n<li>Windows 10 64-bit: Home or Pro 2004 (build 19041) or higher, or Enterprise or Education 1909 (build 18363) or higher.</li>\n</ul>\n<p>Hyper-V: </p>\n<ul>\n<li>Windows 11 64-bit: Pro version 21H2 or higher, or Enterprise or Education version 21H2 or higher.</li>\n<li>Windows 10 64-bit: Pro 2004 (build 19041) or higher, or Enterprise or Education 1909 (build 18363) or higher.</li>\n</ul>\n<p>註:<br>目前VMware 、  Virtualbox 、BlueStack是可以在Hyper-V啟動，但啟動的速度有待改善，若有需要同時使用這些軟體的建議用Toolbox的安裝方式。</p>\n<p><a href=\"https://docs.docker.com/desktop/windows/install/\" target=\"_blank\" rel=\"noopener\">Docker Desktop 安裝文件</a><br><a href=\"https://github.com/docker-archive/toolbox/releases\" target=\"_blank\" rel=\"noopener\">Docker Toolbox 安裝壓縮檔</a></p>\n<h3 id=\"存放Docker映像檔的地方\"><a href=\"#存放Docker映像檔的地方\" class=\"headerlink\" title=\"存放Docker映像檔的地方\"></a>存放Docker映像檔的地方</h3><ul>\n<li>官方的Docker Hub: 預設的下載來源</li>\n<li>非官方的公開Docker Registry：如果你要從這些地方下載，就必須在下載時指定完整的位址名稱，也可能需要該網站的認證金鑰，或是在Docker執行的設定檔中先設定好</li>\n<li>私有的Docker Registry：公司內部可以建立私有的Registry以保證不會用到來源不明的映像檔 </li>\n</ul>\n<h3 id=\"Docker-Hub的個人映像檔名稱\"><a href=\"#Docker-Hub的個人映像檔名稱\" class=\"headerlink\" title=\"Docker Hub的個人映像檔名稱\"></a>Docker Hub的個人映像檔名稱</h3><ul>\n<li>標準的Docker Hub的個人映像檔名稱格式: <user name>/<repo name>:<tag name><ul>\n<li>user name：使用者名稱。在Docker Hub上每個使用者都有一個獨立的名稱</li>\n<li>repo name：倉庫名稱。在Docker Hub上的每一個使用者，都可以建立自己的倉庫，倉庫中可以放多個映像檔。</li>\n<li>tag name：要分辨同一個倉庫中的不同映像檔，就要用tag name來區分。</li>\n</ul>\n<ul>\n<li>如果該倉庫中只有一個映像檔，則tag name可以省略。</li>\n<li>如果該倉庫中有多個映像檔，在沒有指定tag name時，以最新的一個為主。</li>\n<li>同一個映像檔可以有多個tag name，從相同的映像檔ID看，可看做是別名，也可利用做版控。</li>\n</ul>\n</tag></repo></user></li>\n</ul>\n<h3 id=\"Docker-操作指令\"><a href=\"#Docker-操作指令\" class=\"headerlink\" title=\"Docker 操作指令\"></a>Docker 操作指令</h3><ul>\n<li><p>docker info : 列出和系統相關的資訊，如image數、Container數、檔案系統目錄、Linux核心版本，使用Linux版本、CPU及記憶體等。</p>\n</li>\n<li><p>docker version : 列出目前Docker的版本</p>\n</li>\n<li><p>docker images: 列出本機image</p>\n<ul>\n<li>-a：列出完整的image層次資訊。每個映像檔是由不同層次組成的，我們會在稍後說明。</li>\n<li>-q：只列出image id。這在做映像檔批次處理時很方便。</li>\n</ul>\n</li>\n<li><p>docker pull :  就預設從官方的Registry下載(registry.hub.docker.com)(eg. docker pull ubuntu:latest)</p>\n<ul>\n<li>-a: 將某一個倉庫的所有image都下載</li>\n</ul>\n</li>\n<li><p>docker save : 打成tarball(eg. docker save -o demo.tar user/demo)</p>\n<ul>\n<li>-o Write to a file, instead of STDOUT</li>\n</ul>\n</li>\n<li><p>docker load : 載入tarball還原回image(eg. docker load –input demo.tar)</p>\n<ul>\n<li>-i Read from tar archive file, instead of STDIN</li>\n</ul>\n</li>\n<li><p>docker rmi : 刪除映像檔</p>\n<ul>\n<li>-f 強迫刪除</li>\n<li>-no-prune=true這個參數，只殺掉有tag name的image。</li>\n</ul>\n</li>\n<li><p>docker rmi -f $(docker images -aq) : 一次刪掉所有image (Linux的批次指令) </p>\n</li>\n<li><p>docker tag : 給予image 一個tag名稱</p>\n</li>\n<li><p>docker build : 使用 Dockerfile create image </p>\n<ul>\n<li><a href=\"https://docs.docker.com/engine/reference/commandline/build/\" target=\"_blank\" rel=\"noopener\">Docker build Options</a></li>\n</ul>\n</li>\n<li><p>docker history : 查看image歷史紀錄</p>\n</li>\n<li><p>docker push: 上傳image (若沒有登入會提示你輸入帳號、密碼及電子郵件，可以先使用docker login 處理) </p>\n</li>\n</ul>\n<h3 id=\"Docker有關Container的指令\"><a href=\"#Docker有關Container的指令\" class=\"headerlink\" title=\"Docker有關Container的指令\"></a>Docker有關Container的指令</h3><p>Container和image之間的操作:</p>\n<ul>\n<li>commit：將Container的改變存入image</li>\n<li>export：將Container存成快照</li>\n<li>import：從Container快照恢復成image   </li>\n</ul>\n<p>Container執行操作:</p>\n<ul>\n<li>create：建立Container並執行指令</li>\n<li>run：同create<ul>\n<li>-d 背景執行</li>\n<li>-p 對外port號(eg. docker run -p 8080:8080 -p 8081:8081 demo)</li>\n<li>–name Container名稱</li>\n<li>-t：attach時Container的螢幕會接到原來的螢幕上。</li>\n<li>-i：attach時鍵盤輸入會被Container接手<br>註: docker run -it 會切入到要執行 Container內部終端操作介面</li>\n</ul>\n</li>\n<li>kill：刪除執行中的Container，但Container還是存在，只是沒啟動。</li>\n<li>rm：刪除Container(停止或運行中都行)，Container完整移除</li>\n<li>pause：暫停執行中的Container，仍暫有記憶體停，服務不中斷</li>\n<li>unpause：恢復暫停中的Container</li>\n<li>stop：停止執行中的Container，但不暫有記憶體，服務中斷</li>\n<li>start：啟動停止中的Container</li>\n<li>restart：重新啟動Container</li>\n<li>wait：讓Container暫停直到Container停止為止</li>\n<li>rename： 更名Container</li>\n</ul>\n<p>查詢Container的狀態:  </p>\n<ul>\n<li>inspect：檢查Container的狀態</li>\n<li>stats：查看Container的CPU、記憶體及網路使用</li>\n<li>port：查看Container的通訊埠使用</li>\n<li>ps：查看Container使用狀態</li>\n<li>top：查看Container在主系統中的記憶體使用</li>\n<li>dip：查看Container的IP</li>\n<li>dpid：查看Container的pid</li>\n</ul>\n<p>Container執行時的操作:</p>\n<ul>\n<li>docker attach : 進入執行中Container內部終端  (進入可用exit 離開該Container)<br>註: 不建議用，該指令受限於啟動時的參數影響之後的操作結果。如果知道了entrypoint或者有程式正在執行，通過docker attach進入之後是不能執行操作的，因為退出就會終止Container的運行(–sig-proxy=false 需下這個參數防止)。</li>\n<li>docker exec : 在外部向Container內執行指令。推薦使用該指令代替docker attach做日常維運用途</li>\n<li>docker denter ：進入Container</li>\n<li>docker logs ： 將Container內的輸出顯示</li>\n</ul>\n<p>Container和主系統之間的操作:</p>\n<ul>\n<li>cp：複製Container內的檔案到主系統</li>\n<li>diff：列出兩個Container之間檔案系統差異</li>\n<li>events：列出某個時間點之前或之後的事件</li>\n</ul>\n<p>More info: <a href=\"https://www.runoob.com/docker/docker-command-manual.html\" target=\"_blank\" rel=\"noopener\">Docker 命令大全</a></p>\n","categories":["Docker"],"tags":["Docker"]},{"title":"網頁前端設計","url":"/Blog/posts/Development/20210128-java-frontend-system-design.html","content":"<p>寫個記錄。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Responsive-Web-Design-RWD-，-響應式網頁設計\"><a href=\"#Responsive-Web-Design-RWD-，-響應式網頁設計\" class=\"headerlink\" title=\"Responsive Web Design (RWD)， 響應式網頁設計\"></a>Responsive Web Design (RWD)， 響應式網頁設計</h2><ul>\n<li>是一種網頁設計模式，這種設計可使網站在不同的裝置（從桌面電腦顯示器到行動電話或其他行動裝置）上瀏覽時對應不同解析度皆有適合的呈現，減少使用者進行縮放、平移和捲動等操作行為。<br><img src=\"https://upload.wikimedia.org/wikipedia/commons/thumb/0/02/Complete.png/190px-Complete.png\" alt=\"RWD示意圖\"></li>\n</ul>\n<h2 id=\"Single-Page-Application-SPA-，單頁式應用\"><a href=\"#Single-Page-Application-SPA-，單頁式應用\" class=\"headerlink\" title=\"Single Page Application (SPA)，單頁式應用\"></a>Single Page Application (SPA)，單頁式應用</h2><ul>\n<li>利用 AJAX 非同步的特性跟後端同步資料，將不同的資料動態輸向同一個頁面，達到網頁操作不換頁。</li>\n<li>缺點: 是少了後端的渲染回傳，如果使用者操作太快，前端就不能保證每次都能得到正確的 Server 資料（eg. 點進網頁內容，還沒加載完成就點各種功能）。</li>\n<li>需要解決sync與async各項功能的問題</li>\n<li>典型應用: gmail信箱</li>\n</ul>\n<h2 id=\"Server-side-render-SSR-，伺服器端渲染\"><a href=\"#Server-side-render-SSR-，伺服器端渲染\" class=\"headerlink\" title=\"Server side render (SSR)，伺服器端渲染\"></a>Server side render (SSR)，伺服器端渲染</h2><ul>\n<li>為避免 SPA 讓 SEO 變差，先渲染網頁內容，再將後續操作交給 JavaScript，</li>\n<li>使用者一樣能享受到 SPA 不用換頁的好處，不過首次加載的時間增加了。</li>\n<li>在 SSR 的開發上也要需要會一點後端技術。(JSP、Thymeleaf等)</li>\n</ul>\n<h2 id=\"Accelerated-Mobile-Pages-AMP\"><a href=\"#Accelerated-Mobile-Pages-AMP\" class=\"headerlink\" title=\"Accelerated Mobile Pages (AMP)\"></a>Accelerated Mobile Pages (AMP)</h2><ul>\n<li>Google帶領開發的開源專案</li>\n<li>即為「加速行動網頁」，目的是提升行動裝置對網站的存取速度。</li>\n<li>AMP即是透過「規範HTML框架」、「限制JavaScript」、「Google高速緩存」這三種要素，縮小網頁檔案、縮短傳輸時間、降低頁面載入時間。</li>\n<li>只要透過「行動裝置」搜尋時，發現網址前面顯示一個閃電符號⚡️即屬於AMP網頁，通常優先出現在排序前幾名，甚至讓用戶點擊進去等不到一秒，就能看到網頁內容。不僅提高點擊率，也降低了因網頁載入太久的跳出率。</li>\n</ul>\n<h2 id=\"Progressive-Web-App-PWA\"><a href=\"#Progressive-Web-App-PWA\" class=\"headerlink\" title=\"Progressive Web App (PWA)\"></a>Progressive Web App (PWA)</h2><ul>\n<li>2016年 Google提出的概念，PWA的存在是為結合網站和 App 二者的特性，透過網站呈現如 APP 般的瀏覽優點，提供更好的用戶體驗。</li>\n<li>因為PWA的本質是網站，程式語言就是用Html5、Css3、JS。</li>\n<li>沒有跨平台需要不同程式版本的問題，更新內容也是直接從伺服端更改就可以了。</li>\n<li>可靠：即時載入，就算網路狀況欠佳，甚至沒有網路的情況下還是能夠瀏覽。</li>\n<li>快速：畫面流暢且即時回應，提供最佳瀏覽效果。</li>\n<li>吸引度：使用起來如同App一般，帶來人性化的使用體驗。</li>\n<li>不需要透過Google Play或是App Store下載，而是在你瀏覽該網站時，會跳出詢問視窗，當使用者按下同意後，會直接在裝置桌面新增一個快速連結的圖示</li>\n</ul>\n<p>More info: <a href=\"https://zh.wikipedia.org/wiki/%E5%93%8D%E5%BA%94%E5%BC%8F%E7%BD%91%E9%A1%B5%E8%AE%BE%E8%AE%A1\" target=\"_blank\" rel=\"noopener\">RWD wiki</a><br>More info: <a href=\"https://zh.wikipedia.org/wiki/Accelerated_Mobile_Pages\" target=\"_blank\" rel=\"noopener\">AMP wiki</a><br>More info: <a href=\"https://zh.wikipedia.org/wiki/%E6%B8%90%E8%BF%9B%E5%BC%8F%E7%BD%91%E7%BB%9C%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F\" target=\"_blank\" rel=\"noopener\">PWA wiki</a><br>More info: <a href=\"https://blog.sharktech.tw/2018/02/07/google-amp\" target=\"_blank\" rel=\"noopener\">google AMP</a><br>More info: <a href=\"https://web.dev/progressive-web-apps/\" target=\"_blank\" rel=\"noopener\">PWA 官網</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"資料庫Connection pool設定","url":"/Blog/posts/Development/20210217-database-connection-pool.html","content":"<p>相關文章重點整理。</p>\n<a id=\"more\"></a> \n\n<h2 id=\"誤區\"><a href=\"#誤區\" class=\"headerlink\" title=\"誤區\"></a>誤區</h2><p>資料庫連線池的大小越大越好? Ans: 絕對不是</p>\n<h2 id=\"正確觀念\"><a href=\"#正確觀念\" class=\"headerlink\" title=\"正確觀念\"></a>正確觀念</h2><p>(maximumPoolSize: 連線池中允許的最大連線數) 連線數 = ((核心數 * 2) + 有效磁碟數)</p>\n<h2 id=\"主要影響資料庫的效能瓶頸因素\"><a href=\"#主要影響資料庫的效能瓶頸因素\" class=\"headerlink\" title=\"主要影響資料庫的效能瓶頸因素\"></a>主要影響資料庫的效能瓶頸因素</h2><ul>\n<li>CPU</li>\n<li>磁碟 IO (SSD由於不像傳統硬碟需要定址、旋轉碟片，因此更少的阻塞 ，會更近似於CPU核心數)</li>\n<li>網路 IO </li>\n<li>SQL語法 </li>\n</ul>\n<p><a href=\"https://www.itread01.com/content/1547137124.html\" target=\"_blank\" rel=\"noopener\">資料庫連線池DataSource (解釋連線池為何要使用)</a><br><a href=\"https://www.mdeditor.tw/pl/2FBd/zh-tw\" target=\"_blank\" rel=\"noopener\">如何正確設定資料庫連線池的大小？</a><br><a href=\"https://www.youtube.com/watch?v=xNDnVOCdvQ0\" target=\"_blank\" rel=\"noopener\">OLTP Performance - Concurrent Mid-Tier Connections (Oracle Learning Youtube)</a><br><a href=\"https://github.com/brettwooldridge/HikariCP\" target=\"_blank\" rel=\"noopener\">HikariCP 設定參數 (Github)</a><br><a href=\"https://www.mdeditor.tw/pl/piUT/zh-tw\" target=\"_blank\" rel=\"noopener\">HikariCP 設定參數 (翻譯)</a><br><a href=\"https://github.com/brettwooldridge/HikariCP/wiki/About-Pool-Sizing\" target=\"_blank\" rel=\"noopener\">About Pool Sizing - HikariCP (Github)</a><br><a href=\"https://www.itread01.com/content/1548895884.html\" target=\"_blank\" rel=\"noopener\">Springboot datasource 常用配置說明</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"悲觀鎖與樂觀鎖(資料庫交易)","url":"/Blog/posts/Development/20210201-locking-pessimistic-optimistic.html","content":"<p>之前遇上的問題，劃個重點留個整理記錄。</p>\n<a id=\"more\"></a>\n\n<p>資料庫交易特性ACID中的交易隔離(Isolation)通常利用「鎖(locking)」來實現，目的為避免同一筆資料在併行交易(concurrent transaction)中被不同的交易同時修改以確保資料的完整性。<br>交易鎖又分為「悲觀鎖(pessimistic locking)」與「樂觀鎖(optimistic locking)」。</p>\n<p>常用鎖處理的例子: 電商商品庫存、銀行轉帳業務</p>\n<p>##悲觀鎖(Pessimistic Locking)<br>時機: 悲觀並行控制主要用於資料爭用激烈的環境或發生並發衝突時，”使用鎖保護資料的成本”要低於”回復交易的成本”的環境中。</p>\n<ul>\n<li>悲觀並行控制實際上是「先取鎖再訪問」的保守策略，為資料處理的安全提供了保證。</li>\n<li>在效率方面，處理加鎖的機制會讓資料庫產生額外的開銷，還有增加產生”死鎖”的機會</li>\n<li>在只讀型交易處理中由於不會產生衝突，就沒必要使用鎖，這樣做只能增加系統負載，還有會降低了並行性。</li>\n<li>一個交易如果鎖定了某行資料，其他交易就必須等待該交易處理完才可以處理那行資料。(當下資料有對其他執行存取有排他性)<br>典型的使用: synchronized (java)</li>\n</ul>\n<p>##樂觀鎖(Optimistic Locking)<br>時機: 樂觀並行控制多數用於”資料爭用不大”、”衝突較少的環境”中，”偶爾回復交易的成本”會低於”讀取資料時鎖定資料的成本”，因此可以獲得”比其他並行控制方法更高的吞吐量”。</p>\n<ul>\n<li>假設”多使用者並行的交易在處理時不會彼此互相影響”，”各交易能夠在不產生鎖”的情況下”處理各自影響的那部分資料”。在提交資料更新之前，每個交易會”先檢查在該交易讀取資料後，有沒有其他交易又修改了該資料”。如果其他交易有更新的話，正在提交的交易會進行rollback。</li>\n</ul>\n<p>缺點: 樂觀並行控制相信交易之間的資料競爭(data race)的概率是比較小的，因此儘可能直接做下去，直到提交的時候才去鎖定，所以不會產生任何鎖和死結。但如果直接簡單這麽做，還是有可能會遇到不可預期的結果，例如兩個交易都讀取了資料庫的某一行，經過修改以後寫回資料庫，這時就遇到了問題。(ABA问题) </p>\n<ul>\n<li>需要添加重試機制，舉個例子: 資料異動時衝突(JPA中的@version)，重新在執行失敗的動作</li>\n</ul>\n<h4 id=\"樂觀並行控制的交易包括以下階段：\"><a href=\"#樂觀並行控制的交易包括以下階段：\" class=\"headerlink\" title=\"樂觀並行控制的交易包括以下階段：\"></a>樂觀並行控制的交易包括以下階段：</h4><ul>\n<li>讀取：交易將資料讀入快取，這時系統會給交易分派一個時間戳。</li>\n<li>校驗：交易執行完畢後，進行提交。這時同步校驗所有交易，如果交易所讀取的資料在讀取之後又被其他交易修改，則產生衝突，交易被中斷回復。</li>\n<li>寫入：通過校驗階段後，將更新的資料寫入資料庫。<br>典型的使用: Compare and Swap (CAS)、 AtomicReference class、 @Version(Java JPA中的@version 版本控制處理方式)</li>\n</ul>\n<p>##總結<br>樂觀鎖適用於讀大於寫、衝突少的的場景(省去了鎖的開銷，加大了系統的整個吞吐量。如果經常產生衝突，上層應用會不斷的進行retry可能須考慮是否用悲觀鎖)<br>悲觀鎖寫大於讀、衝突大的的場景(併發量不大且不允許髒讀適合)</p>\n<p>more info:<a href=\"https://www.cnblogs.com/kismetv/p/10787228.html\" target=\"_blank\" rel=\"noopener\">資料參考</a><br>more info:<a href=\"https://en.wikipedia.org/wiki/Optimistic_concurrency_control\" target=\"_blank\" rel=\"noopener\">Optimistic Concurrency wiki</a><br>more info:<a href=\"https://zh.wikipedia.org/wiki/%E6%82%B2%E8%A7%82%E5%B9%B6%E5%8F%91%E6%8E%A7%E5%88%B6\" target=\"_blank\" rel=\"noopener\">Pessimistic Concurrency wiki</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"電信業即時計費系統Domain knowledge","url":"/Blog/posts/Development/20210128-java-telecommunications-system-design.html","content":"<p>某電信業即時計費系統簡易系統設計Domain knowledge描述，大概整理下。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"門號申裝流程\"><a href=\"#門號申裝流程\" class=\"headerlink\" title=\"門號申裝流程\"></a>門號申裝流程</h2><ol>\n<li>電信申租門號(月租型、預付卡)</li>\n<li>選號(手機號碼)</li>\n<li>服務方案、優惠(後頭供裝在特定門號優惠服務)</li>\n<li>門號啟用(使門號生效進行打電話、上網等服務)</li>\n</ol>\n<p>服務內容包括:</p>\n<ul>\n<li>資費設定、變更資費</li>\n<li>用量查詢</li>\n<li>計費周期(BillCycle)，出帳的週期</li>\n<li>加值服務(數據加包價購，預付卡儲值等)</li>\n<li>用量簡訊(到達特定亮時給予提醒)</li>\n<li>到期簡訊(服務到期、數據包到期、預付卡到期等)</li>\n<li>用罄簡訊(eg. 上網數據包用罄發送通知)</li>\n<li>服務群組設定</li>\n<li>優惠內容設定</li>\n</ul>\n","categories":["Development"],"tags":["Development"]},{"title":"連線DB2有時會遇上java.io.CharConversionException","url":"/Blog/posts/Development/20211127-DB2-CharConversionException.html","content":"<p>之前做的案子遇啟動時或連接時，有時候會遇上的問題，與資料編碼轉相關，留個解法。</p>\n<a id=\"more\"></a>\n\n<p>問題:<br>db2.jcc.charsetDecoderEncoder=3 so that instead of throwing an exception the JCC driver returns the Unicode REPLACEMENT CHARACTER (U+FFFD) in place of a sequence of bytes that is not a valid UTF-8 string</p>\n<p>解法:<br>在java_opts後面加上參數(-Ddb2.jcc.charsetDecoderEncoder=3)<br>註: 在tomcat或JBoss啟動放上參數即可</p>\n<h3 id=\"參考\"><a href=\"#參考\" class=\"headerlink\" title=\"參考:\"></a>參考:</h3><p>more info:<a href=\"https://stackoverflow.com/questions/42685541/sqoop-error-for-java-io-charconversionexception-which-is-non-utf-8-charactor\" target=\"_blank\" rel=\"noopener\">Sqoop error for java.io.charconversionException which is non UTF-8 charactor</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"Shallow Copy VS Deep Copy (JavaScript)","url":"/Blog/posts/JavaScript/20210127-java-script-obj-copy.html","content":"<p>Shallow Copy VS Deep Copy　</p>\n<a id=\"more\"></a>\n\n<p><img src=\"http://i.imgur.com/abBTAP3.png\" alt=\"Shallow Copy VS Deep Copy\"></p>\n<ul>\n<li>Shallow Copy(淺拷貝): 只複製指向某個物件的指標，而不複製物件本身，新舊物件還是共用同一塊記憶體。</li>\n<li>Deep Copy(深拷貝): 會另外創造一個一模一樣的物件，新物件跟原物件不共用記憶體，修改新物件不會改到原物件內容。</li>\n</ul>\n<h2 id=\"如何-Deep-Copy\"><a href=\"#如何-Deep-Copy\" class=\"headerlink\" title=\"如何 Deep Copy\"></a>如何 Deep Copy</h2><ol>\n<li>手動複製(建立一個物件，手動把值弄進去)</li>\n<li>Object.assign(ES6語法，該語法先建立一個空物件，再把指定值塞進去，限單層，多層需另外處理)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj1 &#x3D; &#123; a: 1, b: 2, c: 3 &#125;;</span><br><span class=\"line\">var obj2 &#x3D; Object.assign(&#123;&#125;, obj1);</span><br><span class=\"line\">obj2.b &#x3D; 100;</span><br><span class=\"line\">console.log(obj1); &#x2F;&#x2F; &#123; a: 1, b: 2, c: 3 &#125; &lt;-- 值不變</span><br><span class=\"line\">console.log(obj2); &#x2F;&#x2F; &#123; a: 1, b: 100, c: 3 &#125;</span><br></pre></td></tr></table></figure>\n<ol start=\"3\">\n<li>轉成 JSON 再轉回來(用JSON.stringify把物件轉成字串，再用JSON.parse把字串轉成新的物件，多層可以，有function情境不可，function沒辦法轉成JSON)</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj1 &#x3D; &#123; fun: function()&#123; console.log(123) &#125; &#125;;</span><br><span class=\"line\">var obj2 &#x3D; JSON.parse(JSON.stringify(obj1));</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(typeof obj1.fun); &#x2F;&#x2F; &#39;function&#39;</span><br><span class=\"line\">console.log(typeof obj2.fun); &#x2F;&#x2F; &#39;undefined&#39; &lt;-- 會undefined，</span><br></pre></td></tr></table></figure>\n\n<ol start=\"4\">\n<li>透過library處理，此處用JQuery處理</li>\n</ol>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">var obj1 &#x3D; &#123;</span><br><span class=\"line\">    a: 1,</span><br><span class=\"line\">    b: &#123; f: &#123; g: 2 &#125; &#125;,</span><br><span class=\"line\">    c: [4, 5, 6]</span><br><span class=\"line\">&#125;;</span><br><span class=\"line\"></span><br><span class=\"line\">var obj2 &#x3D; $.extend(true, &#123;&#125;, obj1);</span><br><span class=\"line\">console.log(obj1.b.f &#x3D;&#x3D;&#x3D; obj2.b.f); &#x2F;&#x2F; false</span><br></pre></td></tr></table></figure>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"資料庫的問題","url":"/Blog/posts/Development/20210118-database-expansion-1.html","content":"<p>遇上的資料庫相關效能處理問題，處理方式記錄。</p>\n<a id=\"more\"></a>\n\n<h3 id=\"讀寫分離架構\"><a href=\"#讀寫分離架構\" class=\"headerlink\" title=\"讀寫分離架構\"></a>讀寫分離架構</h3><p>master : 主要用寫的服務，會與 slave進行資料同步。<br>slave : 主要用來讀的服務。</p>\n<ul>\n<li>適用於讀多寫少情況。</li>\n</ul>\n<h3 id=\"分表\"><a href=\"#分表\" class=\"headerlink\" title=\"分表\"></a>分表</h3><ul>\n<li>時機: 單表資料量太大讀寫遇上瓶頸，增加slave、優化索引仍然無法解決時。</li>\n</ul>\n<h3 id=\"分庫\"><a href=\"#分庫\" class=\"headerlink\" title=\"分庫\"></a>分庫</h3><ul>\n<li>時機: 單機讀寫遇上瓶頸，增加slave、優化索引仍然無法解決時。</li>\n<li>目的就在於減少單台資料庫讀寫的負擔，縮短查詢時間。</li>\n</ul>\n<h3 id=\"DB遇上瓶頸，初步判斷各種可能的解決方法\"><a href=\"#DB遇上瓶頸，初步判斷各種可能的解決方法\" class=\"headerlink\" title=\"DB遇上瓶頸，初步判斷各種可能的解決方法\"></a>DB遇上瓶頸，初步判斷各種可能的解決方法</h3><ul>\n<li>IO<ul>\n<li>磁盤讀IO瓶頸，熱點資料太多，資料庫cache放不下，每次查詢時會產生大量的IO，降低查詢速度。<ul>\n<li>圖片、檔案、影片等不存資料庫，降低負擔(檔案放入Amazon S3、FTP server等做存取，DB只做該檔案資料純文字索引)。</li>\n<li>讀寫分離</li>\n<li>另外架cache server 降低資料庫負擔(eg. Redis)。</li>\n<li>分庫和垂直分表 </li>\n</ul>\n</li>\n<li>網絡IO瓶頸，請求的資料太多，網絡帶寬不夠 <ul>\n<li>減少一次請求的資料(這比較實際，有些工程師為了方便一次性查詢把所有資料查回來，但該階段根本用不到的資料(圖片、影片等單次請求)也一起回來了)</li>\n<li>分庫</li>\n</ul>\n</li>\n</ul>\n</li>\n<li>CPU<ul>\n<li>SQL問題，如SQL中包含join，group by，order by，非索引字段條件查詢等，增加CPU運算的操作<ul>\n<li>建立合適的索引，在Application layer進行計算(不透過資料庫處理複雜運算)。</li>\n</ul>\n</li>\n<li>單表資料量太大，查詢時掃描的行太多，SQL效率低，增加CPU運算的操作 <ul>\n<li>水平分表(使用者人數多的時候有機會遇到，根據資料熱點區間分散)。</li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"總結\"><a href=\"#總結\" class=\"headerlink\" title=\"總結\"></a>總結</h2><p>須根據系統實際狀況處理，沒有一定法則。<br>以下是過取處理案子時的處理方式:</p>\n<ul>\n<li>選擇處理方案優先序:<ol>\n<li>Application layer(應用程式問題)</li>\n<li>檔案相關IO</li>\n<li>快取設計(資料預熱、增加快取Server)、 獨立資料表、靜態常數化(該資料為常用資料)</li>\n<li>讀寫分離(主要調整資料庫設定)</li>\n<li>分區(Partition， 分割資料表，與水平分表(針對資料創資料表)類似但有不同，針對資料內容經由資料庫創建資料的分區，例如: 1~100 1區)</li>\n<li>分表</li>\n<li>分庫</li>\n<li>分庫分表(最不得以的情況，通常這調整幅度比較大，包含資料庫和應用程式的調整)</li>\n</ol>\n</li>\n</ul>\n<p>參考: <a href=\"https://ithelp.ithome.com.tw/articles/10226783\" target=\"_blank\" rel=\"noopener\">資料庫層的擴展 - 讀寫分離架構</a><br>參考: <a href=\"https://ithelp.ithome.com.tw/articles/10227066\" target=\"_blank\" rel=\"noopener\">資料庫層的擴展 - 分庫分表架構</a><br>參考: <a href=\"https://codertw.com/%E7%A8%8B%E5%BC%8F%E8%AA%9E%E8%A8%80/742272/\" target=\"_blank\" rel=\"noopener\">數據庫怎麼分庫分表，垂直？水平？</a><br>參考: <a href=\"https://kknews.cc/zh-tw/news/abvzkex.html\" target=\"_blank\" rel=\"noopener\">資料庫分庫分表，何時分？怎樣分？</a></p>\n","categories":["Development"],"tags":["Development"]},{"title":"Callback hell 處理(jQuery,Promise, async/await)","url":"/Blog/posts/JavaScript/20210128-java-callback-hell.html","content":"<p>在某家壽險業解過這類似的鬼東西，整理一下解釋。</p>\n<a id=\"more\"></a>\n\n<p>如圖:<br>** 示意圖 **<br><img src=\"https://d1dwq032kyr03c.cloudfront.net/upload/images/20181014/201103713ObcIuaSP4.jpg\" alt=\"Callback hell\"></p>\n<p>-必須兼容IE處理方式:</p>\n<ul>\n<li>jQuery 的方式處理</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">$.ajax(&#123;參數&#125;)</span><br><span class=\"line\">.then(callback_A)</span><br><span class=\"line\">.then(callback_B)</span><br><span class=\"line\">.then(callback_C)</span><br></pre></td></tr></table></figure>\n\n<p>適合解法</p>\n<ul>\n<li>Promise (ES6 的語法)<br>![Promise] (<a href=\"https://cdn.rawgit.com/Vectaio/a76330b025baf9bcdf07cb46e5a9ef9e/raw/26c4213a93dee1c39611dcd0ec12625811b20a26/js-promise.svg\" target=\"_blank\" rel=\"noopener\">https://cdn.rawgit.com/Vectaio/a76330b025baf9bcdf07cb46e5a9ef9e/raw/26c4213a93dee1c39611dcd0ec12625811b20a26/js-promise.svg</a>)</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">const promise1 &#x3D; new Promise((resolve, reject) &#x3D;&gt; &#123;</span><br><span class=\"line\">  setTimeout(() &#x3D;&gt; &#123;</span><br><span class=\"line\">    resolve(&#39;foo&#39;);</span><br><span class=\"line\">  &#125;, 300);</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">promise1.then((value) &#x3D;&gt; &#123;</span><br><span class=\"line\">  console.log(value);</span><br><span class=\"line\">  &#x2F;&#x2F; expected output: &quot;foo&quot;</span><br><span class=\"line\">&#125;);</span><br><span class=\"line\"></span><br><span class=\"line\">console.log(promise1);</span><br><span class=\"line\">&#x2F;&#x2F; expected output: [object Promise]</span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>async/await (ES7的語法)，可與Promise混合使用</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">async function a()&#123;</span><br><span class=\"line\">  await b();</span><br><span class=\"line\">  .....       &#x2F;&#x2F; 等 b() 完成後才會執行</span><br><span class=\"line\">  await c();</span><br><span class=\"line\">  .....       &#x2F;&#x2F; 等 c() 完成後才會執行</span><br><span class=\"line\">  await new Promise(resolve&#x3D;&gt;&#123;</span><br><span class=\"line\">    .....</span><br><span class=\"line\">  &#125;);</span><br><span class=\"line\">  .....       &#x2F;&#x2F; 上方的 promise 完成後才會執行</span><br><span class=\"line\">&#125;</span><br><span class=\"line\">a();</span><br><span class=\"line\">a().then(()&#x3D;&gt;&#123;</span><br><span class=\"line\">  .....       &#x2F;&#x2F; 等 a() 完成後接著執行</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n\n<p>參考: <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Global_Objects/Promise\" target=\"_blank\" rel=\"noopener\">Promise MDN文件</a><br>參考: <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Statements/async_function\" target=\"_blank\" rel=\"noopener\">async MDN文件</a><br>參考: <a href=\"https://developer.mozilla.org/zh-TW/docs/Web/JavaScript/Reference/Operators/await\" target=\"_blank\" rel=\"noopener\">await MDN文件</a><br>參考: <a href=\"https://www.oxxostudio.tw/articles/201908/js-async-await.html\" target=\"_blank\" rel=\"noopener\">簡單理解 JavaScript Async 和 Await</a></p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"reCAPTCHA v3(Google)","url":"/Blog/posts/JavaScript/20211003-javascript-reCAPTCHA-v3.html","content":"<p>這個是reCAPTCHA v3 跟v2的做法不太一樣，這作法是為了使用者別再點”我不是機器人”的等類似的選項，是對使用者體驗是個好事，<br>不過這分數的機制作法，在某些情況可能會誤判，各家瀏覽器分數不太一樣。(目前僅供demo UI 樣式)</p>\n<a id=\"more\"></a>\n\n<p>reCAPTCHA v3多了特有的 2 個值：action、score，其中這個分數越高代表非機器人。</p>\n<ul>\n<li>action: 送驗證時要填的，限填英文、數字、斜線。當作「貼標籤」來用，為這次的驗證貼上一個標籤，在後台的報表中會看到。</li>\n<li>store: 後端向 Google 發 POST 後，response 裡會帶上的值，數值是 0 到 1的範圍。(  0 代表是機器人，1 代表是真人。)</li>\n</ul>\n<p>拿到Token後進行後台驗證(會用到私鑰)， <a href=\"https://developers.google.com/recaptcha/docs/verify\" target=\"_blank\" rel=\"noopener\">Verifying the user’s response</a> 。</p>\n<script src=\"https://www.google.com/recaptcha/api.js?render=6Lc7RKQcAAAAACuaIO-vd-Gi2mEMU9MdQBTvFg2Z\" async defer>\n</script>\n\n<p>HTML code :</p>\n<script>\n   function onSubmit(token) {\n     alert(\"送去後端驗證用的token: \" + token);\n   }\n</script>\n<p><button class=\"g-recaptcha\" data-sitekey=\"6Lc7RKQcAAAAACuaIO-vd-Gi2mEMU9MdQBTvFg2Z\" data-callback=\"onSubmit\" data-action=\"submit\">提交</button></p>\n<p>參考: <a href=\"https://support.google.com/a/answer/1217728?hl=zh-Hant\" target=\"_blank\" rel=\"noopener\">什麼是人機驗證 (Captcha)？</a><br>參考: <a href=\"https://medium.com/@d101201007/google-recaptcha%E6%A9%9F%E5%99%A8%E4%BA%BA%E9%A9%97%E8%AD%89-%E6%95%99%E5%AD%B8-php%E7%AF%84%E4%BE%8B-3685a394dce2\" target=\"_blank\" rel=\"noopener\">Google reCAPTCHA機器人驗證 教學 PHP範例</a><br>參考: <a href=\"https://www.google.com/recaptcha/about/\" target=\"_blank\" rel=\"noopener\">recaptcha Google 官網</a><br>參考: <a href=\"https://developers.google.com/recaptcha/docs/v3\" target=\"_blank\" rel=\"noopener\">reCAPTCHA v3</a><br>參考: <a href=\"https://recaptcha-demo.appspot.com/\" target=\"_blank\" rel=\"noopener\">recaptcha-demo.appspot.com</a><br>參考: <a href=\"https://letswritetw.github.io/letswrite-recaptcha-v3/gas.html\" target=\"_blank\" rel=\"noopener\">reCAPTCHA v3 使用範例</a></p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"reCAPTCHA v2(Google)","url":"/Blog/posts/JavaScript/20230415-javascript-reCAPTCHA-v2.html","content":"<p>最近專案碰到的東西，研究一下該驗證機制的應用。</p>\n<a id=\"more\"></a>\n\n<p>reCAPTCHA v2 目前普遍網站使用者常看到的模式，以下為google 提供的範例demo執行後的樣子。(目前僅供demo UI 樣式)</p>\n<p>拿到Token後進行後台驗證(會用到私鑰)， <a href=\"https://developers.google.com/recaptcha/docs/verify\" target=\"_blank\" rel=\"noopener\">Verifying the user’s response</a> 。</p>\n<script src=\"https://www.google.com/recaptcha/api.js?onload=onloadCallback&render=explicit\" async defer>\n</script>\n\n\n<script type=\"text/javascript\">\nvar site_key = \"6LcGY6QcAAAAAD3IvqNqOPVW_l0U_3IeChVOL6nt\";\n      var verifyCallback = function(response) {\n        alert(response);\n      };\n      var widgetId1;\n      var widgetId2;\n      var onloadCallback = function() {\n        // Renders the HTML element with id 'example1' as a reCAPTCHA widget.\n        // The id of the reCAPTCHA widget is assigned to 'widgetId1'.\n        widgetId1 = grecaptcha.render('example1', {\n          'sitekey' : site_key,\n          'theme' : 'light'\n        });\n        widgetId2 = grecaptcha.render(document.getElementById('example2'), {\n          'sitekey' : site_key\n        });\n        grecaptcha.render('example3', {\n          'sitekey' : site_key,\n          'callback' : verifyCallback,\n          'theme' : 'dark'\n        });\n      };\n</script>\n\n<!-- The g-recaptcha-response string displays in an alert message upon submit. -->\n<form action=\"javascript:alert(grecaptcha.getResponse(widgetId1));\">\n   <div id=\"example1\"></div>\n   <br>\n     <input type=\"submit\" value=\"getResponse\">\n</form>\n<br>\n<!-- Resets reCAPTCHA widgetId2 upon submit. -->\n<form action=\"javascript:grecaptcha.reset(widgetId2);\">\n<div id=\"example2\"></div>\n<br>\n<input type=\"submit\" value=\"reset\">\n</form>\n<br>\n<!-- POSTs back to the page's URL upon submit with a g-recaptcha-response POST parameter. -->\n<form action=\"?\" method=\"POST\">\n <div id=\"example3\"></div>\n   <br>\n   <input type=\"submit\" value=\"Submit\">\n</form>\n\n<p>參考: <a href=\"https://support.google.com/a/answer/1217728?hl=zh-Hant\" target=\"_blank\" rel=\"noopener\">什麼是人機驗證 (Captcha)？</a><br>參考: <a href=\"https://medium.com/@d101201007/google-recaptcha%E6%A9%9F%E5%99%A8%E4%BA%BA%E9%A9%97%E8%AD%89-%E6%95%99%E5%AD%B8-php%E7%AF%84%E4%BE%8B-3685a394dce2\" target=\"_blank\" rel=\"noopener\">Google reCAPTCHA機器人驗證 教學 PHP範例</a><br>參考: <a href=\"https://www.google.com/recaptcha/about/\" target=\"_blank\" rel=\"noopener\">recaptcha Google 官網</a><br>參考: <a href=\"https://developers.google.com/recaptcha/docs/v3\" target=\"_blank\" rel=\"noopener\">reCAPTCHA v3</a></p>\n","categories":["JavaScript"],"tags":["JavaScript"]},{"title":"Ubuntu install deb file","url":"/Blog/posts/Linux/20201231-Ubuntu-cmd-dpkg.html","content":"<p>RedHat, Centos 這系列的是用rpm在裝，因為一些個人需求開始用ubuntu，弄個紀錄。 </p>\n<a id=\"more\"></a>\n\n<h3 id=\"dpkg\"><a href=\"#dpkg\" class=\"headerlink\" title=\"dpkg\"></a>dpkg</h3><p>Ubuntu軟體包格式為deb,安裝方法如下:</p>\n<figure class=\"highlight bash\"><table><tr><td class=\"code\"><pre><span class=\"line\"></span><br><span class=\"line\">sudo dpkg -i xxxxx.deb (安裝用root權限，xxxx檔案名稱) or dpkg -i xxxxx.deb </span><br><span class=\"line\"></span><br><span class=\"line\">其他指令參考:</span><br><span class=\"line\">dpkg -r xxxxx 刪除該包</span><br><span class=\"line\">dpkg -P xxxxx 刪除該包(包括配置檔案)</span><br><span class=\"line\">dpkg -L xxxxx 列出與該包關聯的檔案</span><br><span class=\"line\">dpkg -l xxxxx 顯示該包的版本</span><br><span class=\"line\">dpkg –unpack xxxxx.deb 解壓 deb</span><br><span class=\"line\">dpkg -S xxxxx 搜尋所屬的包內容</span><br><span class=\"line\">dpkg -l 列出當前已安裝的deb</span><br><span class=\"line\">dpkg -c xxxxx.deb 列出 deb 包的內容</span><br><span class=\"line\">dpkg –configure xxxxx 配置包</span><br><span class=\"line\">man dpkg 詳細指令</span><br></pre></td></tr></table></figure>\n\n\n","categories":["Linux"],"tags":["Ubuntu"]},{"title":"如果root忘了密碼(Centos 6)","url":"/Blog/posts/Linux/20210127-Linux-shell-root-password.html","content":"<p>#如果root忘了密碼，過單用戶模式重設root帳號的密碼，進入到單用戶模式，root不用密碼就可以登入</p>\n<a id=\"more\"></a>\n\n<p>步驟:<br>開機時在引導時輸入enter-&gt;看到介面輸入e-&gt;選擇kernel-&gt;<br>輸入e-&gt; 在這這行最後面寫 1-&gt;再輸入enter -&gt; 再輸入小b(單用戶模式)-&gt;可以修改root密碼(passwd)</p>\n<p>#安全性的疑慮:<br>用這招必須在當台電腦或機房前才有用(遠程無用)</p>\n<p>More info: <a href=\"https://kknews.cc/zh-tw/code/k9oxl6q.html\" target=\"_blank\" rel=\"noopener\">其他版本相關</a></p>\n","categories":["Linux"],"tags":["Linux"]},{"title":"網卡IP查詢","url":"/Blog/posts/Linux/20210127-Linux-shell-ip.html","content":"<p>#網卡IP查詢</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Window\"><a href=\"#Window\" class=\"headerlink\" title=\"Window\"></a>Window</h2><ul>\n<li>ipconfig</li>\n</ul>\n<h2 id=\"Ubuntu-CentOS\"><a href=\"#Ubuntu-CentOS\" class=\"headerlink\" title=\"Ubuntu, CentOS\"></a>Ubuntu, CentOS</h2><ul>\n<li>ifconfig</li>\n<li>假如指令無效net-tools需要裝</li>\n</ul>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">sudo apt install net-tools</span><br></pre></td></tr></table></figure>\n","categories":["Linux"],"tags":["Linux"]},{"title":"Maven中的dependency的Scope功用","url":"/Blog/posts/Maven/20201124-maven-dependancy-scope.html","content":"<p>Maven中的dependency的Scope功用</p>\n<a id=\"more\"></a>\n\n<p>###compile</p>\n<p> 預設值，jar是所有階段需要， 部署時將一起被打包到jar/war裡面。</p>\n<p>###test</p>\n<p>此jar檔只有在測試時才需要使用，部署時將不會打包到jar/war裡面。如 junit jar 等。</p>\n<h3 id=\"runtime\"><a href=\"#runtime\" class=\"headerlink\" title=\"runtime\"></a>runtime</h3><p>表示此jar在運行時，才需要使用。如jdbc jar等。</p>\n<p>###provided</p>\n<p>運行時該jar檔由JDK、Tomcat及jboss等來提供。如 servlet.jar、jsp-api.jar 等。<br> 部署時將不會打包到jar/war裡面。</p>\n<h3 id=\"system\"><a href=\"#system\" class=\"headerlink\" title=\"system\"></a>system</h3><p>jar檔由系統提供，跟provided相似。在maven repository是無法找到，須提供需指定systemPath來使用。<br>以外部JAR檔的形式提供。</p>\n<h3 id=\"import\"><a href=\"#import\" class=\"headerlink\" title=\"import\"></a>import</h3><p>僅支援<dependencyManagement>區塊中且type僅為pom</dependencyManagement></p>\n<p>dependencyManagement 和 dependencies的使用區別:</p>\n<ul>\n<li>dependencyManagement裡只是聲明依賴，並不實現引入，因此子項目需要顯示的聲明需要用的依賴。</li>\n<li>如果不在子項目中聲明依賴，是不會從父項目中繼承下來的。</li>\n<li>只有在子項目中寫了該依賴項且沒有指定具體版本，才會從讀取父項目中的pom繼承該項 version和scope。如果子項目中指定了版本號，那麼會使用子項目中指定的jar版本。</li>\n</ul>\n<p>More info: <a href=\"https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html\" target=\"_blank\" rel=\"noopener\">Maven Scope</a></p>\n","categories":["Maven"],"tags":["Maven"]},{"title":"Java 8 to 17 各版本功能變化","url":"/Blog/posts/Java/20210926-java-feature-version-history.html","content":"<p>有鑑於國外Java更新已經到那麼遠了，整理一些資訊留存，以便後續追蹤新版本功能特色的資料。</p>\n<p>more info:<a href=\"https://advancedweb.hu/a-categorized-list-of-all-java-and-jvm-features-since-jdk-8-to-17/\" target=\"_blank\" rel=\"noopener\">A categorized list of all Java and JVM features since JDK 8 to 17</a><br>more info:<a href=\"https://openjdk.java.net/projects/jdk/\" target=\"_blank\" rel=\"noopener\">JDK Project(openjdk官網)</a><br>more info:<a href=\"https://github.com/Snailclimb/JavaGuide/blob/master/docs/java/new-features/java%E6%96%B0%E7%89%B9%E6%80%A7%E6%80%BB%E7%BB%93.md\" target=\"_blank\" rel=\"noopener\">java新特性总结.md</a></p>\n","categories":["Java"],"tags":["Java"]},{"title":"時間同步(網路校時)","url":"/Blog/posts/Linux/20210127-Linux-shell-sync-time.html","content":"<p>CentOS 時間同步</p>\n<a id=\"more\"></a>\n\n<h2 id=\"CentOS-6\"><a href=\"#CentOS-6\" class=\"headerlink\" title=\"CentOS 6\"></a>CentOS 6</h2><figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">ntpdate pool.ntp.org # ntpdate [ip]</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"CentOS-8-7開始提供使用Chrony\"><a href=\"#CentOS-8-7開始提供使用Chrony\" class=\"headerlink\" title=\"CentOS 8 (7開始提供使用Chrony)\"></a>CentOS 8 (7開始提供使用Chrony)</h2><ul>\n<li>使用Chrony</li>\n</ul>\n<p>安裝</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">yum install chrony</span><br></pre></td></tr></table></figure>\n\n<p>啟動</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl start chronyd.service 或  systemctl start chronyd</span><br></pre></td></tr></table></figure>\n\n<p>設置開機後就自動執行</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl enable chronyd.service 或  systemctl enable chronyd</span><br></pre></td></tr></table></figure>\n\n<p>設定檔位於路徑 </p>\n<ul>\n<li>/etc/chrony.conf</li>\n</ul>\n<p>預設值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server 0.centos.pool.ntp.org iburst</span><br><span class=\"line\">server 1.centos.pool.ntp.org iburst</span><br><span class=\"line\">server 2.centos.pool.ntp.org iburst</span><br><span class=\"line\">server 3.centos.pool.ntp.org iburst</span><br></pre></td></tr></table></figure>\n\n<p>想改用台灣本地的時間主機，如下台灣本地的時間主機</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">server tock.stdtime.gov.tw prefer</span><br><span class=\"line\">server tick.stdtime.gov.tw</span><br><span class=\"line\">server time.stdtime.gov.tw</span><br></pre></td></tr></table></figure>\n\n<p>查看 chronyd運行狀態</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl status chronyd.service</span><br></pre></td></tr></table></figure>\n\n<p>查看 chronyc 校時來源server</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chronyc sources</span><br></pre></td></tr></table></figure>\n\n<p>查看 chronyc 校時來源server狀態</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chronyc sourcestats</span><br></pre></td></tr></table></figure>\n\n<p>查看最後一次取得的校時資料</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chronyc tracking</span><br></pre></td></tr></table></figure>\n\n<p>如果系統時間與網路時間差異較大，不想等chrony慢慢校時，手動執行強制校時指令 </p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">chronyc -a makestep</span><br></pre></td></tr></table></figure>\n\n<p>More info:<a href=\"http://linux.vbird.org/linux_server/0440ntp/0440ntp-centos5.php#ntpdate\" target=\"_blank\" rel=\"noopener\">ntpdate from 鳥哥</a><br>More info: <a href=\"https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/7/html/system_administrators_guide/ch-configuring_ntp_using_the_chrony_suite#sect-differences_between_ntpd_and_chronyd\" target=\"_blank\" rel=\"noopener\">RedHat chrony vs ntpdate 差異</a><br>More info:<a href=\"https://kknews.cc/zh-tw/code/8ga39xl.html\" target=\"_blank\" rel=\"noopener\">RHEL8或CentOS8上配置NTP伺服器和客戶端</a><br>More info:<a href=\"https://blog.gtwang.org/linux/linux-ntp-installation-and-configuration-tutorial/\" target=\"_blank\" rel=\"noopener\">Linux 設定 NTP 同步系統時間，自動網路校時教學</a></p>\n","categories":["Linux"],"tags":["Linux"]},{"title":"運行級別 CentOS(6, 7)修改","url":"/Blog/posts/Linux/20210127-Linux-shell-runlevel.html","content":"<p>不同版本用法不太一樣</p>\n<a id=\"more\"></a>\n\n<p>運行級別</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\"># Default runlevel. The runlevels used are:</span><br><span class=\"line\">#   0 - halt (Do NOT set initdefault to this)</span><br><span class=\"line\">#   1 - Single user mode</span><br><span class=\"line\">#   2 - Multiuser, without NFS (The same as 3, if you do not have networking)</span><br><span class=\"line\">#   3 - Full multiuser mode</span><br><span class=\"line\">#   4 - unused</span><br><span class=\"line\">#   5 - X11</span><br><span class=\"line\">#   6 - reboot (Do NOT set initdefault to this)</span><br></pre></td></tr></table></figure>\n<p>** 從一種運行模式可以切換到另一種運行模式 **</p>\n<ul>\n<li>重啟系統切換運行級別<ul>\n<li>命令行模式——&gt;圖形界面模式：init 5</li>\n<li>圖形界面模式——&gt;命令行模式：init 3</li>\n</ul>\n</li>\n<li>臨時切換<ul>\n<li>命令行模式——&gt; 圖形界面模式：startx</li>\n<li>圖形界面模式——&gt;命令行模式：在X-window圖形操作界面中按Ctrl+Alt+Fn(n=1-6) 就可以進入Console字符操作界面。按Ctrl+Alt+F7即可回到剛才的X-window中。 </li>\n</ul>\n</li>\n</ul>\n<h1 id=\"CentOS-6\"><a href=\"#CentOS-6\" class=\"headerlink\" title=\"CentOS 6\"></a>CentOS 6</h1><p>修改/ etc / inittab文件中的重置運行等級即可。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">vim &#x2F;etc&#x2F;inittab</span><br></pre></td></tr></table></figure>\n\n<p>修改內容後，重新啟動。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">#默認命令模式</span><br><span class=\"line\">id:3:initdefault:</span><br><span class=\"line\"></span><br><span class=\"line\">#默認GUI模式</span><br><span class=\"line\">id:5:initdefault:</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"CentOS-7\"><a href=\"#CentOS-7\" class=\"headerlink\" title=\"CentOS 7\"></a>CentOS 7</h1><p>改用Systemd處理了，原有的inittab已無用<br>systemd使用targets的取代了原有的運行級別runlevels。</p>\n<p>默認兩個主要目標：</p>\n<ul>\n<li>multi-user.target  = 原來的運行級別3</li>\n<li>graphic.target = 原來的運行級別5</li>\n</ul>\n<p>查看默認的運行等級</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl get-default</span><br></pre></td></tr></table></figure>\n\n<p>** 設置默認的運行等級 **</p>\n<p>切換命令模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl isolate multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p>切換 GUI模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl isolate graphical.target</span><br></pre></td></tr></table></figure>\n\n<p>設定開機啟動至命令模式（runlevel 3）</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl set-default multi-user.target</span><br></pre></td></tr></table></figure>\n\n<p>設定開機啟動至 GUI 模式</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"code\"><pre><span class=\"line\">systemctl set-default graphical.target</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://www.cnblogs.com/rouqinglangzi/p/11077443.html\" target=\"_blank\" rel=\"noopener\">參考(Centos修改默认运行级别)</a><br>More info: <a href=\"http://technote.aven-network.com/852/using-systemctl-control-target\" target=\"_blank\" rel=\"noopener\">使用 systemctl 操作系統層級 target</a></p>\n","categories":["Linux"],"tags":["Linux"]},{"title":"Spring註解 @Component @Service, @Controller, @Repository","url":"/Blog/posts/Java/20210201-spring-annotation-component.html","content":"<p>以前留下整理的資料的記錄。</p>\n<a id=\"more\"></a>\n\n<h2 id=\"spring註解\"><a href=\"#spring註解\" class=\"headerlink\" title=\"spring註解\"></a>spring註解</h2><p>@Component, @Service, @Controller, @Repository是spring註解，註解後可以被spring框架所掃描並註入到spring容器來進行管理</p>\n<ul>\n<li>@Component是通用註解，其他三個註解是這個註解的拓展，並且具有了特定的功能(generic stereotype for any Spring-managed component)。</li>\n<li>@Repository註解在持久層中，具有將數據庫操作拋出的原生異常翻譯轉化為spring的持久層異常的功能。(stereotype for persistence layer)</li>\n<li>@Controller層是spring-mvc的註解，具有將請求進行轉發，重定向的功能。(stereotype for presentation layer)</li>\n<li>@Service層是業務邏輯層註解，這個註解只是標註該類處於業務邏輯層。 (stereotype for service layer)<br>用這些註解對應用進行分層之後，就能將請求處理，義務邏輯處理，數據庫操作處理分離出來，為代碼解耦，也方便了以後項目的維護和開發。</li>\n</ul>\n<p>註解:<br>Spring2.0時提供的: @Repository(在Spring2.5有修改部分內容)<br>Spring2.5時提供的: @Component, @Controller, @Service</p>\n<p>more info:<a href=\"https://stackoverflow.com/posts/6897038/edit\" target=\"_blank\" rel=\"noopener\">stackoverflow 參考</a><br>more info:<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Repository.html\" target=\"_blank\" rel=\"noopener\">@Repository doc</a><br>more info:<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Component.html\" target=\"_blank\" rel=\"noopener\">@Component doc</a><br>more info:<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Controller.html\" target=\"_blank\" rel=\"noopener\">@Controller doc</a><br>more info:<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/stereotype/Service.html\" target=\"_blank\" rel=\"noopener\">@Service doc</a></p>\n","categories":["Java"],"tags":["Java","Spring"]}]